issue
fast_gnp_random_graph doesn't sample directed edges uniformly, wrong way of avoiding loop edges#TITLE_END#I've noticed the following small mistake in the generation of the Erdős-Rényi graph.  The current way to avoid loop edges is to just take the next node if a loop edge would be generated: https://github.com/networkx/networkx/blob/master/networkx/generators/random_graphs.py#L101  However, this way the edge `(v, v+1)` has twice the probability as any other edge. This non-uniformity can be very easily demonstrated on small graphs: ``` neighbors_of_0 = [] for i in range(1000):     G = networkx.generators.random_graphs.fast_gnp_random_graph(4, 0.2, directed=True)     for (i,j) in G.edges:         if i == 0:             neighbors_of_0.append(j) print(np.bincount(neighbors_of_0) / 1000)  # output: array([0.   , 0.351, 0.203, 0.197]) ```  Note: I don't quite understand why, but it appears empirically that the probability is not actually two times the others, but hovers around ~3.5. I think I'm missing something. Edit*: Yes, in fact it's not exactly twice. In the loop-edges-included model, p((v,v+1)) is the sum of immediately arriving at (v,v+1) (skipping (v,v)) plus arriving at (v,v) and then at (v,v+1), while here the probability is the sum of the probability of arriving at (v,v) and the probability of arriving at (v,v+1) given that (v,v) is not included.  I believe this must have been introduced as a response to the following issue (when the generation of loop edges was excluded): https://github.com/networkx/networkx/issues/575  The cited paper [1] doesn't cover the proper way of excluding loop edges as far as I can tell. I believe one way of doing it correctly would be to generate the node `w` from `[0, n-2]` instead of `[0, n-1]` and use edge  `(v, w) if w < v else (v, w+1)`.  [1] Vladimir Batagelj and Ulrik Brandes, "Efficient generation of large random networks"
