issue
A better returning value for draw_networkx_edges#TITLE_END#`draw_networkx_edges` returns either `LineCollection` or `arrow_collection` (which is a list of `FancyArrowPatch`) depending on whether the given graph is `DiGraph` and `arrows=True`.  The documentation says ``` matplotlib.collection.LineCollection     `LineCollection` of the edges  list of matplotlib.patches.FancyArrowPatch     `FancyArrowPatch` instances of the directed edges ```  Internally, the function is short-circuited by checking whether the `edgelist` is empty: ```python if not edgelist or len(edgelist) == 0:  # no edges!     return None ```  Wouldn't it be better if  ```python if not edgelist or len(edgelist) == 0:  # no edges!     if G.is_directed() and arrows:         return []     else:         return LineCollection(None) ```  Currently, the documentation does not mention that it returns `None` if no edge is drawn.   p.s. `draw_networkx_labels` returns an empty set if nothing is drawn. `draw_networkx_nodes` returns `None` but it may be able to return `PathCollection(None)` since documentation did not specify its behavior.   p.p.s. I am using `zip(edgelist, arcs)` after `arcs = draw_networkx_edges...`. It would be better to have an empty list than `None` which needs an additional check. 
issue
Fix return values when drawing empty nodes and edges  #3833#TITLE_END#drawing an empty collection of nodes returns an empty PathCollection. drawing an empty collection of edges returns (i) an empty LineCollection if neither a given graph is a directed graph nor `arrows` is enabled, (ii) an empty list, otherwise.
issue
Fix return values when drawing empty nodes and edges  #3833#TITLE_END#drawing an empty list of nodes will return an empty PathCollection drawing an empty list of edges will return (i) an empty LineCollection if neither graph is DiGraph nor arrows option is enabled, (ii) an empty list otherwise. 
issue
wrong shrink_source calculation in draw_networkx_edges#TITLE_END#I would like to talk about a problem with drawing edges for `DiGraph` (`draw_networkx_edges`).  `shrink_source` is treated differently from `shrink_target`. It would be natural to think that there is no arrow at the source since an arrow is drawn from a source to a target! However, one may want to use < - - > bidirected dashed arrows, for example. If `shrink_source` is not treated the same as `shrink_target`, the arrow tip at the source will be buried under the source node.  Hence, the following modification is suggested: ```python shrink_source = 0  # space from source to tail shrink_target = 0  # space from  head to target  if np.iterable(node_size):  # many node sizes     src_node, dst_node = edgelist[i][:2]     shrink_source = to_marker_edge(node_size[nodelist.index(src_node)], node_shape)     shrink_target = to_marker_edge(node_size[nodelist.index(dst_node)], node_shape) else:     shrink_source = shrink_target = to_marker_edge(node_size, node_shape)  if shrink_source < min_source_margin:     shrink_source = min_source_margin  if shrink_target < min_target_margin:     shrink_target = min_target_margin ```  Then, the modified code can yield a correctly-styled graph. ```python import networkx as nx g = nx.DiGraph() g.add_nodes_from({'X','Y'}) g.add_edges_from([('X','Y')])  pos = nx.nx_pydot.pydot_layout(g, prog='dot') nx.draw_networkx_nodes(g, pos, node_color='#ffffff', edgecolors='#000000') nx.draw_networkx_edges(g, pos) nx.draw_networkx_labels(g, pos)  g2 = nx.DiGraph() g2.add_nodes_from({'X','Y'}) g2.add_edges_from([('X','Y')]) nx.draw_networkx_edges(g2, pos, style='dashed', arrowstyle='<|-|>', arrows=True, connectionstyle=ConnectionStyle.Arc3(rad=0.5))  g3 = nx.DiGraph() g3.add_nodes_from({'X','Y'}) g3.add_edges_from([('X','Y')]) nx.draw_networkx_edges(g3, pos, style='dotted', arrowstyle='-|>', arrows=True, connectionstyle=ConnectionStyle.Arc3(rad=-0.5)) plt.show() ``` <img width="164" alt="Screen Shot 2020-01-30 at 11 52 10 PM" src="https://user-images.githubusercontent.com/4041206/73513460-8f479580-43bb-11ea-9f08-cef77ead26fe.png">  
issue
Shrink the source side of an arrow properly when drawing a directed edge. #3805#TITLE_END#A user may want to draw bidirected edges. e.g., CurveFilledAB	<|-|> in `matplotlib.patches.FancyArrowPatch`  Hence, `shrink_source` needs to be calculated as `shrink_target` is determined. 
issue
Fix #2726: ensure add_path to add the first node#TITLE_END#Fixes #2726   If the given path (list of nodes) is of length one, `add_path` will add the first node.
issue
Add a node when add_path involves no edge.#TITLE_END#`add_path` is convenient for adding edges without adding nodes explicitly. Consider a case where there exists no edge to be added:  ``` G = nx.Graph() nx.add_path(G, [0]) ``` If one wants to test the neighbors of a node in a graph, `G.neighbors(0)` will throw networkx.exception.NetworkXError: The node 0 is not in the graph.  Obviously, one can check whether the argument for `add_path` is a singleton and explicitly do  ``` path = [0]  # or something else G = nx.Graph() if len(path) == 1:     G.add_node(path[0])   nx.add_path(G, path) G.neighbors(0) ```  Should adding a zero-edge path with a single node add a node in the graph if the node isnâ€™t already in the graph? This also applies to `add_star`.
issue
'alpha' parameter is unused in `draw_networkx_labels`#TITLE_END#Each of `draw_networkx_labels` and `draw_networkx_edge_labels` in `networkx.drawing.nx_pylab` defines `alpha` as a parameter, but the passed argument is not used in the code failing to generate transparent text. 
issue
maximal matching documentation#TITLE_END#networkx.algorithms.matching.maximal_matching is documented as   "Find a maximal cardinality matching in the graph."  If it is just "maximal matching", then the use of 'cardinality' seems confusing. Since the algorithm is not "maximum cardinality" matching.  For example, given a graph 'c'--'a'--'b'--'d'  the method might return {('a', 'b')} as a maximal matching, which is not a maximum cardinality matching {('a', 'c'),('b', 'd')}.  ``` import networkx as nx g=nx.Graph() g.add_edge('b','a') g.add_edge('c','a') g.add_edge('b','d') print(nx.maximal_matching(g)) ```  (The above test depends on the order of edges, which is not deterministic. If you get two edges as a result, you might restart python console and rerun the code.)  Could you remove 'cardinality' from the document? 
