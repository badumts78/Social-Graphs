issue
changed edge weights for max weight matching and added test#TITLE_END#As discussed [here](https://github.com/networkx/networkx/pull/6112#issuecomment-1295263707) we are splitting up the PR into two.  Fixes https://github.com/networkx/networkx/issues/5952   - Changed the way the edge weights are computed in `eulerize` function along the lines with the discussion of #5952 so that the minimum possible number of new edges is added in the resulting graph.  - Added a test using the graph from the discussion 
comment
Hi all,  I am interested in this issue and have a couple of remarks/questions.  > It does not seem to be just a matter of a large number of cycles.  How many simple cycles do you expect `g1.json` graph to have?  The algorithm seems to progress on `g1.json` albeit slowly. When I tested it on `g1.json`, it stayed in this [while](https://github.com/networkx/networkx/blob/bcf607cf7ce4009ca37786b2fcd84e548f1833f5/networkx/algorithms/cycles.py#L195) loop for the first time for a few hours but eventually it did leave it and `startnode` was changed. I didn't run it until the end, since it looked like a job for more powerful computer(s).  The implementation of the function `simple_cycles` seems to follow to a great extent the pseudocode from the original [paper ](https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF) except that it is not recursive.  I find it correct provided that all the dependencies (like the computation of _strongly connected components_) are implemented correctly and the algorithm proposed in the paper is correct which I think we have no reason to doubt.  Finally, the number of simple cycles in directed graphs can grow quite rapidly even when adding a single edge. For example, there exists a directed graph with $4000$ vertices with no simple cycle, but adding a single edge introduces at least $2^{1000}$ simple cycles.  cc: @steven-nicolaou @paulitapb 
comment
I haven't observed any memory leak while enumerating cycles of g1 for several hours. Since the function is a generator, storing simple cycles in memory throughout its execution is not necessary. Therefore I am not sure where the problem could be.
comment
Hi all, I would be happy to fix this small bug (as a first time contributor) in case nobody plans to work on it and possibly also implement the generalization in the direction of [the Route inspection problem](https://en.wikipedia.org/wiki/Route_inspection_problem) with the option _"... to start and end at specified vertices_ ..." in case this is still of interest.  cc @dschult, @claudinepeyrat06
comment
I guess you meant `t = nx.algorithms.tree.mst.random_spanning_tree(nx.Graph(np.array(G)))` rather than `t = nx.algorithms.tree.mst.random_spanning_tree(G)`.  I am not sure how you got your `t` matrix.  The problem might just be that the nodes are permuted in `t.nodes()` of type `NodeView` with respect to `graph.nodes()`.  One can (re)-construct the tree `t` differently, so that the nodes are ordered in the same way as in `G` like as follows: ``` t = nx.algorithms.tree.mst.random_spanning_tree(nx.Graph(np.array(G)))  T = [[0]*len(t.nodes()) for _ in range(len(t.nodes()))]  for u, v in t.edges():     T[u][v], T[v][u] = 1, 1  t = nx.Graph(np.array(T)) ``` Would that solve the problem?
