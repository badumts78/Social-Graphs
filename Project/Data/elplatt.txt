issue
greedy_modularity_communities handling of ties#TITLE_END#Created a separate issue for the below comment. This could be a bug, although I am not certain. Either way, we should make the code clearer.  > I have another question, although not super important. >  > Can this statement be False? >  > <https://github.com/networkx/networkx/blob/d475ffe7b24633934b5e566974fe7e72a9400cf4/networkx/algorithms/community/modularity_max.py#L126> >  > If i, j merge has the best dq, is it possible for the j-row to have as its 1st item a better one? Wouldn't that be the one popped from H at that iteration, instead of i, j? From some examples I run locally, it never goes to else. >  > _Originally posted by @ThanasisMattas in https://github.com/networkx/networkx/issues/3112#issuecomment-892005572_
issue
draw_networkx_edges() incorrect xlim and ylim#TITLE_END#When plotting only edges using draw_networkx_edges(), the xlim and ylim are not correct and cut off part of the visualization.  Example: ``` import networkx as nx G = nx.karate_club_graph() pos = nx.spring_layout(G) nx.draw_networkx_edges(G, pos) ``` <img width="395" alt="screen shot 2019-01-13 at 10 30 08 am" src="https://user-images.githubusercontent.com/308312/51087221-3c526000-171e-11e9-8c96-8605ebf81286.png"> 
issue
Remove axis ticks and tick labels from default network visualization#TITLE_END#The axis ticks are districting and in most cases unnecessary.
issue
Add Clauset-Newman-Moore modularity-max community detection#TITLE_END#    * Adds modularity_max module to networkx.algorithms.community package     * Adds greedy_modularity_communities() function with CNM implementation     * Adds test using Zachary karate club network     * Add networkx.utils.mapped_queue used by the above implementation     * Add tests for networkx.utils.mapped_queue 
issue
Remove ticks and tick labels from draw_networkx(), close #3254.#TITLE_END#* Removes left and bottom ticks and tick labels for draw_networkx() and all related draw_networkx_*() functions.
issue
Default color for draw_networkx() is not colorblind-safe#TITLE_END#Currently black labels on red background, which can't be read by some red-green colorblind individuals (including myself). The safest would be to go with a blue color. Any objections?
issue
Make default node color colorblind-safe, close #3233.#TITLE_END#* Switches default node color in draw_networkx_nodes() to #1f78b4 from the ColorBrewer colorblind-safe qualitative palette.
issue
Add option to automatically draw node labels#TITLE_END#It would be convenient to have an optional parameter to draw() to automatically draw labels. I'm going to implement this, and opening this ticket to track.  Current plan: * Add label=False as optional parameter to draw * If true, call draw_networkx_labels() using the node ids cast to strings and the same positioning as the nodes.
issue
Add greedy modularity maximization community detection.#TITLE_END#* Adds modularity_max module to networkx.algorithms.community package  * Adds greedy_modularity_communities() function  * Adds test using Zachary karate club network.
issue
Add greedy modularity maximization community detection.#TITLE_END#    * Adds modularity_max module to networkx.algorithms.community package      * Adds greedy_modularity_communities() function      * Adds test using Zachary karate club network.
comment
Hi all! After looking over this, #5000 and #5065, here's what I see:  * ~~The rounding is occurring when dq is converted to -dq, and the key error occurs when -(-dq) != dq.~~ * ~~The problem is that some of the MappedQueues use dq as a key and some use -dq.~~ * It looks like @dschult's test case works in the latest code as of @ThanasisMattas's commit 3a44d3ec7593358778a2336a5ec2faf5afe49da9, although I think the rounding problem still potentially exists in that code.  I know that @dschult and @tristanic have already been collaborating on fixing the bug by separating the MappedQueue element priority from the element itself. However, I'd like to see if I can write a fix that preserves the performance a little better, as performance is one of the main reasons this community detection algorithm is used. It may involve adding a "reverse_priority" flag or something similar to MappedQueue. I'll post a pull request sometime in the next few days.  **Update** We were wrong about dq and -dq being the issue. Turns out -(-dq)) is always exactly equal to dq in standard floating point arithmetic. More details on the actual problem in my comment below.
comment
While this issue has been resolved a long time, I've always been curious about the cause of the original bug. I finally got around to looking into it. Here's what I found, just in case it ends up being helpful for future dev or debugging.  There were actually two distinct bugs. Both in the following code:  https://github.com/networkx/networkx/blob/2eb274e39f712047cebf5666ee9caf2ba2e51ee4/networkx/algorithms/community/modularity_max.py#L93-L101  Bug 1 was on line 95 in the call to `get_edge_data()`. The arguments are indexes rather than node labels, which was causing some of the `KeyError` exceptions.  Bug 2 was indeed a floating point error. Because floating point multiplication is not associative, on line 96, the term `resolution * k[i] * [j]` was not always symmetric in i and j. This sometimes resulted in a `KeyError` later on, in the following code. After the best merge has been popped from the front of `H`, it is then removed from the per-community queues `dq_heap[i]` and `dq_heap[j]`:  https://github.com/networkx/networkx/blob/2eb274e39f712047cebf5666ee9caf2ba2e51ee4/networkx/algorithms/community/modularity_max.py#L122-L133  The problem occurs on line 133 in the call to `dq_heap[j].remove()`. When `(-dq, i, j)` is taken from the front of `H`, the value of `dq` is the same that was used to populate `dq_heap[i]`. But due to the associativity issue on line 96, that `dq` value might vary slightly from the one in `dq_heap[j]`. This was causing the rest of the `KeyError` exceptions.  The fix sidestepped these issues by changing the way `MappedQueue` works. The change eliminating indexes and instead using node labels was a good call and I probably should have done that in the first place. As for the symmetric elements `(-dq, i, j)` and `(-dq, j, i)` not being equal, I think if I wrote it again I'd enforce equality by making them identical, instead using `(-dq, frozenset([i, j]))`. A little more complex, but it would have prevented the need to remove duplicates and made it impossible to violate the symmetry assumption.
comment
Hi all, just became aware of this issue. I wrote the MappedQueue class so please feel free to tag me in any related issues.  I think there is something else going on here that hasn't been identified yet. Using floating point values as keys should be fine as long as no arithmetic is done on them once they have been used as a key. There shouldn't be any rounding occurring. Which line is causing the KeyErrors? If anyone can give me a test case I'm happy to look into it. I actually have a little time this month I could put towards this.
comment
Thanks! I'll take a look.
comment
CNM is Clauset-Newman-Moore, the authors of the algorithm.
comment
What is the issue with the mapped_queue keys?  On Sat, Sep 4, 2021, 9:41 PM Dan Schult ***@***.***> wrote:  > I'm going to merge this. I has the 2 approvals so that makes sense, but I > wanted to think about whether it was easier to merge before or after the > fixing of the floating point keys in the mapped_queue dict. I understand > that problem better now and have a solution -- but more relevant to this, I > think it will be easier to merge this first... then work to put the other > fix into the code alreay working with DiGraph and MultiGraph. > > Thanks for this code @ThanasisMattas <https://github.com/ThanasisMattas> > and for the help with the other modularity issues! > > ‚Äî > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/pull/5007#issuecomment-913068995>, > or unsubscribe > <https://github.com/notifications/unsubscribe-auth/AACLIWGLM77FJCY6RYO3UHTUALDDZANCNFSM5BSARYFA> > . > Triage notifications on the go with GitHub Mobile for iOS > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> > or Android > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. > > 
comment
As written, I believe it only works with undirected graphs. It only needs a little extra code to work with weighted and directed graphs though, maybe I'll see if I can work on that over the next couple weeks.  As for multigraphs, is there a well-defined concept of "weight" between two nodes? Or a standard networkx way of defining a weight function? If so, the above changes would probably allow the code to work for multigraphs as well.  On Sun, Aug 5, 2018 at 11:21 AM, Dan Schult <notifications@github.com> wrote:  > @elplatt <https://github.com/elplatt> is this designed to work with > directed graphs? > If not, we should put the @not_implemented_for('directed') decorator on > the function. Also helpful to know if it is supposed to work for > multigraphs. > > ‚Äî > You are receiving this because you were mentioned. > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/issues/3112#issuecomment-410527238>, > or mute the thread > <https://github.com/notifications/unsubscribe-auth/AAS0WIMTY2hjkrKkEpCSui3kvvpDHgQzks5uNw1tgaJpZM4VvVfU> > . >    --  Edward L. Platt PhD Candidate, University of Michigan School of Information he/him | https://elplatt.com | @elplatt | @elplatt@social.coop  Tips for stopping email overload: https://hbr.org/2012/02/stop-email-overload-1 
comment
Wanted to give an update that I'm working on this. Have derived the equations for weighted undirected with self-loops and working on directed. If anyone is interested in helping write test cases, that would really help!
comment
Here are the equations for both directed and undirected networks, allowing self-loops: https://github.com/elplatt/Paper-CNM-Modularity/blob/master/paper.pdf  I will be implementing these soon, and it would be really helpful to have some test data for possible configurations (directed w/ self-loops, directed wo/ self-loops, etc.). Ideally this would come from hand-calculating the algorithm for a small network (probably not too hard in a spreadsheet but a bit tedious). Anyone able to help?
comment
I believe it still supports only undirected graphs. It's still something I plan to do, unless someone else gets to it first, but I'm focused on phd work right now and won't likely have a chance to look at it for several months. The necessary changes are fairly simple and detailed in the pdf I link above. Changing the modularity calculation always comes with the potential to introduce calculation errors, so the bulk of the work is in creating the appropriate test cases.
comment
Hi @ThanasisMattas, thanks so much for helping out with this! The (1+ùõø) term might make more sense if you group it with the factor of 1/2. In the sums of equations (1) and (2), there will be one term in the sum for each element of the adjacency matrix A. Edges between different nodes end up getting double counted: if there is a weight 1 edge between nodes 5 and 6, you get a term for A_5,6 and A_6,5. The 1/2 term in front is to correct for the double counting. The self-edges don't get double counted though: for example, there is only one A_3,3 term in the sum. The (1+ùõø) cancels out the 1/2 in the case of self-edges. It's a correction for the correction.  For your second question. Merging any community to itself will never change the modularity, so it doesn't need to be considered or tracked in the priority queue. Self-edges can potentially contribute to the Œî for merging different communities though.  Hope these answers help!
comment
Interesting question. Looking closer, I think it could be false in the event of a tie. For example, `dq_heap[j].h[0]` might be `(-dq, j, k)` for some `k` with `dq_heap[j].h[1] = (-dq, j, i)`. I'm not sure the current code handles that case correctly. This might be a pre-existing bug. It's also possible that there's some clever invariant that ensures that case never happens, but if so, it should be made explicit. This should probably be a separate bug report, and shouldn't hold up the current work.
comment
This looks good to me. The test for non-contiguous labels should probably be moved into its own function for clarity.
comment
Probably easy for the quality module. In the modularity_max module, the change in modularity is calculated at each step, rather than the modularity itself. The formulas for the modularity updates would need to be determined for both directed and undirected networks.
comment
Can you explain the need for the rounding? It seems like that would change the resulting modularity calculation.
comment
With the rounding removed, this looks good to me. It would be nice though to have a test of the generalized formula against some hand-calculated values. The current tests only checks that the new greedy_modularity_communities() matches the new modularity(), which wouldn't catch an error that occurs in both.
