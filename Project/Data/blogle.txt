comment
Reviving a stagnant issue, but I wrote a modified Boruvka algorithm based on this [paper](https://hal.archives-ouvertes.fr/file/index/docid/583120/filename/preprint.pdf) which uses KDTree queries to connect disjoint components. The code is specialized for the domain of [optimizing electricity network design](https://github.com/SEL-Columbia/NetworkBuild) but I'd be happy to refactor it for a more general purpose interface, if you guys are interested in it. Its great in that it escapes the O(n^2) space complexity.  
comment
Heres a quick prototype of the API  %pylab inline figsize(12, 8)  n = 10 G = nx.random_graphs.complete_graph(n) coords = np.random.uniform(-20, 20, [n, 2]) nx.set_node_attributes(G, 'coords', dict(enumerate(coords))) nx.draw(G, nx.get_node_attributes(G, 'coords’))  ![attachment](https://cloud.githubusercontent.com/assets/4959802/5307883/8c74527a-7bdf-11e4-98fc-87e84c81a321.png)  G.remove_edges_from(G.edges()) G.add_edges_from(bvka_mst_edges(G)) nx.draw(G, nx.get_node_attributes(G, 'coords’))  ![attachment](https://cloud.githubusercontent.com/assets/4959802/5307912/dac4ebb0-7bdf-11e4-9abe-be33747c24c5.png)  supporting code (bvka is at bottom, rest is just utilities) https://gist.github.com/blogle/30e0e88ceb963f6557f7 
comment
So the only issue is that the SciPy KDTree (and cKDTree) doesn't have a method for constraining the query to a subset of the nodes. Therefore the only way to find these neighbors is to iteratively increase k until the query returns a node in that subset. This is fine on smaller graphs but extremely expensive on larger graphs where there might be one large component that only has a few potential nodes that it can connect to before completing the MST.  Heres a benchmark comparing my KDTree vs the cKDTree in querying all the nodes for their nearest neighbor constrained within the first five nodes. The x-axis is #nodes and y-axis is processing time in seconds. ![unknown](https://cloud.githubusercontent.com/assets/4959802/5317425/dae65b9e-7c64-11e4-8239-99bbea7b5180.png)  netopt is my KDTree, and netoptP is the same tree but queries are made in parallel. 
comment
The cKDTree implementation is over my head given my minimal cython experience. After looking at the standard KDTree, I am surprised that they do in fact store the 'children' under each branch which is required in my method. While the implementations are fairly different, I will start a discussion over there to see if they will hold my hand in adding the functionality. It would be great to outsource this dependency  to SciPy, especially so other developers in my lab don't have to maintain it. 
