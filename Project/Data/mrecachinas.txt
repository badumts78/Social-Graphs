issue
Add panther++#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  As discussed, follow on to #3886.  This PR implements the Panther++ algorithm from https://doi.org/10.1145/2783258.2783267. In particular, a couple decisions were made to improve the algorithm's performance: - I noticed during testing that the similarities were not normalized to [0, 1], so I'm now normalizing to the maximum similarity value. - Also noticed that small graphs and some edge cases were causing NaNs, so I added another epsilon value to avoid that, and converted any lingering NaNs to 1.0 (which should never happen I think).   - Note: I didn't reuse the epsilon parameter because for a sufficiently small graph, that value could be 1.0, which I think would be entirely too large for a reasonable epsilon.  <hr />  - [x] Need to figure out how to convert `similarities` (i.e., `1 / || theta(v_i) - theta(v_j) ||`) into a true similarity metric. Perhaps just normalized to between 0 and 1? - [x] Probably should pull out the common core of `panther_similarity` and `panther_similarity_pp` - [x] Add tests - [x] ~Rename `panther_similarity` to `panther_path_similarity`?~ Changing to `panther_similarity_pp`. - [x] ~Find a better place for `generate_random_paths`?~ Leaving for now. 
issue
Update approx current_flow betweenness to use k directly#TITLE_END#Rough pass at a fix for #6188.
issue
Add Panther algorithm per #3849#TITLE_END#This addresses #3849.  A couple remaining questions:  * Is there a better home for `generate_random_paths`? Itâ€™s a generic Markovian random walk that could be used elsewhere. Alternatively, if this already exists or there's a more efficient approach, I'm all ears. * I used `numpy` for a bit of this. Is there a desire to have a pure Python version as well (like `simrank_similarity` vs `simrank_similarity_numpy`)? * Should `n_choose_k` be elsewhere or perhaps should we use `scipy.special.binom` instead? * Do we want Panther++ added (requires a KD-tree, which we can use from `scipy.spatial`)?
issue
Add two versions of Simrank similarity#TITLE_END#This PR supersedes #1691 as it pulls in changes (and fixes merge conflicts) from the baseline since 2015 and it also includes tests.  Furthermore, Iâ€™ve added a pure numpy matrix calculation of SimRank as another function available for use in similarity.py.  cc @jfinkels @hagberg 
comment
ðŸ‘‹ Was looking through some open issues and came across this one. I took a glance at the paper, implementation, and #6143. Do you think wording like the following would make sense?  ```     epsilon: float         Absolute error tolerance. Note that smaller values of epsilon lead to          higher numbers of sample pairs (`k`) and thus more computation time. The number         of sample pairs is approximately `(c/epsilon)^2 * log(n)` where `n` is the          number of nodes. ```  Otherwise, I don't see a way to check against `epsilon` unless we effectively hardcoded what "big" looks like (i.e., basically hardcoding `kmax` within the function itself) and suggested increasing `epsilon` accordingly if it exceeds that threshold. That doesn't seem ideal though ðŸ¤” 
comment
Took a swing at what it might look like to remove using `epsilon` directly. Based on my read of the algorithm in the paper, it shows `k` (parameter for number of sample pairs) being computed from `epsilon`, as you mentioned. I think it's reasonable to _not_ expose `epsilon` when users can achieve the same result by specifying `k` directly. See https://github.com/networkx/networkx/pull/8007 for what it looks like.
comment
@dschult @storopoli Let me know if #3886 is sufficient.
comment
@storopoli - Note: I didn't implement Panther++ (i.e., vector similarity), just Panther (i.e., path similarity).
comment
Sorry @storopoli -- see #4400 for Panther++ ðŸ™‡ 
comment
@bigpapame Take a look at [nx.contracted_nodes](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.minors.contracted_nodes.html).  If I'm understanding correctly, you want to combine nodes (while still preserving edges) with ids 0, 4, 5, and 6 (specifically, based on having `shu.edu.tw` in the domain name). If that's your goal, you'd probably do something like:  ```python G = nx.read_gml(...) print(G.nodes) # => NodeView(('https://www.shu.edu.tw/', 'https://www.facebook.com', 'https://www.instagram.com', 'https://www.youtube.com', 'http://cc.web.shu.edu.tw', 'http://donate.web.shu.edu.tw', 'http://english.shu.edu.tw'))  # note: this will merge the nodes such that only "https://www.shu.edu.tw/" will remain # also note: copy=False will modify the graph in-place nx.contracted_nodes(G, "https://www.shu.edu.tw/", "http://cc.web.shu.edu.tw", copy=False) nx.contracted_nodes(G, "https://www.shu.edu.tw/", "http://donate.web.shu.edu.tw", copy=False) nx.contracted_nodes(G, "https://www.shu.edu.tw/", "http://english.shu.edu.tw", copy=False)  print(G.nodes) # => NodeView(('https://www.shu.edu.tw/', 'https://www.facebook.com', 'https://www.instagram.com', 'https://www.youtube.com')) ```  If you wanted to do it based on checking the label, you'd just need to loop over `G.nodes`, something like:  ```python G = nx.read_gml(...) print(G.nodes) # => NodeView(('https://www.shu.edu.tw/', 'https://www.facebook.com', 'https://www.instagram.com', 'https://www.youtube.com', 'http://cc.web.shu.edu.tw', 'http://donate.web.shu.edu.tw', 'http://english.shu.edu.tw'))  # copy the list of nodes, since we're modifying # G.nodes as we iterate nodes = list(G.nodes) for u in nodes:     for v in nodes:         if u != v and G.has_node(u) and G.has_node(v) and "shu.edu.tw" in u and "shu.edu.tw" in v:             nx.contracted_nodes(G, u, v, copy=False) print(G.nodes) # => NodeView(('https://www.shu.edu.tw/', 'https://www.facebook.com', 'https://www.instagram.com', 'https://www.youtube.com')) ```  Just to explain the loop a bit: The `u != v` is because we don't want to waste time combining a node with itself. The `G.has_node(u)` and `G.has_node(v)` is because we're modifying the graph as we're looping through. Since we aren't updating our extracted `nodes` list, we want to make sure to skip already combined nodes. The `"shu.edu.tw" in u` and `"shu.edu.tw" in v` is to combine nodes based on a common domain name.  Note: `nx.contracted_nodes` also has a kwarg `self_loop=True/False` for keeping or getting rid of self-loops (i.e., by default, edges between `u` and `v` with turn into self-loops).
comment
What version of `networkx` are you using? It looks like the `copy` keyword argument was added in 2.5. If you're using an older version of networkx, you can simply assign the returned contracted graph to a variable, like the following:  ```python G = nx.contracted_nodes(G, u, v) ``` 
comment
`nx.contracted_nodes` will merge the weights and edges for an `nx.Graph` (I believe the last contracted node will "win" -- i.e., override the edge weight); however, I think `nx.contracted_nodes` _will_ maintain all edges and associated weights for a `nx.MultiGraph`.
comment
@jfinkels @hagberg What's the status of this PR?
comment
Hi @arshiya-singh -- did you ever solve this? If not, what happens if you try `pip uninstall networkx` and then `pip install networkx` or `pip install -U networkx`?  I tried to reproduce this error in an Ubuntu 16.04 Docker container with Python 3.7, but networkx installed correctly.
comment
What environment are you in and what Python are you using?  My first thought is I'd recommend making sure the `pip` you're using corresponds to the `python` you're using. If you have multiple versions of Python globally installed, they can pretty easily become out of sync. (FWIW, to avoid this case, I usually try to use virtual environments or be explicit with which binary I'm calling -- e.g., `pip2` vs `pip3` and `python2` vs `python3`.)  A quick way to rule this out is to run:  ``` $ python -V Python 2.7.15 $ pip -V pip 18.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7) ```  If this checks out, and you still can't run `python -c "import networkx"`, I'd then see where `pip` installed `networkx`. You can do this with `pip show`.  ``` $ pip show networkx ... Location: /usr/local/lib/python2.7/site-packages ```  If it's still not working, you could try checking to see if your `PYTHONPATH` has become corrupted or overwritten.  ``` $ echo $PYTHONPATH ```
