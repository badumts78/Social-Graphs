issue
max_weight_matching has different behavior based on which python version you use.#TITLE_END#For my project, among (possibly) multiple maximum matchings of a (unweighted undirected) `Graph`, I want to select one maximum matching at random. It would be nice if I can guarantee that I can choose a maximum matching at uniformly random, but who knows how many maximum matchings exist and what they actually look like in a graph.  Since the `max_weight_matching` algorithm is deterministic, I try to add the randomness in choosing a maximum matching by permuting the node names and run the `max_weight_matching` algorithm and undo the permuting of namings. I ran something like below to see whether the output changes randomly: ``` import random import networkx as nx  def relabel(G):     shuffled_nodes = list(G.nodes())     random.shuffle(shuffled_nodes)          mapping = {u: v for u, v in zip(G.nodes(), shuffled_nodes)}     inverse = {v: u for u, v in zip(G.nodes(), shuffled_nodes)}          H = nx.relabel_nodes(G, mapping)          return H, mapping, inverse  def relabel_then_find_matching(G):     H, mapping, inverse = relabel(G)     matching = nx.max_weight_matching(H)     return set(((inverse[u], inverse[v]) for u, v in matching))   G = nx.Graph() G.add_edges_from([(0, 1), (1, 2)]) print("Not relabeled") print([nx.max_weight_matching(G) for i in range(10)]) print() print("Randomly relabeled") print([relabel_then_find_matching(G) for i in range(10)]) ```  Firstly, I have noticed that in python 3.5 I do get different results but in python 3.6 and 3.7, permutation of node names do not affect the returned matching. I suspect that this is due to python's update happened in 3.6 on preserving orders in dictionaries. Is this right? I also want to know that kind of behavior is expected as you update from python 3.5 to 3.6.  Result of running the above code in python 3.5 with Networkx 2.1. ``` (py35) C:\Users\csukh>python C:\Users\csukh\Desktop\test.py Not relabeled [{(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}]  Randomly relabeled [{(2, 1)}, {(2, 1)}, {(0, 1)}, {(2, 1)}, {(1, 2)}, {(1, 0)}, {(1, 0)}, {(1, 2)}, {(1, 2)}, {(1, 2)}] ``` You can see that in python 3.5, randomly relabelling nodes makes `max_weight_matching` return between `(0,1)` and `(1,2)`. However in python 3.6 with Networkx 2.1 (below) you always get the edge `(1,2)` as a maximum matching. ``` (py36) C:\Users\csukh>python C:\Users\csukh\Desktop\test.py Not relabeled [{(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}, {(1, 2)}]  Randomly relabeled [{(1, 2)}, {(2, 1)}, {(1, 2)}, {(1, 2)}, {(2, 1)}, {(1, 2)}, {(2, 1)}, {(1, 2)}, {(2, 1)}, {(1, 2)}] ```  Secondly, it would be nice to have an optional parameter `random` in `max_weight_matching` that detremines whether the maximum matching is chosen at random.  Lastly, I wanted to know what would be the best way of adding randomness in `max_weight_matching`. I understand that the bossom algorithm itself might be biased in selecting maximum matching, but I want to reduce bias coming from the implementation of the algorithm. For example, randomizing the initial node or edge where the algorithm starts.  Thanks for the great package. 
issue
is_graphical treats numpy int as not integers#TITLE_END#There is a minor issue with using `is_graphical` function with numpy array. When passing a numpy array with integers as the argument, `is_graphical` automatically returns `False` because numpy `int` type is not an instance of python `int` type.  Also there is no warning regarding the data type of input so I was very confused for a while when I had a clearly graphical degree sequence passed to the `is_graphical` and was returned `False`.  I would suggest considering numpy int as a valid integer type, otherwise I have to recreate a list of python integers from the array of numpy integers.  Also I think it is reasonable to raise an exception or print a warning when the data type of the input degree sequence is not a valid integer, because this case is fundamentally different from not being able to pass HH or EG tests.   ``` >>> import networkx as nx >>> import numpy as np >>> a = np.array([2,2,2]) >>> b = [2,2,2] >>> nx.is_graphical(a) False >>> nx.is_graphical(b) True ```
