issue
The documentation for shortest_path() is confusing#TITLE_END#I have a Directed, potentially cyclic graph. I need to find the shortest path between two nodes.  shortest_path() won't work (quite randomly so, I believe serializing the graph and then loading it back up (and thus changing the order of nodes and edges in the internal representation) made it work once) because it assumes that G is undirected.  I think it would be nice if shortest_path()'s doc made that fact clear. I can write a proposal and make a pull request if the maintainers agree this is the way to go.  In order to solve my problem, I tried dijkstra_path(), which appear to work on directed graphs. Looking at the code, I fail to understand why shortest_path exists as anything more than a wrapper for dijkstra_path with all weight set at 1. Is there a reason for shortest_path having its own, separate implementation of a less generic dijkstra ?
comment
Just acknowledging the question. I'll post an answer asap.  Le mer. 19 juil. 2017 23:54, Dan Schult <notifications@github.com> a écrit :  > This PR proposes to deprecate the current force directed methods and > replaced with a couple of options. Could you give a very short description > of what these methods are, how they differ and when to choose which one? > > I'm not looking for much -- even just "we try each one and see which looks > best (the eyeball norm)" would be fine. I'm not up on the literature here > -- it looks like one of the methods follows a paper that's been implemented > by Gephi. Perhaps the answer to my question is just that we should add a > link to the wikipedia article on Force Directed Graph Drawing > <https://en.wikipedia.org/wiki/Force-directed_graph_drawing>. > > Also you've got generalized_fruchterman_reingold_layout. Is this the same > algorithm in some special case? How does it relate to the existing > function. Do we need both codes? Can we add a test in some case that checks > for the same result? > > Thanks!! > > — > You are receiving this because you are subscribed to this thread. > > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/pull/2389#issuecomment-316529567>, > or mute the thread > <https://github.com/notifications/unsubscribe-auth/AApF7QgAPzoxiKTD-fCgZnpEN5al3IEHks5sPnr_gaJpZM4MeDzC> > . > 
comment
All force directed layout algorithms work on the same principle: nodes repel each other according to some law, and attract each other according to some other law.  In a loop, one computes the effect of those attraction-repulsion forces and move the nodes accordingly, and then recompute the forces, etc.  These law can depend on the edges value, can be anisotropic, can be anything, really.  Fruchterman Reingold (also called "Spring layout") is just one particular choice of one attraction force and one repulsion force. Force-Atlas 2 is another particular choice, but both work according to the same principle.  To date, Fruchterman Reingold is the only force-directed layout algorithm available in networkx.  This PR proposes a generalized version of the force-directed layout mechanism: as long as the user provides the function that computes the forces, the `force_directed` function will do the loop on the graph using this forces until the nodes come at a rest (or as close to a rest as the `min_displacement` variable specifies).  One very nice property of `force_directed` is that given that the forces are non-stupid (i.e. they allow for the equilibrium to exist by having a distance range where attraction and repulsion compensate each other)  we can prove the convergence of the algorithm, because we use a variable step-size parameter (`alpha`) that make it so the actual displacement get smaller and smaller as the forces decreases, so that we don't overshoot the equilibrium point. This is something I intend to publish someday, but I have not found the time just yet. Note however that the convergence may be to a local minimum, but I don't think there's a simple way around that.  In order not to break the API, we re-implemented Fruchterman Reingold using `force_directed`, this is `generalized_fruchterman_reingold_layout`. The function is very long because of the docstrings, the conversion to numpy arrays, etc. but the actual implementation is three lines long: ``` def fruchterman_reingold(Dis, delta_unit, Pos, _):     f_rep = (k * k / Dis**2).reshape((nnodes, nnodes, 1)) * delta_unit     f_att = (W * Dis / k).reshape((nnodes, nnodes, 1)) * delta_unit     return np.sum(f_att - f_rep, axis=1) ```  We just compute the attraction and repulsion forces and add them together.  Adding new force-directed layouts is child's play now. In order to illustrate, we wrote Force-Atlas 2, which the the flagship layout algorithm of Gephi (the paper is tied to Gephi's Java implementation). The implementation is a bit longer than 3 lines because Force-Atlas 2 has a very ugly "Gravity force" that must be computed from the center of the graph, but is is quite readable nonetheless (the force function is `force_atlas_2`, and the boilerplate-included, user-facing API function is `force_atlas_2_layout`.  We are working on an anisotropic repulsion function, where nodes are repelled more if they are on the same horizontal line. This is in order to make the labels readable (nodes will slip a bit vertically and nicely arrange themselves so that labels don't overlap).  The tests are very difficult to write, because those algorithms are very sensitive to the initial conditions, and because the end result ("looking good") is hard to express in code. There were no such tests on the existing spring layout algorithm either. Maybe we can try something anyway, I'll think about it, but if you have any idea, I'm all ears.   If the code need some cleanup, or if you need real tests before merging, I'd be happy to work with you to get this PR merged.
comment
Hi !  I refactored the diff into one commit. I removed the FIXMEs, changed the name of `force_directed` to `force_sim_until_no_displacement` and removed the previous `fruchterman_reingold_layout` function for two reasons: - the new implementation with `force_sim_until_no_displacement` is as fast on big graphs (and even marginally faster on the tests I did) as the previous sparse version - the results look better, see eg for a path graph old: https://i.imgur.com/SkwvfOl.png  vs new https://i.imgur.com/z5Q6GhI.png  I cant reproduce the doc build fail for Python 2.7 on my machine, but I suspect this PR is not responsible as there is no non-ASCII char in the diff, and the build process is choking on a non ASCII char.  Do you think this PR is acceptable as-is, or do you want me to try to make all checks pass ? If so I think I would need some help with that.
comment
@dschult, it would be easier for us to have this merged into the master branch, because as is we must maintain our fork and dependency management is getting cumbersome.  We are ready to work on this PR if you dont think is is ready for merging yet.   Please advise :)
comment
Hi,  I apologize about the nudge and the delay of this answer. Your suggestions make perfect sense. I'll try to get this done before the end of 2018.
comment
The new pull request:  https://github.com/networkx/networkx/pull/2389 
comment
Just chiming in to say that I was hurt by this as well. The documentation does not explicitly state that shortest_path does not work on DAGs, the function does not check that the passed graph is a DAG, and so sometimes it works, sometimes it does not.  
