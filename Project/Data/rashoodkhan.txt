comment
@Midnighter - I like your idea of providing an alternative implementation of Graph in a turbo package as mentioned above. This will ensure that networkx provides performance in terms of time/space complexities. As there is a parallel project on moving to new API and once the API design is finalized, the new classes and methods can be implemented using the new API.  Correct me if wrong, all the algorithm implementations rely on the existing API for the graph, so to make the existing algorithms compatible with the newly developed implementation two things could be done: 1. Provide helper functions to convert back to compatible data format (i.e dicts) 2. Update the existing algorithms to use suitable back end graph classes (possibly by checking the type of graph initiated). 
comment
> Overall, the appeal of a matrix class to me is not as an alternative storage solution (the dict-of-dict is > actually quite good and very convenient) but to make use of algebraic solutions to graph problems. So > at this point I am more concerned with implementing those algorithms where algebraic solutions exist > efficiently rather than making the matrix classes work with every networkx function. However, if the 2.0 > API makes this feasible, it should definitely be pursued.  It now makes sense from the project description. I had doubts that once the new implementation is done, then the existing graph implementation will become obsolete which is cleared now. Do you have any specific algorithms to be implemented with the new implementation?   Also, I want to read up more on Linear Algebra for Graphs - what would you suggest to look at? One resource I found was on the GraphBLAS homepage which is the book Graph Algorithms in the language of Linear Algebra. 
comment
@Midnighter Making a Wiki page on Github will be nice which collects all the algorithms and resources links!  @chebee7i - I have studied about sparse representation in my algorithms course, but will need to brush up on the concepts. I will have a look at `scipy.sparse` and `scipy.sparse.csgraph` 
comment
I went through the [code](https://github.com/hagberg/networkx/commit/b6e18655f51104c06251558890e88a9dee189d4d) by @hagberg and as mentioned it can be a good starting point for the project. I have started to work on the GSoC proposal for this project, it would be nice if we can compile the list of algorithms. Once the list is ready, depending on the complexity of each algorithm, I can make up the project timeline @Midnighter. 
comment
Hey!  Would it make sense to open Github issues for other GSoC project ideas as well (Alternate backends for storing graph data)?  Two project ideas are of interest to me - Adjacency matrix based add-on - I'm more inclined on this as of my interest in graph algorithms.  - Alternative backends for storing graph data - A very fascinating idea to work on. This seems like implementing a mini-ORM as Django provides for storing its objects. Making the backend system to be plug-able with multiple databases by providing a settings option as Django provides would be cool.  I want to discuss the above ideas with mentors/community - Where would be the best place to start the discussion, i.e. the mailing lists or Github Issues?  +1 to @MridulS  for pointing out for IRC channel for discussing ideas with mentors. 
comment
@MridulS - I have started following the thread. Thanks!  ##   Rashid Khan http://www.imrashid.com  On Sun, Feb 22, 2015 at 10:07 AM, Mridul Seth notifications@github.com wrote:  > @rashoodkhan https://github.com/rashoodkhan Please go through #1076 > https://github.com/networkx/networkx/issues/1076 to get an idea about > matrix graphs. >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1341#issuecomment-75419358. 
comment
I use PyCharm for all python development, and by default it takes the python installed by the system.  I use virtual environment by using the virtualenv. Install virtualenv by `$ pip install virtualenv` and the workflow which I follow for each project is given below -  - If I want to work a new project, I make sure not to install any packages on the default python installation, hence I create a virtual environment for each project. You can create a new virtual environment by `$ virtualenv projectname-env` - Activate the virtual environment by running `$ source path-to-virtualenvironment/bin/activate` - You should be able to see the environment name on the bash prompt - Install all dependencies required by the project using pip - Run `$ pip freeze` to verify all the required dependencies are installed - Install the required application using source (i.e. `$ python setup.py install` or `$ pip install projectname`)  Now comes the PyCharm Setup - Open the project in PyCharm - Click `Cmd ,` to open the preferences menu - Navigate to Project tab -> Project Interpreter - Click on the settings icon on the right next to and click Add Local - Now navigate to your path of installation of virtual environment/bin/ and select python2.x depending on your installation  ![screen shot 2015-02-26 at 4 09 20 am](https://cloud.githubusercontent.com/assets/2310087/6382362/f6e69184-bd6d-11e4-9737-39d04a2c7b95.png)  Now your PyCharm is loaded with given virtual environment.  If you want to run the code from terminal, you will need to activate the virtual environment and then run your code. If a terminal session closes, the virtual environment session closes too. At any point of time you can deactivate the virtual environment by executing `$ deactivate` on the terminal.  I think by following the above steps will solve your problem. In case you are stuck, please reply to this thread. 
