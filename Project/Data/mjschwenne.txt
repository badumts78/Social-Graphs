issue
New draw API#TITLE_END#The first version of the new draw API is ready! It takes the approach that a graph should be able to describe what it looks like and how it should be visualized. As such, most of the data is read from the graph itself. However, to provide the most convenience and flexibility to the user, they can pass in `None` to force the visualization to fall back onto the default value or for most attributes if they specify a single value which isn't an attribute name (i.e. `node_size=500`) that value will be used for all applicable nodes and edges.   I've also included a helper function called `apply_matplotlib_colors` which takes a color map and generates a new attribute on the graph which stores RGBA tuples. The idea here is to setup the visualization API for dispatching in the future.   The next steps include refactoring the tests to use the new API and setting a deprecation policy for the old one. Below are some examples using the new draw function, currently called `new_draw`. These examples are what I used while developing the functionality to test, but are otherwise pretty arbitrary.  ```python import networkx as nx import matplotlib as mpl import matplotlib.pyplot as plt import random from collections import Counter import numpy as np  G = nx.karate_club_graph()  node_shapes = 'so^>v<dph8' nx.set_node_attributes(G, {n : random.choice(node_shapes) for n in G.nodes()}, name="shape")  nx.new_draw(G) ```  ![image](https://github.com/user-attachments/assets/f5e4c4ca-0837-45d0-9591-53ac5ee700ef)  ```python nx.set_node_attributes(G, {n : 1 / (n + 1) for n in G.nodes()}, name="alpha") nx.set_node_attributes(G, {n : n for n in G.nodes()}, name="border_width") nx.new_draw(G) ```  ![image](https://github.com/user-attachments/assets/44c87cf5-d604-4eae-b171-62738bacbaac)  ```python nx.new_draw(G, node_alpha=None) ```  ![image](https://github.com/user-attachments/assets/1ed7b047-2e7a-4d54-bb1e-6c2887a7826c)  ```python H = nx.karate_club_graph() nx.set_node_attributes(H, {n : n for n in G.nodes()}, "weight")  nx.apply_matplotlib_colors(H, "weight", "color", mpl.colormaps['plasma']) nx.new_draw(H, node_label=None) ```  ![image](https://github.com/user-attachments/assets/e5b236a3-3930-4369-9221-f6fcb2b000c6)  ```python nx.set_node_attributes(H, "#1f78b480", "transparent_color") nx.new_draw(H, node_color="transparent_color", node_label=False) ``` The edges in this one are still drawn behind the nodes, but the nodes themselves are transparent, which is why we can still the edges. While this behavior is probably not desirable, it is consistent with the existing visualization capabilities.   ![image](https://github.com/user-attachments/assets/8514d143-cd41-4875-81d8-d737d5f68722)  ```python nx.new_draw(H, node_size=500) ```  ![image](https://github.com/user-attachments/assets/ed7961b1-7450-4b1f-9318-26594cebf1cc)  ```python I = nx.karate_club_graph() nx.set_edge_attributes(I, {(u, v): "-|>" if (u + v) % 2 else "-" for u, v in I.edges()}, "arrowstyle") nx.new_draw(I, arrowsize=10) ```  ![image](https://github.com/user-attachments/assets/3cb658ac-2b2a-4502-8216-d1ac8c06d4a4)  ```python sl = nx.complete_graph(3, create_using=nx.DiGraph) sl.add_edge(0, 0) pos = nx.circular_layout(sl) nx.set_node_attributes(sl, pos, name="pos") sl.add_edge(1, 1, style=":") sl.add_edge(2, 2, style=":") nx.new_draw(sl) ```  ![image](https://github.com/user-attachments/assets/86faebe3-8b68-4c60-8a92-d7e7ce240ce1)  ```python import itertools as it nodes = "ABC" prod = list(it.product(nodes, repeat=2)) * 4 M = nx.MultiDiGraph() for i, (u, v) in enumerate(prod):     M.add_edge(u, v, w=round(i / 3, 2)) ``` This is what the multigraph looks like with the existing draw API: ```python  connectionstyle = [f"arc3,rad={r}" for r in it.accumulate([0.15] * 4)] nx.draw(M, connectionstyle=connectionstyle) ```  ![image](https://github.com/user-attachments/assets/f6af9267-c382-4419-97f3-8a34d6dc5507)  Here is the same graph with the new API. This time I also added edge labels and colors. I was interested in seeing if I could replicate the old behavior of passing in a list with less entries than the number of edges and iterate over it multiple times. Fortunately the `cycle` function from `itertools` makes this easy.   ```python csi = it.cycle(connectionstyle) nx.set_edge_attributes(M, {e: next(csi) for e in M.edges(keys=True)}, "curve") nx.set_edge_attributes(M, {tuple(e) : {"label": w, "bbox": {"alpha": 0}} for *e, w in M.edges(keys=True,data="w")}, "label") nx.apply_matplotlib_colors(M, "w", "color", mpl.colormaps["inferno"], nodes=False) nx.new_draw(M) ```  ![image](https://github.com/user-attachments/assets/0a4f01c6-b0a5-46b7-8710-22ffc7c5a804) 
issue
Save Layouts on Graphs#TITLE_END#Adds the option to save positions onto the graph. Everything still returns an dict for now for backwards compatibility. In the future we'll want the default behavior to write the position back onto the graph, but that will require a deprecation cycle. I'm particularly interested in advice on how to structure the API during the cycle and still need to add the warnings.   In the meantime, I still need to add tests and look into the possibility that it's more efficient to compute the positions directly on the graph rather than use `set_edge_attribute` at the end. 
issue
Fix TSP weight parameter issues#TITLE_END#Fixes #7720. See that issue for a description of the issue and solution.  
issue
Individualize drawing attributes#TITLE_END#A set of improvements to the existing visualization suite aimed to align the current functionality with what will be implemented after the refactor.   Some attributes can only have one value per visualization, such as node font color or arrow style for directed graphs, but if attributes are read from the graph, we should allow individual values for all of these.   While I haven't broken any of the existing tests, I'm not sure that I fully understand the testing infrastructure for the visualization module. Tests will need to be added, but I'm still working on it.   Below are some examples on the karate club graph.  ```python nx.draw_networkx(G, pos=pos, ax=ax, node_shape='o',      font_size={n: int(n / (34/15) + 5) for n in G.nodes()},      font_color={n: 'k' if n % 2 == 0 else 'r' for n in G.nodes()}) ``` ![image](https://github.com/user-attachments/assets/40c60c45-3f53-4f49-a163-5d7991d9a1f6) ```python nx.draw_networkx(G, ax=plt.axes(),      node_shape=np.array(['o' if n % 2 == 0 else '^' for n in G.nodes()])) ``` ![image](https://github.com/user-attachments/assets/361404db-e822-44ed-a774-7bc50a9990ed) ```python arrowstyles = ["-|>" if (u + v) % 2 == 0 else "-[" for u, v in G.edges()] arrowsizes = [(u+v)/2 for u, v in G.edges()] nx.draw_networkx(G, ax=plt.axes(), arrows=True, arrowstyle=arrowstyles, arrowsize=arrowsizes) ``` ![image](https://github.com/user-attachments/assets/a90d2b29-ca74-43c6-8e2e-6c7f5164013b) ```python min_source_margin = [u for u, _ in G.edges()] min_target_margin = [v for _, v in G.edges()] nx.draw_networkx(G, ax=plt.axes(), arrows=True, min_source_margin=min_source_margin, min_target_margin=min_target_margin) ``` ![image](https://github.com/user-attachments/assets/0d0e636d-2e19-4900-856a-9b6bf8ba9119) 
issue
Add remove attribute functions#TITLE_END#With the addition of attribute based visualization, users may want to be able to remove visualization related attributes. I was a bit surprised that this functionality didn't already exist, but these are a pair of convenience functions to help with that. 
issue
Remove deprecated MultiDiGraph_EdgeKey for 3.4#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html --> Removes the `MultiDiGraph_EdgeKey` class for the 3.4 release.
issue
add **kwargs to traveling_salesman_problem#TITLE_END#The current interface for `traveling_salesman_problem` requires currying, creating a lambda to create a partial application of the fixed arguments for the method. This by itself is totally fine, and very commonly seen in functional programming, but as far as I know this is the only time that behavior appears in NetworkX.   This PR adds a `**kwargs` to `traveling_salesman_problem` to remove the currying requirement. I've designed it so that existing code shouldn't break, although this does require the extra check for `init_cycle` to remain compatible with the threshold accepting and simulated annealing TSP methods. I thought about changing those methods to have a default argument, which has been considered numerous times, but decided against changing the API. The points raised in the doc string continue to be relevant. 
issue
Add new test result to `test_asadpour_tsp` and change `linprog` method#TITLE_END#Fixes #5913   (I hope, since I can't reproduce the bug)
issue
deprecate Edmonds class#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> As discussed in #6743, the original implementation of Edmond's algorithm for finding maximum branchings, and by extension minimum branchings as well as minimum and maximum arborescences was a class with only one method (`find_optimum`). This API structure is not common throughout NetworkX, in fact it is the only instance where a class is used to implement a network algorithm that I'm aware of. Since all of these algorithms were recently refactored and no longer depend on the class itself, it is now safe to remove the class.   Additionally, the `MultiDiGraph` subclass `MultiDiGraph_EdgeKey` is also no longer needed. It was not used in any other algorithms in the library and doesn't extend the original class in a manner which is not easily replicated with an additional helper function. 
issue
remove to/from_scipy_sparse_matrix#TITLE_END#Remove deprecated `to_scipy_sparse_matrix` and `from_scipy_sparse_matrix`. 
issue
Fix #5817#TITLE_END#Ok, so first of all this fix was way faster than I thought it would be, thanks in part to my excessively detailed notes and blog posts from last summer on the topic (such as [this one](https://mjschwenne.github.io/2021/06/03/a-closer-look-at-held-karp.html)). The linear program that gets run as part of `direction_of_ascent` is checking for the existence of a set of non-negative constants. If the program is feasible, then the direction of ascent doesn't exist and we can stop trying to find it.   So, I believe that `optimize.linprog` failing to find a solution to the program is fine; it just means that this set of constants doesn't exist and we have to keep looking. More information can be found on page 13 of [this paper](https://pubsonline.informs.org/doi/abs/10.1287/opre.18.6.1138) by Held and Karp titled "The Traveling-Salesman Problem and Minimum Spanning Trees". So in reality, just checking if the problem has a solution gives us all the information we need. Note that I any taking advantage of the default non-negative bounds that the `linprog` on the variables involved.    Since linear programming is *not* something I claim any more than the most basic skill with (although I would be interesting in taking a class about it if given the chance) input from someone with a bit more expertise would help clam some lingering doubts that I just can't seem to smooth over in part because this particular internal function is so difficult to generate test cases for.  
issue
Add random_spanning_tree to documentation#TITLE_END#When I created #5656 I forgot to add `random_spanning_tree` to `tree.rst` so it does not appear in the documentation. 
issue
remove old attr keyword from json_graph/tree#TITLE_END#Removes the deprecated `attr` keyword from `tree_graph` and `tree_data`. 
issue
Remove depercated Edmonds class for 3.4#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html --> Removes the `Edmonds` class for the 3.4 release. 
issue
Refactor edmonds algorithm#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Hello!  I've finished my refactor of Edmond's optimal branching algorithm so it is not dependent on the `Edmonds` class or the `MultiDiGraph_EdgeKey` class. The algorithm itself now lives under `maximum_branching` and the other branching and arborescence functions transform the edge weights and use the `maximum_branching` function.   Things left to do -------  There are two things that still need to happen here.   1. I would like to deprecate the `Edmonds` class as well as `MultiDiGraph_EdgeKey` and the `get_path` function in  `branching.py`. These classes (and function) are no longer required and always struck me as odd since the rest of the nx codebase doesn't use objects to run algorithms like this. However, I don't know how to deprecate anything in networkx and would appropriate some help getting that setup.   2. As mentioned in #4836, the `minimum_branching` function will return an empty branching for graphs with only positive edge weights since it can choose to not add an edge which will move it further away from the minimum or maximum value. This isn't helpful, isn't documented and should be corrected. I can think of two ways to do this, either    * Create a new function called `minimal_branching` which uses the same weight transformation as `minimum_spanning_arborescence` but doesn't throw an error when the result isn't an arborescence. This will let us return a branching which will be like an arborescence but doesn't have to span the whole graph and would be useful when the graph has multiple components.     * Change the behavior of `minimum_branching` since it really isn't useful right now, although it would require some form of warning to the user that the behavior has changed. I'm not  really sure if that's truly a deprecation or something less. 
issue
networkx.org banner display issue#TITLE_END#The primary banner for the NetworkX website is not displaying correctly, making 'Python' appear like 'Pythor'.  ### Current Behavior  When visiting the networkx website, the logo and banner appear like below. The windows on the left are Brave Browser and the ones on the right are Firefox windows.   ![nx-banner-issue](https://user-images.githubusercontent.com/19698215/217340172-12475930-3e5a-4c20-bfcd-ff89b6a60339.png)  ### Expected Behavior  'Python' should display correct, as it does when I view the image locally in Inkscape.  ![nx-banner-local](https://user-images.githubusercontent.com/19698215/217340192-f2ca4626-3e15-43c0-a67d-3862bd25a055.png)  ### Steps to Reproduce  Visit [networkx.org](https://networkx.org).  ### Environment  Python version: NA NetworkX version: NA  ### Additional context  In the browsers, the text in the images is selectable, so the browsers may be trying to and failing to parse some of the vector information in the underlying `svg` file.  
issue
remove testing submodule#TITLE_END#Removes the deprecated `testing` submodule. 
issue
Moved random_spanning_tree to public API#TITLE_END#This is an improvement from my GSoC project last summer. Part of the Asadpour algorithm involved sampling random spanning trees from the graph based on their edge weight. I have moved the function I used to do that into `mst.py`, even though technically it isn't 'minimum' that seems to be were it fits the best. I have also expanded the algorithm to be able to use the sum of edge weights in the tree for the probability instead of the product of edge weights. However, this new method is very slow (the original paper says O(|V|^4|E|), but to me it seems closer to O(|V|^3|E|^2) and is quite slow in practice as well) so I have left the multiplicative weight as the default. Trees can be picked from a uniform distribution by leaving `weight` as `None`.  As part of this, I also moved a helper function to `laplacianmatrix.py` which uses the matrix to find the total weight of the spanning trees assuming a multiplicative weight or just the number of trees if `weight` is left as `None`, but I'm not really sure if that fits there or even really needs to exist, so I'm definitely looking for feed back about that. 
issue
GSoC Asadpour ATSP Implementation Pull Request#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Following the instructions for the [Google Summer of Code applications](https://github.com/numfocus/gsoc/blob/master/CONTRIBUTING-students.md) for NumFocus, the NetworkX umbrella organization, my application should be accompanied by a pull request.  There is no new work here, other than a method stub, but the pull request and branch are ready to be worked on during the summer of code.
issue
Updating contributors for GSoC 2021#TITLE_END#Hello!  I am one of the Google Summer of Code students this year and my project is quickly drawing to a close, I just need to ensure that my updates to the documentation are correctly shown in the NetworkX documentation. At my mentor meeting yesterday @dschult suggested that I create a new PR with this change so that I am no longer considered a first time contributor. This will cause my commits to automatically create the documentation build artifact  on my main PR so I know that my changes are correct.
issue
updated contributor file for GSoC 2021, take 2#TITLE_END#My second attempt at updating this file.  First attempt is PR #5018. 
comment
We recently introduced a new visualization API in #7589, and it would be much appreciated if any improvements to the old visualization system were also reflected there. Long term, we'd like to shift focus to the new visualization method, `display`. We will keep the old functions but I'd like to eventually have them be wrappers of `display` so that we aren't maintaining two separate ways to do the same thing. 
comment
Yes, a lot of the code was copied directly from the old system regarding the lower level matplotlib code. It should be reasonable simple to copy the changes here up there so that `display` is capable of going everything that the old `draw_*` functions. 
comment
This was fixed in #7753 and will be included in the next release of NetworkX.
comment
Nice catch! In this case we can simply brute force the TSP since there is only one possible path. Our only choice is which one of the two nodes should be returned first, and I think your new check handles that quite well. Everything here makes sense to me. 
comment
Thanks for the issue, there is indeed a bug here!  Specifically, in the graph pre-processing for `traveling_salesman_problem`, we rebuild the graph to restrict it to the nodes passed in via the `nodes` parameter, create a complete graph and re-weight the graph to ensure it satisfies the triangle inequality (which is a requirement for algorithms like `christofides`). During this process we see   ```python  GG.add_edge(u, v, weight=dist[u][v]) ```  which will replace the name of the attribute storing the weight with `"weight"`, and then pass the user-supplied `weight` value to the method.   Fortunately this is an easy fix, we just need to change this line to   ```python GG.add_edge(u, v, **{weight: dist[u][v]}) ```  to preserve the user-supplied weight attribute name. 
comment
I would expect this to be in the next release, but I don't know when that will happen or what version number that will be.
comment
I don't remember there being any specific reason I changed the return type on this function. I suspect that it was to help with generating images in a jupyter notebook but I'm not sure. Reverting the return type to what's promised in the doc string and what has been used historically by this function is a good idea. Technically if we wanted to keep the change (which we don't) we'd need a deprecation cycle I think that since that didn't happen the change was never met to be permanent. 
comment
The examples were very helpful to understanding the proposed behavior. What is the role of the `backend_fallback` config option? Is this any different than putting `"networkx"` as the last position in the `backend_priority` list?
comment
Interesting, the documentation build failure is related to not having nvidia drivers installed, but I'm not sure why the check would pass on the last commit but not in main...
comment
A couple of points on this:  - `SpanningTreeIterator` should only work with un-directed graphs. Directed graphs should use the `ArboresenceIterator`. That's a typo in the documentation. - The spanning tree iterator isn't really designed to work with multi-graphs in mind.  - I wrote this class mostly to develop my understanding for the `ArboresenceIterator` class which I needed for the Asadpour TSP algorithm. That process does involve multi-graphs (since we have to contract vertices while tracking the total number of edges between them) so it's also possible that the reference to a multi-graph is a copy-paste error or something similar.  - I'm not aware of any particular reason why the underlying methodology shouldn't work for multi-graphs, although clearly it's not currently working as implemented right now.    I might take a crack at this later, but looking at what I've got going on this summer, I don't think it will happen before the end of June at the earliest. 
comment
The code itself looks pretty good, but you should definitely add some test cases using multi-graphs to the iterator. Things that are worth testing would be that the number of generated trees is correct, and then that the trees themself are presented in a non-decreasing (and non-increasing for the reverse mode). For a small tests, enumerating the trees explicitly can be a good sanity check. The current tests for the iterator should provide a good roadmap. 
comment
I've added a pair of tests which mirror the ones for the simple graphs. It highlighted a bug with Erik's suggestion since `*e` returns a list and not a tuple which can't be used as a dictionary key.   I think that this is ready to merge now!
comment
This is odd indeed. While I did author the code in question, I will admit that the random number generation pattern used in networkx isn't something that I've investigated. I haven't been able to replicate the error in my environment running Ubuntu 22.04 (python 3.10.4) against the main branch of the repo and haven't heard any reports of that test failing in our pipeline, but since you mention that it's an intermittent problem that doesn't exactly say anything.  (Ugh those types of problems are the worst to track down!)  I did check that the `seed` parameter passed to `asadpour_atsp` is used in all of the places where random numbers are required. It is worth noting that the since their are already two tours in  the `expected_tours`, the comment above it seems... not exactly correct, but I'm not sure where the existing non-determinism is coming from.    Since the returned answer has the same weight as the correct answer, the quick and dirty option here is to add that tour to the list of expected tours. Perhaps either @dschult or @rossbar would have a better intuition on whether this is a problem that we need to track down or if the fast solution is considered good enough.
comment
Changing it to use a seed would be the best solution, but I believe that it already is? [Line 742](https://github.com/networkx/networkx/blob/28f3a4e22d32ca43ff768b1fa365b26f75a0273d/networkx/algorithms/approximation/tests/test_traveling_salesman.py#L742) in the test file of the 2.8.5 release does wrap the `asadpour_atsp` function and provides a seed value of 19 for the failing test unless I'm seriously mistaken.
comment
What version of networkx and python are you using?
comment
Well, I'm still not sure what is causing this issue. I'm using the NixOS compiled version of both `numpy` and `scipy` and I was still unable to reproduce the bug by changing the `scipy.linprog` method. I tend to agree that Rossbar that this was probably the most likely point of origin for the bug, pretty much everything outside of that call is python only and should be fairly robust to platform specific changes.   Either way, since the new tour returned is equally valid, I've added the reported path to the test and fixed the method to `"highs-ipm"`. That should fix the bug, but since I can't reproduce the problem I'd really appreciate if you could test the update.  
comment
I agree with Ross, that is the right solution and it was caused by an oversight during the last refactor.   Adding a test also seems like a good idea to catch things like this in the future. 
comment
The `traveling_salesman_problem` function actually creates a new version of the input graph which does meet the triangle inequality by replacing the edge weight between two nodes with the cost of the shortest path between those nodes. Once the internal TSP method has returned a result on the graph, it undoes these changes by replacing the edge in the tour with the shortest path in the original graph (this can possibly introduce nodes multiple times). By definition the triangle inequality is satisfied in the graph which is actually passed to the `christofides` method. We do this so that we can have a meaningful using of the TSP on non-complete graphs. 
comment
There are multiple different approximation algorithms which you can use for the `traveling_salesman_problem` function. For directed graphs, the default is the Asadpour[^1] method because it actually has an approximation bound, unlike the threshold accepting and simulated annealing methods, and doesn't require extra inputs like an initial solution.   However, it is slower than the other two and in my experience very inconsistent. Your graph takes around 8 minutes on my computer (nx 3.1, python 3.11.4) but the six vertex graph in the [test suit](https://github.com/networkx/networkx/blob/e4463a4f38bcdce1b6a95b1bdfaf762cbf80ddf7/networkx/algorithms/approximation/tests/test_traveling_salesman.py#L766) only takes about 0.43 seconds.   According to this script, the other methods are actually many times faster than the default method.  ```python import networkx as nx import time from datetime import timedelta  graph = nx.DiGraph() graph.add_nodes_from(range(6)) graph.add_weighted_edges_from((s, t, s + t) for s in graph.nodes() for t in graph.nodes() if s != t) for n, m in zip(["Treshold Accepting,", "Simulated Annealing,", "Asadpour,"],                 [lambda G, w: nx.approximation.threshold_accepting_tsp(G, "greedy", w),                   lambda G, w : nx.approximation.simulated_annealing_tsp(G, "greedy", w),                   nx.approximation.asadpour_atsp]):     start = time.time()     tour = nx.approximation.traveling_salesman_problem(graph, method=m)     end = time.time()     print(f"Name: {n:20} Duration: {timedelta(seconds=end - start)}, Route: {tour}, Cost: {sum([graph[tour[i]][tour[i+1]]['weight'] for i in range(len(tour) - 1)])}") ``` ``` Name: Treshold Accepting,  Duration: 0:00:00.045257, Route: [0, 1, 2, 3, 4, 5, 0], Cost: 30 Name: Simulated Annealing, Duration: 0:00:00.005363, Route: [0, 1, 2, 3, 4, 5, 0], Cost: 30 Name: Asadpour,            Duration: 0:08:34.207166, Route: [1, 2, 3, 5, 0, 4, 1], Cost: 30 ``` It is worth noting that for `threshold_accepting_tsp` and `simulated_annealing_tsp` the documentation for `G` states it should be undirected, but the methods work will with directed graphs and even the examples in the documentation use directed graphs. We should at the very least update the documentation to more explicitly states that these methods can be used for directed graphs.   [^1]: A. Asadpour, M. X. Goemans, A. Madry, S. O. Gharan, and A. Saberi, An O (log n / log log n)-approximation algorithm for the asymmetric traveling salesman problem, SODA â€™10, Society for Industrial and Applied Mathematics, 2010, p. 379 - 389 https://dl.acm.org/doi/abs/10.5555/1873601.1873633.
comment
Reading some of the Sphinx docs, you may be able to reference the `christofides` function with  ``` :func:`christofides` ``` or some other path to the function such as `nx.approximation.christofides`. Note that I haven't actually tested this, but here are the references I found:  [Sphinx Quickstart Guide](https://www.sphinx-doc.org/en/master/usage/quickstart.html#documenting-objects)  [Sphinx Domain Reference](https://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html#cross-referencing-python-objects)
comment
Hmmm, the `pygraphviz` build stuff is a little beyond my knowledge (although I know it's been changeling to get working). However, @rossbar could probably way in on this issue.
comment
Hello!  I have looked at the method in question, and it is indeed bugged. I ran the tests for that file and they all pass... but the tests for the minimum branching case appear to have never been completed!  I can quickly fix and test the problem so that it can be resolved soon.
comment
Would you still like me to fix and merge it?
comment
Sounds good, I should have time over the weekend
comment
Ok, I've done some reading from the original Edmond's paper.  The difference between a branching and an arborescence is that the branching is not required to be connected. Thus, a minimum branching from the above graph technically *is* the one that was returned. It has a weight of 0. If there was a negative edge weight then that one would be included in the minimum branching.   I think `minimum_branching` is effectively a useless function since it will always return the set of negative edges, but I'm not sure what the 'correct' behaviour is since changing it would made it equivalent to `minimum_arborescence`.  I wonder if @dschult would be able to give some guidance. 
comment
I certainly agree that `find_optimum` could use a refactor and would be happy to work with you on that @lkora.  As for the notion of a minimum weight, maximal coverage branching, the main difference between this and a spanning arborescence is that we can return a spanning forest style of graph should there be multiple truly disconnected components in the original graph. Kruskal's algorithm inherently does this and that would be useful functionality for NetworkX in the case of a directed graph we know has multiple components.  It we move that definition any more we get into the gray area of if there is an edge with a high cost, how do we decide that the cost is too high and choice to disallow it? This would be a threshold based approach and even if we let the function caller set the threshold I'm not sure that they would have the information needed to set a good one (hence their interest in calling this function in the first place).
comment
While I did mention this issue in the one about `min_weight_matching`, the implementations are completely separate, so the fix their did nothing to fix the issue here. My point their was that this is the same type of issue more than anything. In the short term, I thing that adapting the same style of edge weight conversion from that issue would help solve this problem as will. In the long term, the `Edmonds` class is very difficult to read and understand even when crossing referencing every step with the original research paper which is what I was doing last summer. In my opinion that whole class should be refactored and rewritten to be more concise and easier to follow but I haven't had the time to throw about it. I can probably take a crack at this in those two step, so first a small PR to fix this and then a larger one to refactor the `Edmonds` class.  
comment
Two points to add to the conversation:  1. Christofides algorithm (which is the default choice for an undirected graph) is an approximation algorithm for the *metric* TSP. This means that the edge between two nodes must be at least as short as any other path between those nodes in the graph. Since passing through the fourth node in your example can find paths between all nodes with a total length of zero, the original graph is not metric and directly using Christofides is not the right choice.  2. The `traveling_salesman_problem` function will replace edge weights with the shortest distance between those two nodes so that the direct link between the nodes is always the shortest path, even if the input graph is complete (if the input is not complete, this process will also complete it). This will implicitly also ensure that the graph is metric. After it has been passed through the method which it was given, it will recover the path in the original graph by undoing the shortcutting, so if the edge between nodes is not the shortest for all pairs of vertices it is possible to get repeated nodes in the output solution.  So for your example, the `traveling_salesman_problem` function converted the graph to only have zero edge weights and passed it to `christofides` which probably reports a valid TSP tour for a complete and metric input. Perhaps it was `[1, 3, 2, 4, 1]`, but there are several other valid outputs which are possible. On the way out, the original paths are recovered and the `1 -> 3` edge traversed by the algorithm with weight zero after the shortcutting becomes `1 -> 4 -> 3` which we see in the output.
comment
As I originally read this, I was a bit confused as to why this would be needed, then I realized that it was probably because all of my recent work with NetworkX has been from a developer prospective were I can read all of the docstrings and implementations without needing to refer to the website or GitHub repo rather than a user prospective.  That being said, I agree that there is a possibility to increase the overall readability of NetworkX code across the board. This is still a new area of discussion for me, I'm not used to having to think about the overall API in programs that I am normally writing, but I think that we should be careful about your comment about new additions to the API. I don't think that we would want inconsistent keyword requirements based on something as seemingly arbitrary to an end-user as when a function was added to the library. At least to me, this is something that we would have to commit to entirely or not enforce at all and maybe try to encourage 'proper' usage by using keyword arguments if that is at all possible.  (If I'm totally off base here, just let me know)
comment
I believe that this functionality has already be implemented with the `ArborescenceIterator`, documentation [here](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.tree.branchings.ArborescenceIterator.html), although the complexities of the two methods are different with this one performing better for graphs with more arborescences (either because they are larger or denser).   To get the $K$ maximum arborescences create a maximum `ArborescenceIterator` and break the loop after $K$ arborescences have been generated. 
comment
I had noticed the warnings coming from `optimize.linprog` and always wanted to go back and try to fix them. I guess scipy has forced my hand to at least try :smiley:. Unfortunately, the linear programming part of this has always been my weakest point with the algorithm. Also, I don't have access to my annotated copy of Held and Karp's paper at the moment but I should still have a PDF copy somewhere on my laptop.  My inclination is that the issue is not with the original problem formulation from the paper or with scipy. I most likely have a subtle error in populating the constraint matrices before they are passed to scipy. I will have time to start the investigative process tomorrow, but I don't really know how long it will take to track down the problem. Only that it will take a day or two for me to get back up to speed with the held karp ascent method. 
comment
Reading about this bug reminded me of #4836 since they are both a similar issue with converting a maximal algorithm to take the minimum. While I haven't had the time yet to work on that issue, it is still on my mind. I wonder if other functions which take a minimal approach using a maximal algorithm have this issue. It might be a good idea to check if these are part of a large problem. I *should* start to get some free time in the coming week and try to compile a list to test. 
comment
Any reason your approval is green and mine is gray?
comment
Hello!  I'm looking to get involved with NetworkX and this looks like a good first issue.  It seems that there are still a few places using `numpy.matrix` in the linalg module. Namely `directed_combinatorial_laplacian_matrix`, `directed_laplacian_matrix` and `_tranistion_matrix` which still use `numpy.matrix`. `attr_matrix` also still uses `numpy.matrix` as a return type.  Are we looking to change these methods now or simply add warnings that they are going to change in the future (NetworkX 3.0 seems to be the version mentioned)?
