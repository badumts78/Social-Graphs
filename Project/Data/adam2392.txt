issue
[BUG] Patch doc and functionality for `is_minimal_d_separator`#TITLE_END#Signed-off-by: Adam Li <adam2392@gmail.com>  Closes: #6247  Fixes: #6216  I am opening this PR since the other one seems stalled. 
issue
Subclassing networkx with Mixin class defined with Python Protocol results in an error during graph creation#TITLE_END#### Current Behavior  If I define a subclass of a networkx graph and augment it with some mixin class that defines some extra functions everything works as expected. However, if I subclass a Python "Protocol" class in my mixin class to allow mypy to do its thing and for me to define an API interface, there is an error.  ### Expected Behavior  `nx.to_networkx_graph(ts_edges, create_using=Graph)` should work as expected.   The error arises due to the check inside `empty_graph ` for `elif type(create_using) is type:`.  ``` def empty_graph(n=0, create_using=None, default=Graph):     if create_using is None:         G = default()     elif type(create_using) is type:         G = create_using()     elif not hasattr(create_using, "adj"):         raise TypeError("create_using is not a valid NetworkX graph type or instance")     else:         # create_using is a NetworkX style Graph         create_using.clear()         G = create_using ```  ### Steps to Reproduce  The following code results in an error:  ```     from typing import Protocol      import networkx as nx      class Mixin(Protocol):         _adj: Protocol          def new_method(self):             pass      class BaseGraph(nx.DiGraph):         def __init__(self, incoming_graph_data=None, **attr):             super().__init__(incoming_graph_data, **attr)      class Graph(Mixin, BaseGraph):         def __init__(self, incoming_graph_data=None, **attr):             super().__init__(incoming_graph_data, **attr)      ts_edges = [         (("x1", -1), ("x1", 0)),         (("x1", -1), ("x2", 0)),         (("x3", -1), ("x2", 0)),         (("x3", -1), ("x3", 0)),     ]     G = Graph(ts_edges)     new_G = Graph(G)      G = nx.to_networkx_graph(ts_edges, create_using=Graph) ```  ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.9 NetworkX version: 3.0b1.dev0 
issue
[ENH] Find and verify a minimal D-separating set in DAG#TITLE_END### Summary This addresses: https://github.com/networkx/networkx/discussions/5859  where I raised the issue of enhancing the `nx.algorithms.d_separated` submodule with additional two related algorithms.  1. for finding a minimal separating set, and  2. the other is to verify that a separating set is indeed minimal in a DAG.   In order to compute these, there are some operations that can be performed on a DAG:  1. moralizing a directed graph 2. computing the v-structure of a directed graph  ## Misc.  Do I have to add a changelog here too?  cc: @dschult 
issue
When writing pydot graph there is an extra "\n" character added#TITLE_END#### Current Behavior I am trying to save graphs to disc using the DOT language. However, when I save this simple graph, it does not match IO roundtrip.  ``` nx_graph = nx.DiGraph() nx_graph.add_nodes_from([0, 1, 2, 3, 4]) nx_graph.add_edges_from([(0, 4), (3, 4)]) pydot_graph = nx.nx_pydot.to_pydot(nx_graph)  print(pydot_graph) > strict digraph  { 0; 4; 3; 1; 2; 0 -> 4; 3 -> 4; } ```   Now when I write to disc... ``` nx.nx_pydot.write_dot(nx_graph, "/Users/adam2392/Downloads/test.dot") pygraph = pydot.graph_from_dot_file(     "/Users/adam2392/Downloads/test.dot", encoding="utf8" )[0]  print(pygraph.to_string()) > digraph G { 0; 4; 3; 1; 2; 0 -> 4; 3 -> 4; "\n"; } ``` ### Expected Behavior There should not be an extra "\n" character  ### Environment Python version: 3.8 NetworkX version: 2.7.1  
issue
Is it possible to draw networkx edges by attribute?#TITLE_END#Hi,   I'm trying to extend networkx for usage with causal graphs, which encompass multiple types of edges (i.e. direct and bidirected arrows).  To draw the edges such that they don't overlap I have to indicate the `edge_list` parameter inside networkx. Is it possible to add a parameter to draw edges based on edge attribute?  E.g. this code ends up becoming unwieldy if I have to manually specify every tuple of "direct" and "bidirected" edges.  ``` # nx.draw_networkx(dag, pos=pos) nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color="indigo") directed_edges = nx.draw_networkx_edges(     G,     pos,     edgelist=[('A', 'B', 'direct')],     node_size=node_sizes,     arrowstyle="->",     arrowsize=10,     # edge_color=edge_colors,     edge_cmap=cmap,     width=2,     # connectionstyle="arc3,rad=0.1" ) bd_edges = nx.draw_networkx_edges(     G,     pos,     edgelist=[('A', 'B', 'bidirected')],     node_size=node_sizes,     style='dotted',     # arrowstyle="->",     arrowsize=10,     # edge_color=edge_colors,     edge_cmap=cmap,     width=2,     connectionstyle="arc3,rad=0.4" )  bd_edges = nx.draw_networkx_edges(     G,     pos,     edgelist=[('B', 'A', 'bidirected')],     node_size=node_sizes,     style='dotted',     # arrowstyle="->",     arrowsize=10,     # edge_color=edge_colors,     edge_cmap=cmap,     width=2,     connectionstyle="arc3,rad=-0.4" ) ```
comment
> hi @dschult, `compute_v_structures` currently returns colliders, not v-structures. Renaming it to `compute_colliders` and adapting a little the docstring would already be sufficient as far as I can tell (could do a PR if wanted).  I am +0.5 in favor of this solution if we don't want v-structures. See below  > Otherwise, the way to fix it for computing v-structures would be a simple check on either parent node sharing an edge with the other parent. This is in fact how I am currently using it in my lib:  Another possibility is the following code:  ```     for node in G.nodes:         for p1, p2 in combinations(G.predecessors(node), 2):             if p1 not in G.predecessors(p2) and p2 not in G.predecessors(p1):                   yield((p1, node, p2)) ```  We simply need to add a unit-test for having adjacent parents to confirm that triplet is not a "v-structure", or unshielded collider.  > So I am not doing much more than adding the check for adjacency between the parents to decide if it is a collider or a true v-structure. The definition of v-structure is not completely unambiguous from what I can tell, but for reference, I would mention [Pearl's PRIMER, chapter 2 page 50](http://bayes.cs.ucla.edu/PRIMER/primer-ch2.pdf):  Agreed.  > The sorting should not happen IMO, as it is not essential to the functionality, yet limits its scope. I also don't think this function needs to be removed as finding colliders/v-structs may be of interest to others as well, but the documentation of the function should be made to align with its intention.  Yes I'm not exactly sure why there is sorting here. We can prolly remove it tbh. 
comment
> * The names for `i` and `r` arguments are poor choices and the descriptions don't indicate to me what those names stand for. Perhaps something like `included` and `restricted`? But maybe there are better names than those. > * While I'm talking about names, why do we name the sets u, v and then z? Are there better names than that? u and v are generic enough -- though usually used as nodes, not sets. But `z` should be named something more meaningful. Maybe `separator`?  +1 for these names.  > I'm also pretty sure the API names are not implemented yet. We've got `d_separated` and `minimal_d_separated` but `find_d_separator`. I think the proposal was for `find_d_separated` (in [this comment](https://github.com/networkx/networkx/pull/6438#issuecomment-1442310818)  I can help implement this when I get some time, unless someone else gets to it first.  > There are no tests using inputs `i` and `r`. Can those inputs just be removed? It seems like `r` could be handled by having the user input a subgraph of the original graph -- but there may be impacts of that I don't understand. What is the use case for the `i` set? Can it be obtained by morphing the input graph somehow? These optional inputs need fleshed out documentation and tests -- or removal from the api.  cc: @jaron-lee on this part? I'm not exactly sure. 
comment
@dschult I can also handle this by adding a return `None` in this edge-case, unless @jaron-lee wants to take the PR?
comment
Were there any blockers to this? Just checkin on the status cuz it would be nice to use this function as is.
comment
Is @jaron-lee still interested in addressing the above?
comment
Is there anything blocking this PR?
comment
Ah I see! Exciting milestone for networkx!
comment
Hi, sorry for the lateness.  Yes this was an intentional design to limit the necessity of re-running a full d_separated algorithm. However, upon inspection of this thread, it seems not intuitive. Would it be better to add a kwarg to optionally check for d-separation that is by default True? E.g.   ``` is_minimal_d_separator(g, 'C', 'F', {'D'}) # True is_minimal_d_separator(g, 'C', 'F', {'D'}, check=False) # False now ```  wdyt?
comment
@ilya-causalens if you're up for the PR, I can help review. Otw I can possibly do it this weekend. 
comment
@tamandeeps I think @ilya-causalens already started a PR? If not, and they want, you can start one and address the comments raised here?
comment
Hi @tamandeeps was there any progress on this?
comment
Hi @rossbar It seems the current open PR has stalled so I went ahead and i have opened up a PR to address this bug. 
comment
Was this ever addressed/implemented? If not, what are the challenges? It looks like based on the discussion the `MixedGraph` abstraction seemed plausible?  I had a similar question that I raised before seeing this issue: https://github.com/networkx/networkx/discussions/5408  
