issue
Fix documentation typos for clustering#TITLE_END#Minor change to the documentation of `cluster.clustering` to fix a double sentence and missing comas.  At the same time, it also clarifies that the possible triangles are the ones containing the node `u`, not all possible triangles in the graph. 
issue
Fixes for tickets #733 and #749#TITLE_END#Fixes for tickets #733 (Trac #747) and #749. 
comment
While I do agree that returning the negative cost cycle can be useful, we have to be careful in how we implement this.  As @dschult pointed out, what is returned is not actually a path, nor is it the negative cost cycle itself.  The negative cycle will be contained in the `pred` dictionary, but there will be other stuff as well.  Moreover, the `dist` dictionary is mostly meaningless when negative cost cycles are present.  Is it even worth returning it?  To make ideas a little more concrete, consider the following example.  ``` python >>> import networkx as nx >>> G = nx.DiGraph() >>> G.add_weighted_edges_from([(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), ...                            (5, 3, -4), (4, 6, 1), (6, 7,1)]) >>> nx.bellman_ford(G, 1, return_negative_cycle=True) ({1: None, 2: 1, 3: 5, 4: 3, 5: 4, 6: 4, 7: 6}, {1: 0, 2: 1, 3: 0, 4: 1, 5: 2, 6: 2, 7: 5}) ```  The 3-4-5 negative cycle is there, but not that easy to extract.  And the claim that `return_negative_cycle=True` makes, i.e., the negative cycle is returned, is not true from the user's perspective: he still has to search for the cycle in the `pred` dictionary.  The best approach could be to compute the cycle itself (probably best to do this in a small helper function) and return it. 
comment
Since there has been no feedback on this issue from the person who opened it in the last two years, I will mark it as closed. 
comment
I do not have time to go over the code in details, but this sure looks pretty nice!  I glimpsed over the code and did not see any obvious problems.  The runtimes are great!  Jordi, I think this can not only become the default for `connectivity`, but eventually the default max flow algorithm in nx. 
comment
I am wondering if creating a new package for this is not overkill.  If only a few functions would end up in this tree/forrest recognition, it is probably better to just make it a module in the algorithms package.  @markusian how many more such functions were you thinking about? 
comment
If the algorithm ignores the capacities, it might be because you need to specify the `capacity` keyword when you call `network_simplex`.  Can you provide more details?  I would like to know what graph you are working with, the expected results, and the flow returned by the simplex algorithm. 
comment
In order to check if this is a bug in NetworkX or a problem with your algorithm, we need an example (as simple as possible) where `network_simplex` fails to give you the expected result.  Do provide the data needed to produce the bug as well as the code you run.  Please, paste the code or link to a file; a screenshot makes it very hard for us to do actual debugging. 
comment
The problem is that you use the same ID number for students, choices and academics and you use just these ID numbers as nodes.  For instance, if you create an edge from S to student 1 and then an edge from academic 1 to T, then the graph has an edge (S, 1) and an edge (1, T).  Even though you wanted both 1's to actually represent something different, in the graph data structure they correspond to a single node.  The flow then gets routed from S to 1 to T directly, which means that when you interpret the results, you find that student 1 is not assigned to any choice.  You can probably solve your problem by making sure that no ID number is used twice. 
comment
You are right that floating point weights or demands can cause problem.  This is mentioned in the [documentation for `network_simplex`](http://networkx.github.com/documentation/latest/reference/generated/networkx.algorithms.flow.network_simplex.html#networkx.algorithms.flow.network_simplex).  To overcome this issue, you can try multiplying all your weights and demands by a scaling factor large enough to transform all rational numbers into integers.  This could be implemented implicitly in the mincost algorithm, but I think it is better to let this kind of preprocessing to the user. That being said, if there is a general consensus that the mincost algorithm should do the scaling, I'm open to changing this behaviour. 
comment
Since there is no follow up and no comment, I'll close this ticket for now. 
comment
With the current repository, your example works just fine.  However, the patch looks fine to me as well. Since it is simpler, we should apply it, I can't think of any reason why it would not work. 
comment
Negative cost cycles of finite capacity should be fine: they will receive as much flow as possible in order to lower the cost.  The min cost flow implementation works for multiple sources and multiple sinks. As such, you need to specify the demand of each node. If a node does not have the `demand` attribute set, it is considered to have zero demand. Your example should finish with a solution consisting of a zero flow of cost zero.  A more sensible example would be  ``` python import networkx as nx G = nx.DiGraph() G.add_node('a', demand=-1) G.add_node('b', demand=1) G.add_edge('a', 'b', capacity=1, weight=-1) G.add_edge('b', 'a', capacity=1, weight=-1) print networkx.min_cost_flow_cost(G) ```  That being said, the above example still does not terminate, which is a bug. Digons are always difficult to deal with in the current implementation. I'll fix this as soon as possible. 
comment
Yes, the original example is indeed fine. The problem is fixed now. I included your example as a test. 
