issue
Minimal d-separator function does not handle cases where no d-separating set exists#TITLE_END#The minimal d-separator function does not return a special value when no valid d-separating set exists.  ### Current Behavior  Currently the code returns: ``` >>> import networkx as nx >>> G = nx.DiGraph() >>> G.add_edge("A", "B") >>> nx.minimal_d_separator(G, "A", "B") set() ``` but this implies that A is marginally independent of B in G, which is false.  Compare with  ``` >>> import networkx as nx >>> G = nx.DiGraph() >>> G.add_edge("A", "B") >>> G.add_edge("C", "B") >>> nx.minimal_d_separator(G, "A", "C") set() ```  and this empty set correctly implies that A is marginally independent of C.  ### Expected Behavior The function should return None, raise an error, or otherwise indicate that there is no valid d-separating set for A and B in the above graph, in order to distinguish from cases where the empty set is indeed a valid d-separating set.  ### Steps to Reproduce See above.  ### Environment  Python version: 3.10.9 NetworkX version: 3.0  ### Additional context  Related to discussions in #6247 
issue
Fixes minimal d-separator function failing to handle cases where no d-separators exist#TITLE_END#Fixes #6430.  - Implement a check to verify the candidate minimal d-separator set is in fact a valid d-separating set - Added test to verify the function now returns None if there are no valid d-separating sets - Updated `release_dev.rst` to indicate changed API behavior - Updated documentation as required   <!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
comment
Thanks for that. Happy to introduce renaming and testing around the `i` and `r` issue. API names should be easy on my end.   Regarding the use of the inputs `i` and `r`, looking at the algorithm you definitely can't replicate removing `i` through passing a different graph (as this would require the moralization and subgraph operations to commute, which they don't). You also need to keep `r` - if you pass a subgraph of the original graph you risk removing certain paths, possibly leading you to conclude that you have a minimal separating set when in fact it might not separate at all (or perhaps no such set exists).  The use case for the `i` set being non-empty is if we want to find a minimal separating set that includes all vertices in `i`. Perhaps we have some reason to require conditioning on `i`, and want to know the minimal additional vertices to condition on for a separating set. Note that in this case we might end up with a larger minimal separating set compared to if `i` was empty (since not conditioning on `i` could leave certain paths closed due to colliders). It's a fairly niche use but I figured it's in the algorithm already and it would be more work to try and take it out correctly.  Similarly for `r` - maybe you want to consider only all separating sets of certain variables (and don't want to condition on certain other variables). However you'd still need to include these variables in the graph since this affects d-separatedness.  I'll have some time this week to try and close this out.
