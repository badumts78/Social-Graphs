issue
Improvements and test coverage for `line.py`#TITLE_END#Changes to `line.py` itself:  * due to the discussion in the documentation of `line_graph`, line graphs are generated with no loops.     It makes therefore sense to exclude graphs with loops from `inverse_line_graphs` * we can always pop u from `partitioned_vertices` since the cell `new_cell` contains all the neighbors of u,   and thus `deg_u = 0` after line 403. * we only ever use the length of ac_edges and bc_edges * the only way to have `len(triangle_nodes) != s+2` is if `G` has self-loops (otherwise each odd triangle contributes   exactly one new vertex to `triangle_nodes`).  Test changes: * adds coverage for working inverse line graph examples * adds a bunch of negative examples (the whole list of forbidden subgraphs of L.W.Beineke), which also covers all possible branches * adds some very basic tests for private internal functions
issue
Add an `initial` parameter to simple and dual Barábasi-Albert random graphs#TITLE_END#As asked in #3459, adds a new `initial` parameter to Barábasi-Albert random graph models that allows the user to specify a base graph.  Notes: - my IDE formatted some imports automatically; I left them in the PR but I can remove those changes if needed, - as noted in [this paper](http://www.mathematik.uni-muenchen.de/%7Ekpanagio/ModelsLitSS12/DegreeSequenceBA.pdf) (page 3), and somewhat in #3281, the BA model is ill-defined whenever some degrees are zero. For this reason, the initial graphs for `barabasi_albert_graph` and `dual_barabasi_albert_graph` have been changed to stars on (m+1) and max(m1, m2) + 1 vertices, respectively. For the simple model, this does not change the end result, since the first added vertex was always connected to the m others. - The tests have been improved: previously, the `repeat` parameter was useless since the seed (and hence the randomness) was fixed. The new behavior tests the functions for several distinct seeds.  Fixes #3459, fixes #3281 
issue
Fix article link in katz_centrality definition#TITLE_END#Both references to Katz' article have been fixed with the actual article link.  Fixes #4648 
comment
I tried to take a look at the code, and it is also pretty unreadable: lots of one-letter variables, sometimes with unintuitive choices... It would maybe benefit from a full rewrite, but even understanding the existing code looks quite arduous. 
comment
Hey there !  Disclaimer :  I am not a contributor to `networkx`, but I can try to answer at least your technical questions.  2. The entries need not be in `(0, 1)` ! For example, if `nstart = [1, 0, 0, 0]`, then you can convince yourself that `nstart_sum = 1` and therefore `x = [1, 0, 0, 0]`. The only thing that is ensured is that `nstart_sum != 0`, so that the division in this line does not throw an error. 3. The line you highlighted checks for convergence, i.e. "is my new vector close to my previous one" ? If the answer is true, then you've (approximately) found your eigenvector (since when the iterations get close, it means you're approaching the limit). 4. My guess is that `networkx` does not explicitly depend on `numpy` nor `scipy`, and thus there is a version of this function for when one of those packages is not installed. As a rule of thumb, if you have numpy on your system : use the numpy version !
