issue
Unhandled Exceptions in `panther_similarity`, `simrank_similarity`, `preferential_attachment` and `jaccard_coefficient`#TITLE_END#Hello, \ I've encountered a few corner cases while using Link Prediction and Similarity Measures Algorithms that lead to exceptions that aren't currently handled. ### 1. Panther Similarity ValueError with Isolated Nodes - **Current Behavior**:    - Executing `nx.panther_similarity` on a graph with isolated nodes results in `ValueError: probabilities contain NaN`. This issue might be arising due to the presence of an isolated node. - **Steps to Reproduce**: ```python G = nx.Graph() G.add_node(1) G.add_edges_from([(2, 3), (3, 4), (4, 5), (5, 6)]) nx.panther_similarity(G, source = 2) ```  ### 2. SimRank Similarity ValueError Instead of NodeNotFound - **Current Behavior**:    - Calling `nx.simrank_similarity` on a graph where node 7 does not exist results in `ValueError: 7 is not in list`. - **Expected Behavior**:    - The function should raise a `NodeNotFound` exception for better clarity when a non-existent node is specified. - **Steps to Reproduce**: ```python G = nx.Graph() G.add_edges_from([(1, 1),(1, 2), (1, 3), (4, 5), (5, 6)]) nx.simrank_similarity(G, source=7) ```  ### 3. Preferential Attachment TypeError and Incorrect Exception - **Current Behavior**:    - Using `nx.preferential_attachment` raises `TypeError: 'int' object is not iterable` and `NetworkXError: nbunch is not a node or a sequence of nodes`. - **Expected Behavior**:    - The function should raise a `NetworkXError: v is not in the graph` for non-existent nodes in the pairs provided. - **Steps to Reproduce**: ```python G = nx.Graph() G.add_edges_from([(1, 1),(1, 2), (1, 3), (4, 5), (5, 6)]) preds = nx.preferential_attachment(G, [(1, 2),(3, 7)]) for u, v, p in preds:     print(f"Preferential Attachment between nodes {u} and {v}: {p}") ```  ### 4. Jaccard Coefficient KeyError for Non-existent Node - **Current Behavior**:    - Executing `nx.jaccard_coefficient` where node `7` does not exist in `G` results in `KeyError: 7`. - **Expected Behavior**:    - The function should raise a `NetworkXError: v is not in the graph` for non-existent nodes in the pairs provided. - **Steps to Reproduce**: ```python G = nx.Graph() G.add_edges_from([(1, 1),(1, 2), (1, 3), (4, 5), (5, 6)]) preds = nx.jaccard_coefficient(G, [(1, 2),(3, 7)]) for u, v, p in preds:     print(f"Jaccard similarity between nodes {u} and {v}: {p}") ```  ### Environment  Python version: 3.9.10 \ NetworkX version: 3.2.1 
issue
Discrepancy in 'strongly_connected_components_recursive' for Detecting SCCs#TITLE_END#Hey NetworkX team! ðŸ‘‹ ### Description: While attempting to identify strongly connected components (SCCs) of a graph using the `strongly_connected_components`, `strongly_connected_components_recursive`, and `kosaraju_strongly_connected_components` methods provided by `networkx`, inconsistent SCCs were observed. Notably, the `strongly_connected_components_recursive` method identified node `8` as a separate SCC, while the other two methods included node `8` in a larger SCC.\ For context, I've minimized my original, much larger graph to a smaller version to isolate and highlight the issue.    ### Observed Behavior: - Using `strongly_connected_components`: [{0, 2, 3, 5, 6, 7, 8, 10}, {1}, {4}, {9}] - Using `strongly_connected_components_recursive`: [{8}, {0, 2, 3, 5, 6, 7, 10}, {1}, {4}, {9}] - Using `kosaraju_strongly_connected_components`: [{1}, {0, 2, 3, 5, 6, 7, 8, 10}, {9}, {4}]  ### Expected Behavior: All three methods should produce consistent SCCs. Node `8` should be part of the larger SCC `{0, 2, 3, 5, 6, 7, 8, 10}` based on the provided edges.  ### Steps to Reproduce: 1. Create a directed graph with the provided nodes and edges. 2. Compute SCCs using the `strongly_connected_components`, `strongly_connected_components_recursive`, and `kosaraju_strongly_connected_components` methods.  ### Environment: Python version: 3.8.10 NetworkX version: 3.1  ```python import networkx as nx from matplotlib import pyplot as plt   class Graph:     def __init__(self):         self.graph = nx.DiGraph()      def add_nodes(self, nodes):         for node in nodes:             self.graph.add_node(node)      def add_edges(self, edges):         for edge in edges:             self.graph.add_edge(edge[0], edge[1])      def compute_scc(self):         """Compute the result using three functions and print them"""         result1 = list(nx.strongly_connected_components(self.graph))         result2 = list(nx.strongly_connected_components_recursive(self.graph))         result3 = list(nx.kosaraju_strongly_connected_components(self.graph))          print("Using strongly_connected_components:", result1)         print("Using strongly_connected_components_recursive:", result2)         print("Using kosaraju_strongly_connected_components:", result3)  if __name__ == "__main__":     nodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]     edges = [         (0, 2), (0, 8), (0, 10), (2, 3), (3, 10),         (3, 0), (4, 6), (4, 1), (5, 6), (5, 7),         (6, 2), (6, 5), (7, 10), (8, 7), (9, 8),         (10, 6)     ]      graph_instance = Graph()     graph_instance.add_nodes(nodes)     graph_instance.add_edges(edges)     graph_instance.compute_scc() 
issue
 Inconsistency in Negative Cycle Detection Between Bellman-Ford and Goldberg-Radzik Algorithms#TITLE_END#### Description: When attempting to compute the shortest path length between two nodes in a graph using the Bellman-Ford and Goldberg-Radzik algorithms, inconsistent results regarding the presence of a negative cycle are obtained. Specifically, the Goldberg-Radzik algorithm suggests the presence of a negative cycle and fails to compute the path length, while the Bellman-Ford algorithm successfully computes the shortest path without detecting any negative cycles.  ### Observed Behavior:  Shortest path length between 6 and 0 using Bellman-Ford: 11 \ Goldberg_Radzik: A negative cycle exists in the graph. \ Shortest path length between 6 and 0 using Goldberg_Radzik: None   ### Expected Behavior: The results from both algorithms should be consistent. Either both algorithms should detect a negative cycle and fail to compute the path, or both should successfully compute the shortest path without detecting any negative cycles.  ### Steps to Reproduce: 1. Create a directed graph with the following nodes and edges:    - Nodes: [0, 1, 2, 3, 4, 5, 6, 7]    - Edges: (Provided in the code snippet below) 2. Attempt to compute the shortest path length between nodes `6` and `0` using both Bellman-Ford and Goldberg-Radzik algorithms.  ### Environment: Python version: 3.8.10 \ NetworkX version: 3.1  ```python # Python code to reproduce the issue import networkx as nx import matplotlib.pyplot as plt  class ManualGraphLoader:     def __init__(self):         self.G = self.create_graph_from_data()      def create_graph_from_data(self):         G = nx.DiGraph()         # Add nodes         for i in range(8):             G.add_node(i)          # Add edges with weights         edges_data = [             (0, 5, 12), (0, 7, 1), (0, 4, 6), (1, 0, -1), (2, 3, 5), (2, 7, -1), (4, 0, 12),             (5, 4, 15), (5, 3, -16), (6, 3, 4), (6, 5, -4), (6, 4, -1), (7, 5, -8), (7, 0, 9),             (7, 4, 7), (7, 2, 1)         ]          for src, tgt, weight in edges_data:             G.add_edge(src, tgt, weight=weight)          return G      def compute_shortest_path_length_bellman_ford(self, source, target):         """Computes shortest path length between source and target using Bellman-Ford algorithm."""         try:             return nx.bellman_ford_path_length(self.G, source=source, target=target, weight='weight')         except nx.NetworkXNoPath:             print(f"Bellman-Ford: No path exists between {source} and {target}.")             return None         except nx.NetworkXUnbounded:             print(f"Bellman-Ford: A negative cycle exists in the graph.")             return None      def compute_shortest_path_length_goldberg_radzik(self, source, target):         """Computes the shortest path length between source and target using the Goldberg-Radzik algorithm."""         try:             _, distance_map = nx.goldberg_radzik(self.G, source=source, weight='weight')             return distance_map.get(target, None)         except nx.NetworkXNoPath:             print(f"Goldberg_Radzik: No path exists between {source} and {target}.")             return None         except nx.NetworkXUnbounded:             print(f"Goldberg_Radzik: A negative cycle exists in the graph.")             return None      def get_graph(self):         """Returns the manually created graph."""         return self.G  if __name__ == "__main__":     graph_loader = ManualGraphLoader()     G = graph_loader.get_graph()      source, target = 6, 0      shortest_path_length = graph_loader.compute_shortest_path_length_bellman_ford(source, target)     print(f"Shortest path length between {source} and {target} using Bellman-Ford: {shortest_path_length}")      shortest_path_length = graph_loader.compute_shortest_path_length_goldberg_radzik(source, target)     print(f"Shortest path length between {source} and {target} using Goldberg_Radzik: {shortest_path_length}")      try:         cycle = nx.negative_edge_cycle(G, weight='weight')         if cycle:             print("The graph has a negative weight cycle.")         else:             print("The graph does not have a negative weight cycle.")     except nx.NetworkXUnbounded:         print("The graph has a negative cycle.")
