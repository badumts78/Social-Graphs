issue
multipartite_layout() fails when some node labels are not float#TITLE_END#<!--- Provide a general summary of the issue in the Title above --> Dear contributors, I am facing currently the following issue which I believe is a bug. Calling `multipartite_layout()` on a graph which has some nodes with labels which are not float (or integers) will result in an error.  ### Current Behavior Calling `multipartite_layout()` on a graph which has some nodes with hashable labels which are not float (or integers) will result in the following exception: ``` numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' did not contain a loop with signature matching types (dtype('<U32'), dtype('<U32')) -> dtype('<U32') ``` The traceback points at line 1101 of drawing/layout.py, in multipartite_layout:  `layer_pos = np.column_stack([xs, ys]) - offset`  ### Expected Behavior Calling `multipartite_layout()` on a graph which has some nodes with hashable labels which are not float (or integers) should return a `pos` allowing to draw the graph as a multipartite graph.  ### Steps to Reproduce Here is a minimum non-working example: ```python G = nx.Graph() G.add_node(0, subset='s0') G.add_node("b", subset='s0') G.add_node(2, subset='s1') G.add_node("d", subset='s1') G.add_edges_from([(0, 2), (0, "d"), ("b", 2)]) pos = nx.multipartite_layout(G)  # <-- raise the exception mentioned above ```  ### Environment <!--- Please provide details about your local environment --> Python version: 3.8.11 NetworkX version: 2.6.3 NumPy version: 1.20.3   ### Additional context I fixed this problem with the following workaround (from `multipartite_layout` code, in drawing/layout.py): ```python import numpy as np  if align not in ("vertical", "horizontal"):     msg = "align must be either vertical or horizontal."     raise ValueError(msg)  G, center = _process_params(G, center=center, dim=2) if len(G) == 0:     return {}  layers = {} for v, data in G.nodes(data=True):     try:         layer = data[subset_key]     except KeyError:         msg = "all nodes must have subset_key (default='subset') as data"         raise ValueError(msg)     layers[layer] = [v] + layers.get(layer, [])  pos = None nodes = []  width = len(layers) # for i, layer in layers.items():  # <-- original code for i, layer in enumerate(layers.values()):  # <-- modification     height = len(layer)     xs = np.repeat(i, height)     ys = np.arange(0, height, dtype=float)     offset = ((width - 1) / 2, (height - 1) / 2)     layer_pos = np.column_stack([xs, ys]) - offset     if pos is None:         pos = layer_pos     else:         pos = np.concatenate([pos, layer_pos])     nodes.extend(layer) pos = rescale_layout(pos, scale=scale) + center if align == "horizontal":     pos = np.flip(pos, 1) pos = dict(zip(nodes, pos)) return pos ``` However, being new to using NetworkX, I cannot guarantee that it is a reliable fix.
