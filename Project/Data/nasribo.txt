issue
shortest_simple_paths() missing some valid paths#TITLE_END#I'm using the shortest_simple_paths function on a DiGraph to calculate the top-k paths for my network. I found a few edge cases where the results are missing some valid paths.  I am using networkx 1.10 for Python 2.7.  Please see my simple example below.  ```python #In this example, I want to find all shortest simple paths #from IN to OUT. A is an intermediate node, B is an extra irrelevant node. # #Graph looks like this: # #[B]<--->[IN]----------->[OUT] #         |                ^ #         |                | #         +----->[A]-------+ # #There are two feasible paths: #  - First path: ['IN', 'A', 'OUT'] with cost 30 #  - Second path: ['IN', 'OUT'] with cost 60 #For some reason, second path isn't detected unless B is removed.  #Run the code below. import networkx as nx  #Create our full graph. G = nx.DiGraph() G.add_edge('IN', 'A', {"weight":10}) G.add_edge('A', 'OUT', {"weight":20}) G.add_edge('IN', 'OUT', {"weight":60}) G.add_edge('IN', 'B', {"weight":40}) G.add_edge('B', 'IN', {"weight":50})  g = nx.shortest_simple_paths(G, 'IN', 'OUT', "weight") print [p for p in g] #Expected: [['IN', 'A', 'OUT'], ['IN', 'OUT']] #Observed (BUG): [['IN', 'A', 'OUT']]  #Try again without B. G = nx.DiGraph() G.add_edge('IN', 'A', {"weight":10}) G.add_edge('A', 'OUT', {"weight":20}) G.add_edge('IN', 'OUT', {"weight":60}) g = nx.shortest_simple_paths(G, 'IN', 'OUT', "weight") print [p for p in g] #Expected: [['IN', 'A', 'OUT'], ['IN', 'OUT']] #Observed (OK): [['IN', 'A', 'OUT'], ['IN', 'OUT']] ```  I made a small change to the function to fix it (for my network at least). I don't know why it works, and I don't know if it will break anything for other networks. Please see possible bug fix below.  ```python #Attempted bug fix. Please check. I don't know why this works and if it breaks anything. #Note that my graph has no reflexive edges (v->v). while True: 	if not prev_path: 		length, path = shortest_path_func(G, source, target, weight=weight) 		listB.push(length, path) 	else: 		ignore_nodes = set() 		ignore_edges = set() 		for i in range(1, len(prev_path)): 			root = prev_path[:i] 			root_length = length_func(root) 			for path in listA: 				if path[:i] == root: 					ignore_edges.add((path[i-1], path[i])) 			#ignore_nodes.add(root[-1])  #<-- Do not add to ignore_nodes yet. 			try: 				length, spur = shortest_path_func(G, root[-1], target, 					ignore_nodes=ignore_nodes, 					ignore_edges=ignore_edges, 					weight=weight) 				path = root[:-1] + spur 				listB.push(root_length + length, path) 			except nx.NetworkXNoPath: 				pass 			ignore_nodes.add(root[-1])  #<-- Add only after shortest path. ```
