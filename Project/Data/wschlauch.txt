comment
roguebee,  I am not familiar with shapefiles. Still, I think you load it not correctly. Don't you have to specify a file instead of a folder? Meaning by this: just providing the foldername "Streetview" won't help you a bit.  I can't help more right now since I don't even get that GDAL-stuff to run on my linux. 
comment
Could you provide any example code? How did you call the method? My guess would be for an empty set of nodes, such that the length of top will be zero and therefore you divide by zero (giving the method no nodes implies all are in bottom). For a more exact statement an example would be useful. 
comment
Betweenness centrality is defined as the fraction of shortest paths your node is on. So you need all shortest paths to see on how many of them your node is located. Every way you are going to compute it you have to look how many shortest paths are in your network and how many are going through your node.  Closeness centrality is, as far as I know, the only method that allows to give the node specifically which makes sense with respect to how it is calculated (1/(average distance to all other nodes)).   So, the part that takes the longest will be the all pair shortest path problem.  Nevertheless, did you have a look at betweenness_centrality_subset(graph, source, target [, normalized = False, weight = None])? This calculates for a bunch of sources and a bunch of targets the betweenness. You can use it like betweenness = networkx.centrality.betweenness_centrality_subset(graph, [single_node], graph.nodes())  The problem is, you appear not include all shortest paths with this calculation and thus get "wrong" values (wrong in the sense of missing information since you take only the shortest paths from your source).  You can define for yourself a method betweenness_node(graph, node). This could call the networkx.centrality.betweenness_centrality(graph). As far as I know this returns a dict and thus you could return in your new method dict[node].  
comment
By the error you provided I don't see any problem. A graph with two odd degree nodes has an Eulerian trail and not a cycle. The difference is that you will not in the starting node but that you only visit every edge once. Does this solve your problem?   According to the code itself this should solve your problem for undirected as well as directed (multi-)graphs. 
comment
I just tried to reproduce your error. It seems to me it depends on the class of the graph you are using the all_neighbors method on. For a undirected graph it works like a charm, for a directed graph the named error message turns up.  I would actually guess that this is "wrong" implemented since digraph has a method to return the predecessors and successors.   values = iter(graph.predecessors(node) + graph.successors(node)) would be a solution working without itertools.  
comment
Ah, well. then it is fine. Since this is my first time using github, is there any way to check/close the issue?  
