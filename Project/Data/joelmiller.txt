issue
Have `compose` offer an option to sum attributes.#TITLE_END#This will need a bit of thought about how best to handle this...  Right now in `compose` where there are nodes with the same name or edges between the same nodes in both graphs and the attributes are in conflict, it takes the attributes of one of them over the other.  I can imagine many scenarios where we might want to sum the attributes if they are numeric.  I think it would be good to include an optional flag to allow summing of node or edge attributes.
issue
Documentation for `draw_shell` does not explain all arguments#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->    ### Current Behavior I was trying to debug code which assigns `nlist` in `draw_shell`. I didn't understand that until I read the source code.  The documentation for `draw_shell` says that the keyword arguments match `nx.draw_networkx`.  But `nlist` is not described there.  Instead it is described in `nx.shell_layout`.  ### Expected Behavior documentation that explains nlist.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug -->  ### Environment <!--- Please provide details about your local environment --> Python version: NetworkX version: 2.6.2   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
`geometric_edges` should be accessible#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above --> The function `geometric_edges` in `generators.geometric` is not callable.   However, I have found a case where someone wants to use it (more specifically is asking for a function that does it).  https://stackoverflow.com/q/68815295/2966723   I thought I'd just build an example for the person, but I can't figure out how to call it, presumably because it isn't in `__all__`, but I'm not an expert on this.  ### Current Behavior I get an error that the function doesn't exist.  ### Expected Behavior I'd like the function to run.  ### Steps to Reproduce      import networkx as nx     import random      pos = {n: (random.random(), random.random()) for n in range(100)}     G= nx.Graph()     G.add_nodes_from(pos)     radius = 0.1 #connect nodes of distance <0.1     G.add_edges_from(nx.generators.geometric.geometric_edges(G, radius,2))     > AttributeError: module 'networkx.generators.geometric' has no attribute 'geometric_edges'  ### Environment <!--- Please provide details about your local environment --> Python version: 3.7(?) NetworkX version: 2.4   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
corner-case bug in single_source_dijkstra#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->   ### Current Behavior If we call `single_source_disjkstra` with the source equal to target, it returns a path of length 0, even if the source is not in the graph  ### Expected Behavior If the source is not in the graph, it should give an error message.  ### Steps to Reproduce      import networkx as nx     G = nx.Graph()     nx.single_source_dijkstra(G, source=1, target=1)  ### Environment <!--- Please provide details about your local environment --> Python version: 3.7.6 NetworkX version:  2.4   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
Issue with attribute names in `greedy_modularity_communities`#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->   ### Current Behavior The function is defined as  `def greedy_modularity_communities(G, weight=None, resolution=1):`  but the first step that uses any attributes is  `m = sum([d.get("weight", 1) for u, v, d in G.edges(data=True)])`  If the graph has an attribute `"weight"`, but either wants to use no attribute (`weight=None`) or a different attribute, this will use the value for `"weight"` rather than what the user wants.   If the graph doesn't have an attribute `"weight"` and the user wants to use a different attribute, then this step will initialize `m` to have all weights equal.  ### Expected Behavior <!--- Tell us what should happen -->  It should use `m = sum([d.get(weight, 1) for u, v, d in G.edges(data=True)])`  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> I haven't worked out an example yet, but I'm confident this is an issue.  [I'm looking at [something that appears to be a bug](https://stackoverflow.com/questions/69006073/attributeerror-nonetype-object-has-no-attribute-get-when-using-greedy-modul?noredirect=1#comment122014639_69006073) on stackoverflow, but I don't yet understand what's going on there]. ### Environment <!--- Please provide details about your local environment --> Python version: NetworkX version:   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
Documentation and code in `floyd_warshall_numpy` are inconsistent#TITLE_END#### Current Behavior <!--- Tell us what happens instead of the expected behavior -->  Using `floyd_warshall_numpy` with a specified set of nodes will only find paths that are confined to that subset of nodes.  I'm not sure I agree with that choice, and certainly the documentation does not make it clear.  ### Expected Behavior <!--- Tell us what should happen -->  Based on the documentation, I would expect it to find a path that starts at one node and ends at another, even if that path must go through additional nodes not in the provided list.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug -->  https://stackoverflow.com/q/65771537/2966723  ### Environment <!--- Please provide details about your local environment --> Python version:  3.9 NetworkX version:  2.5   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
ancestors & descendant documentation appears overly restrictive#TITLE_END#I'm trying to find the out-component of a node, and it looks like I could use `nx.descendants` and just add the node to the descendants.  But the documentation of `descendants` suggests the graph needs to be a DAG, rather than just directed.  I don't see anything in the code that requires that restriction.  
issue
Make `shortest_path` use `bidirectional_dijkstra` as a default#TITLE_END#Currently by default if a user calls `shortest_path` with a source and a target but no weight, the algorithm will use `bidirectional_dijkstra` regardless of the method the user inputs.  But when the user has a weighted network, it will use either `bellman_ford` or `dijkstra` depending on the user's choice (with `dijkstra` the default).  I think `dijkstra` is slower than `bidirectional_dijkstra` in every case I've encountered.  So I feel like that should be added as an option, and perhaps it should be the default when source and target are known and the user hasn't specified which method to use.
issue
Example of how to plot a degree distribution could be simplified#TITLE_END#The example for plotting a degree distribution could be simplified quite a bit through using `plt.hist`  https://networkx.github.io/documentation/stable/auto_examples/drawing/plot_degree_histogram.html
issue
Apparent trouble with EdgeView __contains__#TITLE_END#See:  https://stackoverflow.com/questions/60184296/how-to-iterate-through-edges-in-a-graph-if-they-are-not-in-a-pre-selected-list  It appears that an EdgeView based on just some of the edges returns `True` for a containment test as long as the edge is in the graph, rather than that it is one of the edges in the EdgeView.
issue
Add "Jefferson High" network to the built-in networks#TITLE_END#The Jefferson High network from "Chains of affection" would be a nice network to add to the library.  [I may try to do this some day in the future when I have time again]
issue
instructions for removing self-edges in `configuration_model` are out of date#TITLE_END#In the configuration model documentation, it says to use `G.remove_edges_from(nx.selfloop_edges(G))` to remove self-edges.  This no longer works (I think it broke with 2.0).  Something to do with the dictionary changing size while iterating.  The documentation should be updated to `G.remove_edges_from(list(nx.selfloop_edges(G)))`.  It's curious that this breaks, because it does seem to work on directed graphs.  That suggests that there's something I don't understand about the internal details of how the different graph types are implemented.
issue
inaccurate node attributes for random intersection graph#TITLE_END#G = nx.uniform_random_intersection_graph(10,3,0.2)   G.nodes(data=True) > NodeDataView({0: {'bipartite': 0}, 1: {'bipartite': 0}, 2: {'bipartite': 0}, 3: {'bipartite': 0}, 4: {'bipartite': 0}, 5: {'bipartite': 0}, 6: {'bipartite': 0}, 7: {'bipartite': 0}, 8: {'bipartite': 0}, 9: {'bipartite': 0}})  But `G` isn't bipartite.  I assume it's because it was bipartite at the intermediate stage and that attribute was preserved.
issue
Consider adding a 'hierarchical' positioning algorithm for plotting trees.#TITLE_END#This answer I wrote on stackoverflow for positioning nodes in trees seems to be fairly popular - by far the most popular of the "tools" I've written there.  Assuming there are no license issues, could this be added as a default algorithm for networkx?  https://stackoverflow.com/a/29597209/2966723
issue
readthedocs error with setup.py#TITLE_END#I've got a package that uses networkx.  When I use readthedocs to build the documentation of my package, I get an error message when it tries to run networkx's setup.py:  > Obtaining networkx from git+https://github.com/networkx/networkx/#egg=networkx (from -r requirements.txt (line 1))   Updating /home/docs/checkouts/readthedocs.org/user_builds/epidemicsonnetworks/envs/latest/src/networkx clone   Running command git fetch -q --tags   Running command git reset --hard -q ab4d8c65759b51fa615837faa61e9436d0350107     ERROR: Complete output from command python setup.py egg_info:     ERROR: Traceback (most recent call last):       File "<string>", line 1, in <module>       File "/home/docs/checkouts/readthedocs.org/user_builds/epidemicsonnetworks/envs/latest/src/networkx/setup.py", line 22         python_version = f"{sys.version_info[0]}.{sys.version_info[1]}"                                                                       ^     SyntaxError: invalid syntax     ---------------------------------------- ERROR: Command "python setup.py egg_info" failed with error code 1 in /home/docs/checkouts/readthedocs.org/user_builds/epidemicsonnetworks/envs/latest/src/networkx/  Not sure what the issue is.   
issue
`make_small_graph` may fail to return error when it gets a bad input#TITLE_END#The following command was used in an answer on [stackoverflow](https://stackoverflow.com/a/56032840/2966723), and produces a very different result from desired:      gr = {         0: [4],         1: [3],         2: [2, 3, 4, 5],         3: [1, 3],         4: [3],         5: [4]     }     G = nx.make_small_graph(gr)  But it isn't what they expected to happen:      G.nodes()     > NodeView((2, 3, 4, 5))     G.edges()     > EdgeView([])  Because `gr[0]`, `gr[1]`, and `gr[2]` are defined, no error message is returned.  The code then creates an empty graph with the nodes from `gr[2]`  (that is with `[2,3,4,5]`).  It then fails to add any edges because `gr[0]` isn't of the right form.  I think the easiest fix is to add an extra condition if `gr[0]` is not either `'edgelist'` or `'adjacencylist'` to return an error. 
issue
Apparent bug in `betweenness_centrality_subset`#TITLE_END#See this question:  https://stackoverflow.com/questions/56569070/is-this-betweenness-calculation-correct  I believe the issue is that the `_rescale_e` function requires a factor of 0.5 if `G` is not directed, and that this got copied over into the `_rescale` function and wasn't fixed.  The result is that betweenness centrality appears to be off by a factor of 0.5.
issue
Documentation of `gnmk_random_graph` and `preferential_attachment_graph` is incomplete#TITLE_END#see https://stackoverflow.com/a/54836695/2966723 for more detail.  When we do `G = nx.bipartite.gnmk_random_graph(m,n,k)` networkx puts nodes `0` to `m-1` in partition `0` and `m` to `m+n-1` in partition `1`.    -  networkx actually assigns each node an attribute `'bipartite'` which is `0` or `1`.  The documentation makes no mention of this.  The documentation of `preferential_attachment_graph` also neglects this (everything else in `bipartite` seems to mention it)  Additionally, I wonder if it would improve the documentation if it explicitly stated which nodes end up in which partition (this comment would apply to all of `bipartite`).
issue
possible bug in read_gml?#TITLE_END#If I go to Mark Newman's webpage and download the karate club graph: http://www-personal.umich.edu/~mejn/netdata/karate.zip  I do the command      nx.read_gml('karate.gml')  and get the error       >NetworkXError: node #0 has no 'label' attribute  I get a different error when reading the example on the Wikipedia page for gml format.  https://en.wikipedia.org/wiki/Graph_Modelling_Language      >NetworkXError: expected an int, float, string or '[', found 'n42' at (4, 5)  Am I misunderstanding something? 
issue
`global_efficiency` is inefficient#TITLE_END#See https://stackoverflow.com/a/57032282/2966723  Currently the code takes every single pair of nodes (in both directions), and finds the length of the path between those two.    An obvious factor of 2 speedup is to change the denominator by a factor of 2 and use `combinations` rather than `permutations` to do the calculation, so that the path is only considered once.  (presumably would need to check that the graph is undirected first)  Alternately, another option is to use this code that I provided in my answer.      def my_global_efficiency(G):         '''author Joel C Miller            https://stackoverflow.com/a/57032282/2966723         '''          n = len(G)         denom = n*(n-1)         if denom>0:             efficiency = 0             for path_collection in nx.all_pairs_shortest_path_length(G):                 source = path_collection[0]                 for target in path_collection[1]:                     if target != source:                         efficiency += 1./path_collection[1][target]                     return efficiency/denom         else:             return 0 
issue
How to plot an invisible node?#TITLE_END#[I've posted this same question on stackoverflow, but I think it's going to be beyond most of the people there to address unless it's something matplotlib specific].  I would like to plot a completely invisible node in networkx.  Basically it should be as if it weren't plotted.  However, because of the structure of my code, I can't easily not plot it.  It would be simpler if I could set the `node_color` to be something like `"Invisible"`.  Since networkx uses `matplotlib.pyplot.scatter` to plot the nodes, I thought I would approach it like matplotlib.  To do this there, just set the `c` argument for a particular marker to be the string `"None"` (see https://stackoverflow.com/questions/23596575/plotting-with-a-transparent-marker-but-non-transparent-edge?lq=1).    Here's an example where 2 of the 5 markers are invisible:      plt.scatter(range(5), range(5), c = ["None", "black", 'red', "None", 'blue'])  [![enter image description here][1]][1]  Let's try that with networkx:      G = nx.erdos_renyi_graph(100,0.03)      nodelist = list(G.nodes())        colorlist = ["None" if node%2==0 else "red" for node in nodelist] #even nodes should be invisible     nx.draw_networkx(G, nodelist=nodelist, node_color=colorlist)     [![enter image description here][2]][2]  Notice that the even nodes are not invisible, they are black.  I don't understand, because when I look at the [source code][3] from networkx, the relevant line appears to be      node_collection = ax.scatter(xy[:, 0], xy[:, 1],                                  s=node_size,                                  c=node_color,                                  marker=node_shape,                                  cmap=cmap,                                  vmin=vmin,                                  vmax=vmax,                                  alpha=alpha,                                  linewidths=linewidths,                                  edgecolors=edgecolors,                                  label=label)  so `colorlist` should be sent directly to `scatter` without any alteration.    I'm very confused.    [1]: https://i.stack.imgur.com/Xjj2W.png   [2]: https://i.stack.imgur.com/E8YgW.png   [3]: https://networkx.github.io/documentation/stable/_modules/networkx/drawing/nx_pylab.html#draw_networkx_nodes
issue
Allow nx.double_edge_swap to take edgelist as an input#TITLE_END#double_edge_swap is a relatively slow algorithm.  This is because it has to sample edges uniformly at random from the edges.    In some applications I find I need to do this many, many times, and so this is the bottleneck.  I find that I can do much faster if I get the edgelist in advance and pass it as an argument.  Then I just need to select two edges from this list, do a bit of testing, do the swap, and update the edgelist.  I have attached sample code that runs much faster when an edgelist is provided (mostly copied and pasted from the current version and then edited to include optional edgelist.  I didn't copy over all the comments):  [my_double_edge_swap.txt](https://github.com/networkx/networkx/files/481586/my_double_edge_swap.txt) 
issue
issue in draw_networkx_labels if label has key not in pos#TITLE_END#I was plotting a network with labels.  The dict of labels I created was defined for a larger set of things than just the nodes in the graph I was drawing.  That caused a problem here in draw_networkx_labels:  ``` for n, label in labels.items():     (x,y)=pos[n] ```  the key wasn't a key of pos.  This could be fixed by something like:  ``` for n, label in labels.items():      if n not in pos:         continue     (x,y) = pos[n] ```  Here's a discussion of possibly [better approaches](http://stackoverflow.com/questions/29139012/iterating-over-shared-keys-in-two-dictionaries) to this part:   Further, I think it would be nice to be able to send a nodelist to draw...labels so that the user has a bit more direct control over what labels to draw without having to create a new dict for each case.  Here's some sample code:  ``` G = nx.Graph() G.add_node(1) labels = {1:'a', 2:'x'}     pos = nx.spring_layout(G) nx.draw_networkx_labels(G, pos, labels = labels) ```  ---  KeyError                                  Traceback (most recent call last) <ipython-input-24-7cfdd938fadd> in <module>() ----> 1 nx.draw_networkx_labels(G, pos, labels = labels)  /Users/jomiller/anaconda/lib/python2.7/site-packages/networkx/drawing/nx_pylab.pyc in draw_networkx_labels(G, pos, labels, font_size, font_color, font_family, font_weight, alpha, ax, **kwds)     709     text_items = {}  # there is no text collection so we'll fake one     710     for n, label in labels.items(): --> 711         (x, y) = pos[n]     712         if not cb.is_string_like(label):     713             label = str(label)  # this will cause "1" and 1 to be labeled the same  KeyError: 2 
issue
bug when creating a plot with a legend if edges have arrowheads#TITLE_END#Currently, it appears to me that when you plot an edge in a directed graph with an arrowhead and assign a label, the legend in the plot will show both the edge and the arrowhead with whatever label.    Looking at the source code, it appears that the error is in the command `arrow_collection.set_label(label)`.  I don't think this serves any purpose other than to ensure that the arrowhead is labelled but the edge itself is already labelled from the earlier command `edge_collection.set_label(label)`  See https://stackoverflow.com/q/44966874/2966723 for an example of this.
issue
contracted_nodes can fail if original graph has self-loops#TITLE_END#See https://stackoverflow.com/q/45476424/2966723 for more details.      G = nx.Graph([(1,2), (2,2)]) # Two nodes     H = nx.contracted_nodes(G, 1, 2, self_loops=False)     H.edges()   Fails to give expected output of a single node.
issue
Waxman graph parameters interchange roles#TITLE_END#In the Waxman Graph, edges are placed with probability   alpha x math.exp(-r/(beta x l))  However, in the usual definition the roles of alpha and beta are interchanged.  For example: http://www.huaxiaspace.net/academic/classes/fa00/cse202/project/08Waxman.pdf  May be a tough one to fix for backwards compatibility. 
issue
Add triangular and hexagonal lattice generators#TITLE_END#I also did a few little book-keeping edits to other parts of generators/classic.py: I changed G.name for 2d grid graph in nonperiodic case and corrected some typos in comments in the file. 
issue
Error message from eigenvector_centrality has typo.#TITLE_END#When `eigenvector_centrality` fails, the error message says:   > power iteration failed to converge in %d iterations."%(i+1))  It doesn't actually say how many iterations occured.  It should be something more like  > power iteration failed to converge in 100 iterations.  The current code for it is: `raise nx.NetworkXError("""eigenvector_centrality(): power iteration failed to converge in %d iterations."%(i+1))""")` 
issue
Add dijkstra version with node weights#TITLE_END#(minor request)  Sometimes people want to find the cheapest path where the cost is calculated based on node weights or a sum of edge and node weights.  In this case it is easy to translate into dijkstra's algorithm with just edge weights by assigning a weight to each edge equal to the sum of the weights of the nodes on either end (or just their average).  However, this requires doing modifications to all the edges a priori, and we may not want to modify the graph.  It should be straightforward to adapt the existing Dijkstra's algorithm to do this at each step as it runs. 
issue
Update documentation for `add_weighted_edges_from`#TITLE_END#For `add_weighted_edges_from(ebunch, weight='weight', **attr)` the documentation gives  > **ebunch** (container of edges) – Each edge given in the list or container will be added to the graph. The edges must be given as 3-tuples (u,v,w) where w is a number.  There's no clear reason why `w` should be a number.  I looked at the source code and it didn't seem to require it.  So I tested it with `w` a string, and it worked. 
issue
Better error message for eccentricity#TITLE_END#The error message in `eccentricity` from these lines  ``` if L != order:     msg = "Graph not connected: infinite path length"     raise networkx.NetworkXError(msg) ```  can occur in directed networks if the network is weakly connected but not strongly connected.  This causes confusion as the network is connected, but the error message says it isn't.  I suggest changing to   ```  if L != order:     msg = "Undirected graph not connected or directed graph not strongly-connected: infinite path length"     raise networkx.NetworkXError(msg) ```  Here is [an example](http://stackoverflow.com/questions/33114746/find-diameter-of-a-graph-in-networkx/33116490?noredirect=1#comment54048488_33116490) where someone had trouble with this. 
issue
Better error message if odd degree sum in configuration_model#TITLE_END#A student came to me a bit confused by an error message from `configuration_model`:   ``` if not sum(deg_sequence)%2 ==0:     raise nx.NetworkXError('Invalid degree sequence') ```  I think this is a hold-over from an earlier version which checked whether the degree sequence is graphical.  Now it just checks whether it is odd.  Could the error instead say 'odd degree sum'? 
issue
Minor inefficiency in dijkstra algorithms#TITLE_END#The dijkstra algorithms seem to all have `c=count()` in them.  The variable `c` is used a few times, but never for anything that actually affects the calculation.  I suspect it was put in during some testing.  In my (limited) testing, it can be removed without altering any results. 
issue
Update reference link for [R174]#TITLE_END#The link given in the closeness_centrality documentation for   > [R174](1, 2) Freeman, L.C., 1979. Centrality in networks: I. Conceptual clarification. Social Networks > 1, 215–239. http://www.soc.ucsb.edu/faculty/friedkin/Syllabi/Soc146/Freeman78.PDF  is broken.  I can find the paper at http://leonidzhukov.net/hse/2014/socialnetworks/papers/freeman79-centrality.pdf, or with a paywall at http://www.sciencedirect.com/science/article/pii/0378873378900217 
issue
need set current image in draw_networkx_nodes?#TITLE_END#I'm doing something along the lines of the following:  from networkx import * import pylab  G=fast_gnp_random_graph(10,0.2)  rect1=[0,0,1,0.5] rect2=[0,0.6,1,0.4] pylab.figure() ax1 = pylab.axes(rect1) ax2 = pylab.axes(rect2)  draw_networkx(G,ax=ax1)  ax2.plot([0,1],[0,2])  This will get an error.  Whereas if I move the draw_networkx command up before defining ax2, it's fine.  The reason is in the draw_networkx_nodes call, there is a call to pylab.sci().  The current axes are ax2.  But it just drew the figure on ax1.  So when it tries to set the current image, it dies.  It's not clear to me that there is a significant advantage to having the pylab.sci call - I don't know what the reason for it was.  But given that the drawing command accepts the axes to plot on as an argument, it might be nice to be able to plot on something other than what pylab thinks are the current axes.  I'm not very experienced playing with axes, so this may just be an issue with me not understanding standard conventions and trying to do something that is generally not considered kosher. 
issue
Tiny issue in comments for configuration model code#TITLE_END#The comments http://networkx.lanl.gov/reference/generated/networkx.generators.degree_seq.configuration_model.html currently mention that  "This configuration model construction process can lead to duplicate edges and loops. You can remove the self-loops and parallel edges (see below) which will likely result in a graph that doesn’t have the exact degree sequence specified. This “finite-size effect” decreases as the size of the graph increases."  This is potentially misleading.  The density of self-loops and parallel edges tends to decrease as the order of the graph increases.  However, typically the number of self-loops will approach a Poisson distribution with a nonzero mean, and similarly for the number of parallel edges.  So depending on what "this effect" is interpreted to mean, "this effect" may not decrease if we're talking about existence or total number of such "imperfections".  However, if we're talking density this effect does decrease.  To convince yourself of this: consider an individual with k stubs.  The probability of being joined to another stub of the same individual is basically (k-1)/N<k> .  So the probability a random individual is joined to itself scales like c/N for some constant c.  As N grows, this means we expect c self-loops.  Similarly for parallel edges.  Joel 
comment
As a comment, the documentation is clearly assuming a simple graph.  If this algorithm is updated to also consider self-loops, then the text in the documentation about the inequality between number of nodes in a vertex cover and the number of edges breaks down.
comment
I'm not saying it states that it assumes a simple graph.  But even though that statement is not made, it is still clear that it implicitly assumes no self edges.  First, the algorithm apparently doesn't work on graphs with self-loops, as you've noted.  So the algorithm assumes a simple graph.  Second, the in the documentation, the statement: "the total weight of the set is guaranteed to be at most twice the total weight of the minimum weight vertex cover" is false if there can be self-edges.
comment
I think you've got me there.  I was mis-reading what S and S^* where.
comment
If your idea is to run the existing algorithm and then augment with the nodes having self-loops, I don't think that will work.  Consider the line graph 1-2-3, with nodes 1 and 3 having self-loops.  The best vertex cover including self-loops is {1,3}.  But running it without 1&3 (or even just without the loops) would get {2}.
comment
Ah yes, I'm not doing well on my quick suggestions in this thread, am I?  I think I've now convinced myself that what you're suggesting would work.
comment
As a user, I'd push for delaying 2.0 until views is available.  In going from 1.x to 2.0, I expect that a fair amount of my existing code may no longer work.  Going from 2.0 to 2.1 I'm generally expecting existing code will continue to work, but new functionality may exist and some bugs may be fixed.
comment
I think we should strongly consider having the generators of 2-D lattices assign each node an attribute, say `pos` which gives its coordinates in the usual embedding. We should also consider whether it's worth adding a new layout function just for these few cases, particularly if it doesn't give the usual embedding.  Then these could be plotted with `pos=nx.get_node_attributes(G,'pos')`.  This would provide consistency across the various networks embedded in 2-D space e.g., [`random_geometric_graph`](https://networkx.github.io/documentation/latest/examples/drawing/random_geometric_graph.html).  Right now if we use the example given for a triangular lattice in `grid_layout`, we get  ![triangle](https://cloud.githubusercontent.com/assets/2914057/7846175/5ba184fc-04ff-11e5-83f3-0041bd7b8452.png) However, I don't know of anyone who would discuss a triangular lattice and isn't thinking about a regular triangular lattice - with equilateral triangles, a rotational symmetry, etc.  Here's the google image search on [triangular lattice](https://www.google.com/search?site=&tbm=isch&source=hp&biw=1440&bih=758&q=triangular+lattice&oq=triangular+lattice&gs_l=img.3..0l4j0i30j0i24l5.1603.4213.0.4365.18.10.0.0.0.0.334.1457.2-2j3.5.0....0...1ac.1.64.img..13.5.1457.4tU-tahBEOE).  The documentation provided for `triangular_lattice` references [wolfram](http://mathworld.wolfram.com/TriangularGrid.html) which states that this is the result of "tiling the plane regularly with equilateral triangles".  This implementation forces users to write their own function if they want to plot the triangular lattice in its usual form, and it's not really a pleasant function to create. 
comment
I think we agree that we disagree on whether the positions should be set when the graph is created or separately.  I don't think either will convince the other, so other opinions would definitely be good.  Separately - if we use itertools in the triangular lattice, it would probably be good to do the same in the other lattices for internal consistency.   
comment
The reason this appears to be happening (for this graph) is that there isn't a path from 2 to 3.  So it's interpreting this to mean that it doesn't have to delete any edges to disconnect the graph.  The documentation should be made clearer about how directed graphs are handled.  If the current version is the appropriate interpretation then the current test for whether the graph is weakly connected should be changed to test if it's strongly connected. 
comment
@jtorrens @litaotju   I would say that it's best to have it return `set([])` for an undirected network if it is already disconnected and also for a directed network if it's not strongly-connected.  So I'm actually suggesting a change to what happens if it gets a disconnected undirected graph.  I think it would be a mistake to make it respond to a directed graph differently if the graph is weakly connected compared to strongly connected.  Too much opportunity for a misunderstanding (how did I increase the size of the minimum edge cut by deleting an edge?)  There could be a flag for the user to say that they are interested in breaking the weakly-connected property rather than the strongly-connected property.  So what I'm proposing is   if `G` is undirected and disconnected, return `set([])`  if `G` is weakly connected, return `set([])`  if `G` is weakly connected, but the weakly-connected flag is `True` return whatever edges are needed to disconnect it [with some consideration to the case where (1,2) and (2,1) are both edges in the system - is that 1 to delete or 2?] 
comment
A similar error  is also reported [here](http://stackoverflow.com/questions/31946029/networkx-read-gml-error-networkx-exception-networkxerror-cannot-tokenize-ugra) 
comment
In Kleinberg's original paper it is normalized by the sum of the squares.  However, other options are used elsewhere.    "A Survey of Eigenvector Methods for Web Information Retrieval" (sec 3.2) discusses options available for the normalization.  It's fairly arbitrary - the algorithm is used for ranking things and the normalization is just an arbitrary scaling to every entry.  In hindsight, I think a better option might be to normalize such that the maximum entry is 1.  If the vector is very long, normalizing such that the sum (or the sum of squares) is one could result in some roundoff problems. 
