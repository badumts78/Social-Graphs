issue
Minimum cycle basis returns impossible cycles#TITLE_END#### Current Behavior The minimum cycle basis of the generalized Petersen graph G=P_7,2 appearing in example 11 of  Liebchen, Christian, and Romeo Rizzi. "Classes of cycle bases." Discrete Applied Mathematics 155.3 (2007): 337-355. generated by nx.minimum_cycle_basis contains cycles containing edges that are not edges of the graph.      <!--- Tell us what happens instead of the expected behavior -->  ### Expected Behavior  According to the cited paper, the following is a minimum cycle basis for the graph G:  [7, 9, 1, 0, 6,] [7, 12, 4, 5, 6,] [10, 8, 0, 1, 2] [13, 8, 0, 6, 5] [11, 9, 1, 2, 3] [12, 10, 2, 3, 4] [13, 11, 3, 4, 5] [7, 9, 1, 2, 10, 12]  This is an expected result. (The basis is not unique.) <!--- Tell us what should happen -->  ### Steps to Reproduce  ```python >>> import scipy.sparse as sp >>> import networkx as nx >>> row = [0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, ...        7, 7, 8, 8, 9, 10, 11] >>> col = [1, 6, 8, 9, 2, 3, 10, 4, 11, 5, 12, 6, 13, 7, ...        9, 12, 10, 13, 11, 12, 13] >>> data = [3.] * 14 + [2.] * 7 >>> G = sp.coo_array((data, (row, col)), shape=(14, 14)) >>> G = G + G.T >>> GG = nx.Graph(G) >>> nx.minimum_cycle_basis(GG) [[0, 5, 6, 8, 13], [0, 1, 6, 7, 9], [4, 5, 6, 7, 12], [0, 1, 2, 8, 10], [0, 6, 7, 8, 10, 12], [1, 2, 3, 9, 11], [2, 3, 4, 10, 12], [3, 4, 5, 11, 13]] ```  Here, for example (0, 5) is not an edge of the graph G.  ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.10.12 NetworkX version: 3.1  ### Additional context  <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
Minimum cycle basis incorrect#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  ### Current Behavior Consider the complete weighted graph on the vertices 0, 1, 2, 3 with edge weights ``` 01: 1 12: 1 23: 1 03: 1 13: 10 02: 10 ``` A cycle basis for this graph is given by the cycles ``` 0123 012 013 ``` The weights of these cycles are ``` 0123: 4 012: 12 013: 12 ```  However, the nx.minimum_cycle_basis function returns the basis `[[0, 1, 2], [0, 1, 3], [0, 2, 3]]`  All of these cycles have weight 12. Thus this is not a minimum cycle basis.  <!--- Tell us what happens instead of the expected behavior -->  ### Expected Behavior A valid minimum cycle basis is  `[[0, 1, 2], [0, 1, 3], [0, 1, 2, 3]]`  <!--- Tell us what should happen -->  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug --> ```python import networkx as nx G = nx.Graph() G.add_weighted_edges_from([(0, 1, 1.), (1, 2, 1.), (2, 3, 1.), (3, 0, 1.), (0, 2, 10.), (1, 3, 10.)]) print(nx.minimum_cycle_basis(G)) # [[0, 1, 2], [0, 1, 3], [0, 2, 3]] ``` ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.10.12 NetworkX version: 3.1  ### Additional context  <!--- Add any other context about the problem here, screenshots, etc. --> 
comment
Thank you @dschult . I am impressed. Well done. It seems to work as I expect. I will test it and let you know if I find any problems. 
comment
Running my original example from #6783 now yields an error message ```python row = [0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6,        7, 7, 8, 8, 9, 10, 11] col = [1, 6, 8, 9, 2, 3, 10, 4, 11, 5, 12, 6, 13, 7,        9, 12, 10, 13, 11, 12, 13] data = [3.] * 14 + [2.] * 7 G = sp.coo_array((data, (row, col)), shape=(14, 14)) G = G + G.T GG = nx.Graph(G) nx.minimum_cycle_basis(GG, weight='weight') ``` Long error message ending at the dijkstra function. Probably nothing serious?
comment
Here is another problem:  With the old version of cycles.py, the returned cycles are linearly independent: ```python import networkx as nx import numpy as np import scipy.sparse as sp  def complete_circle(n):     G = np.full((n,n), n + 1)     G[np.arange(len(G)), np.arange(len(G))] = 0     A = np.eye(n, k=1) + np.eye(n, k=-1)     G[-1, 0] = 1     G[0, -1] = 1     return G - n * A  G = complete_circle(8) GG = nx.Graph(G)  basis = nx.minimum_cycle_basis(GG, weight='weight') vertices = np.unique(np.concatenate(basis)) edges = set() for b in basis:     b = np.append(b, b[0])     for e in zip(b[:-1], b[1:]):         edge = tuple(sorted(e))         if edge not in edges:             edges.add(edge) A = np.zeros((1 + np.max(vertices), len(edges))) for idx, e in enumerate(edges):     s, t = e     A[s, idx] = -1     A[t, idx] = 1      print(A.shape[1] - np.linalg.matrix_rank(A, tol=None, hermitian=False), len(basis)) # 21 21 ``` With the new version the cycles are no longer linearly independent. The above code returns `18 21`.  
comment
With the original version of cycles.py, the following code seems to produce a valid minimum cycle basis ```python import networkx as nx import numpy as np import scipy.sparse as sp  def complete_circle(n):     G = np.full((n,n), n + 1)     G[np.arange(len(G)), np.arange(len(G))] = 0     A = np.eye(n, k=1) + np.eye(n, k=-1)     G[-1, 0] = 1     G[0, -1] = 1     return G - n * A  G = complete_circle(8) GG = nx.Graph(G)  basis = nx.minimum_cycle_basis(GG, weight='weight')  min_cycles = [] for b in basis:     s = nx.simple_cycles(GG.subgraph(b))     s = [np.append(x, x[0]) for x in s if len(x) == len(b)]     c = np.array([np.sum(G[x[:-1], x[1:]]) for x in s])     idx = np.argmin(c)     min_cycles.append(list(s[idx][:-1])) ``` The cycle basis is in the list called `min_cycles`. Since, in this example, a member of the minimum cycle basis is an Eulerian cycle, the above code computes all simple cycles in a complete graph. This obviously scales poorly. A better solution is needed. I have not read the Horton paper, and do not know if or how he deals with this issue.
comment
Thanks, now it seems to function as expected. I would like to test it some more but it will have to wait a week or so. I am traveling for vacation tomorrow.   The issue about comparing numpy integers and python integers is familiar to me. I do not quite understand it and I have not decided for myself how I want to deal with it. I guess I only want to allow native python data types as labels for nodes and vertices.  The reason I caught the problem about linear dependence is that I have my own way of computing a minimum cycle basis. The defect 'basis' produced by yesterday's code had a lower cost than the one I produced, so I had to figure out why the costs were different. As of now it seems that we produce cycle bases with identical cost, so there is a good chance both approaches produce valid minimum cycle bases.  Regarding tests, my understanding is that for algorithms like this one, where examples quickly become so complicated that they can not be analyzed manually, the best thing we can hope for is to verify that several different algorithms and implementations give compatible results. We can also do sanity checks like checking that we have produced linearly independent vectors. However such sanity checks can not be used to infer that the results are correct.  I am still impressed by the amount of work you have invested in this issue. Getting it all right on the first attempt is super human, so I see no reason to be disappointed.
