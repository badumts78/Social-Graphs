issue
Should type stubs be contributed to this repository?#TITLE_END#Hi, my name is Logan. I am working on a research project which will involve extensive use of `networkx`. First of all I would like to say thank you for such a comprehensive network analysis package!  I am building up type stubs for running static analysis on `networkx`. I expect to have light coverage of lots of the package, with extensive coverage of some of the basic classes like `Graph` by the time I'm done. Is this something that the `networkx` community would be interested in having added to the repository, or would it be more appropriate to try to push it to an third party typestub project like typeshed?
issue
Wiener index is a distance measure#TITLE_END#The Wiener index is actually a measure of distance.  So moved it from its own category to the Distance measures.
issue
Rename and move total_spanning_tree_weight#TITLE_END#**Old suggestion:**  Implements a formula for computation the number of spanning trees of a graph (https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem)  **Update:**  The function already existed under the name `total_spanning_tree_weight`. Instead, I updated that function with additional functionality, see #7098 and #7100.  **Further suggestions in this PR (or perhaps a new PR is better):**  - Rename from `total_spanning_tree_weight` to `number_of_spanning_trees` - Move from `Laplacian` subfolder to `Tree` subfolder   
issue
Improve total_spanning_tree_weight#TITLE_END#Following #7065  Improved `total_spanning_tree_weights`:  - Added the computation for directed graphs - Added examples - Added references - Added tests - Prevented corner case (like graphs without nodes or edges or disconnected graphs) 
issue
Add Kirchhoff index / Effective graph resistance#TITLE_END#The Kirchhoff index (also known as the effective graph resistance) is defined as the sum over the resistance distance of every pair of nodes.  The output of this function is equivalent to using _resistance_distance_ and summing over all possible node pairs. However, this function is (much) faster on large graphs (1,000+ nodes) than using _resistance_distance_.  Implements #6847. 
issue
Connect docs to doc_string for total_spanning_tree_weight#TITLE_END#Following #7065 Add missing link in documentation to `total_spanning_tree_weight`.
issue
remove unused code#TITLE_END##6925 improved the `resistance_distance`. I already removed some old code in #7053, but this PR removes a no-longer-used auxiliary function.
issue
Remove unused code resistance_distance#TITLE_END##6925 improved the `resistance_distance`, but I forgot to remove the old code, which is fixed in this PR.
issue
Add Tadpole graph#TITLE_END#Implements the Tadpole graph Source: https://en.wikipedia.org/wiki/Tadpole_graph 
issue
Fix a reference#TITLE_END#Fix a reference from `dorogovtsev_goltsev_mendes_graph`. Fixes a spelling error in one of the author's names and now refers to published article instead of arXiv.
issue
Speedup resistance_distance#TITLE_END#This is my first pull request ever, so there's probably a bunch of nooby errors in this PR. Any help is appreciated! Implements #6847.  Improvements to the function [resistance_distance](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.distance_measures.resistance_distance.html), primarily to speed it up, simplify its computation and to allow for the computation of the `resistance_distance` between all node pairs in the network. The main advantage of this PR is the O(N^2) speedup when computing the resistance distances of all node pairs compared to the original implementation.  Currently, the function returns the resistance distances as a dictionary (of dictionaries). Alternatively, we could also opt to return it as a numpy matrix, but I think the dictionary is preferred.  List of changes:  - Speedup and simplified computation of resistance_distance - Allowed for computation of the resistances between all nodes. Results in a O(N^2) speedup compared to original implementation. Ensured that the script remains backwards compatible - Handle corner case where G does not contain any nodes - Allowed for nodeA and nodeB to be equivalent - in that case, the resistance distance is zero - Added more test cases - Improved references - Added NetworkXError raises in documentation - Mentioned that self-loops are ignored and multigraphs are contracted
issue
Add Kemeny's constant#TITLE_END#Implemented Kemeny's constant for undirected and directed graphs. The concept is borrowed from Markov theory. Viewing the graph as a Markov chain, Kemeny’s constant is the expected number of time steps required for a Markov chain to transition from a starting state i to a random destination state sampled from the Markov chain's stationary distribution. Surprisingly, this quantity does not depend on which starting state i is chosen.  The concept is more and more used in graph theory and network science, see e.g. https://dl.acm.org/doi/abs/10.1145/3366423.3380093 https://epubs.siam.org/doi/abs/10.1137/22M1486728 https://www.sciencedirect.com/science/article/pii/S0024379517305256
issue
size() and degree() returning unexpected result when using a subgraph view#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->   ### Current Behavior <!--- Tell us what happens instead of the expected behavior --> After creating a subgraph view, H.size() wrongly returns 1. However, H.copy().size() correctly returns 2. This seems to be due to the degree of node "4" in H.degree wronlgy being specified as 0 instead of 2. H.copy().degree works as expected. This odd behaivor does not happen with every graph. But it happens when using a graph G as specified in Graph.txt (GraphML format) and creating a subgraph view as seen in Networkx_Bug.pdf. (See Additional context for a pdf of a Jupyter Notebook and a txt of the used graph in GraphML format)  ### Expected Behavior <!--- Tell us what should happen --> H.size() should return 2 just like H.copy().size() does.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> See attached Networkx_Bug.pdf (especially the bottom of page 3, section 4). The used graph in GraphML format is attached in Graph.txt. The files can be found under "Additional contex" uploaded to this bug report.  ### Environment <!--- Please provide details about your local environment --> Python version: 3.8.12 via Anaconda NetworkX version: 2.6.3   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> [Graph.txt](https://github.com/networkx/networkx/files/8053346/Graph.txt) [Networkx_Bug.pdf](https://github.com/networkx/networkx/files/8053347/Networkx_Bug.pdf)  
issue
AttributeError: 'Graph' object has no attribute 'pred'#TITLE_END#I get the error in the title when I try to use the algorithm below, specifically the GM.is_isomorphic() function. https://networkx.org/documentation/stable/reference/algorithms/isomorphism.vf2.html  I had to call networkx from R  (using reticulate R package) because most of my project uses R packages. So, I have to convert an igraph object (the igraph package) to a networkx graph object.  I have tried "nx.from_pandas_adjacency" and "nx.from_pandas_edgelist" and plug the graph objects in the isomorphic mapping object listed above. I got the error shown in the title.  The tricky part is that the graph converted from igraph object works well for other algorithms in networkx, but could not work out for this one. GM.is_isomorphic()   I would appreciate your help.   ### Current Behavior <!--- Tell us what happens instead of the expected behavior --> it raises an error: Error in py_call_impl(callable, dots$args, dots$keywords) :    AttributeError: 'Graph' object has no attribute 'pred'  ### Expected Behavior <!--- Tell us what should happen --> I expect it tells me whether G G1 are isomorphic or not.   ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> A<-as_edgelist(subgraphs[[isomor[i,1]]])     A<-pd$DataFrame(A,columns=c("from","to"))     G<-nx[["from_pandas_edgelist"]](A,"from","to")     B<-as_edgelist(subgraphs[[isomor[i,1]]])     B<-pd$DataFrame(B,columns=c("from","to"))     G1<-nx[["from_pandas_edgelist"]](B,"from","to") X=nx$algorithms$isomorphism$DiGraphMatcher(G,G1)     X$is_isomorphic()  ### Environment <!--- Please provide details about your local environment --> Python version: 3 NetworkX version: 2.5   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> <img width="440" alt="Screen Shot 2021-03-01 at 10 29 36 PM" src="https://user-images.githubusercontent.com/71058076/109592658-9c164b80-7add-11eb-80bf-c8984699582f.png">  
issue
Maximum cost path#TITLE_END#is there a solution to find the maximum cost path in a directed graph from source to distenation? I tried to use "all_simple_paths" method and then find the maximum cost path. However, the method itself did not scale and not even finish due to a large number of node ~ 700 and ~ 600 edges. Any suggestion?
issue
_random_subset is very inefficient#TITLE_END#In networkx.generators.random_graphs the function _random_subset is very inefficient. It leaves seq unaltered after choosing and adding x, so it can keep selecting the same element indefinitely before finding one that has not yet been added. In a Barabasi Albert graph where there is preferential attachment this can be especially costly because there will usually be nodes that will be selected with relatively high probability, so multiple repetitions is actually very likely. Considering that this loop is called for every element added to the graph, as n grows this can really slow down the performance. It is worth the extra overhead of making a copy of seq and removing every node after it has been selected to remove this repetition.
issue
Counting the number of nodes that “share” at least one edge#TITLE_END#I have created a network consisting of investors and companies using the Python library NetworkX:  # Creating our graph g = nx.from_pandas_edgelist(network_df, source='company_name', target='investor_names')   There is a node for every investor and company, and an edge connecting them if an investor has participated in a funding round.  For a given company, how can I count the number of companies in existence that share at least one investor with that given company? Let's call this number investor reach.  Consider the following example with four companies:  Company A is connected to Investors A, B and C Company B is connected to Investors A and B Company C is connected to Investor C only Company D is connected to Investor D  In this example, the investor reach of company A is equal to 2, since Company A shares investors with only Company B and Company C.
issue
contracting (merging) nodes #TITLE_END#I Hope everyone is well. I have an undirected graph. I want to aggregate two nodes but also do some arithmetic operation on the resultant edges's weight after the merging process. You can see in the first figure if a merge occurs between node (2) and node (0) using function `nx.contracted_nodes(G, source, target)` the result will be figure 2, but the new weight between (5) and (0) was chosen to be 27.92 instead of 23.11. It could be the order of the nodes. My question: How do I specify a certain operation on the new edge's weight; e.g. taking the average of the two edges? i.e. 25.51.    This is a toy example. Thanks,   <img width="286" alt="Screen Shot 2020-06-02 at 10 36 28 PM" src="https://user-images.githubusercontent.com/16886629/83590088-f53b5980-a522-11ea-8e41-7b6e0b920409.png"> <img width="251" alt="Screen Shot 2020-06-02 at 10 38 38 PM" src="https://user-images.githubusercontent.com/16886629/83590091-f5d3f000-a522-11ea-81db-07cd7e6a1b10.png"> 
issue
importing json file as directed graph#TITLE_END#Hello everyone, i have this json file named test.json:  `{"nodes": [{"id": "1"}, {"id": "2"}, {"id": "3"}, {"id": "4"}], "links": [{"target": "2", "source": "1"}, {"target": "4", "source": "2"}, {"target": "3", "source": "4"}, {"target": "2", "source": "3"}]}`  which shall be an directed graph. But i having trouble importing it as an directed graph in python:  ``` def read_json_file(filename):     with open(filename) as f:         js_graph = json.load(f)     return nx.json_graph.node_link_graph(js_graph)  G = read_json_file("test.json") DG = nx.DiGraph(G) ``` Because still i have an undirected graph:  ![test](https://user-images.githubusercontent.com/58147719/70791480-7a755b00-1d97-11ea-90dc-f69a4abde9e7.PNG)  What am i doing wrong? Should not be that hard to do...
issue
'NodeDataView' object has no attribute 'pop'#TITLE_END#in graph.py:   def nodes(self):         """A NodeView of the Graph as G.nodes or G.nodes().         Can be used as `G.nodes` for data lookup and for set-like operations.         Can also be used as `G.nodes(data='color', default=None)` to return a         NodeDataView which reports specific node data but no set operations.         It presents a dict-like interface as well with `G.nodes.items()`         iterating over `(node, nodedata)` 2-tuples and `G.nodes[3]['foo']`         providing the value of the `foo` attribute for node `3`. In addition,         a view `G.nodes.data('foo')` provides a dict-like interface to the         `foo` attribute of each node. `G.nodes.data('foo', default=1)`         provides a default for nodes that do not have attribute `foo`.         .........  ------------------------------------------------------- when I tried to do in Python 3.6.5:   `nodes = G.nodes(data=True) nodes.pop()`  I got the error like:  `AttributeError: 'NodeDataView' object has no attribute 'pop'`  -------------------------------------------------------  I am confused. Should it be compatible with set operation?
issue
 Laplacian Centrality for Weighted/Unweighted Networks (Static or Evolving)#TITLE_END#Following the paper in:  [Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama, J. (2017). Efficient incremental laplace centrality algorithm for dynamic networks. In International Workshop on Complex Networks and their Applications ,pages 341–352. Springer, Cham  Code Authors:  Mário Cordeiro Rui P. Sarmento Luís Lemos André Martinez      For Unweighted and Weighted Networks     Prepared for Static and Evolving Networks
issue
 topological_sort() got an unexpected keyword argument 'reverse'#TITLE_END#I must be doing something obviously wrong here but I can't see it.  ``` Traceback (most recent call last):   File "call_tasks..py", line 87, in <module>     get_dependency_sorted_node_list()   File "call_tasks..py", line 76, in get_dependency_sorted_node_list     for node_id in nx.topological_sort(G, reverse=True): TypeError: topological_sort() got an unexpected keyword argument 'reverse' (venv3.6) root@ubuntu-s-1vcpu-1gb-lon1-01:~# ``` Here's the code: ``` def get_dependency_sorted_node_list():     for node_id in nx.topological_sort(G, reverse=True):         print('VFX job id: {}'.format(node_id))         print('VFX job dependencies: {}'.format(G[node_id]))         node_attributes = G.node[node_id]         print('VFX job state: {}'.format(node_attributes['state']))         print('VFX job action: {}'.format(node_attributes['definition']['action']))         print('VFX job arguments: {}'.format(node_attributes['definition']['arguments']))  ```  
issue
AttributeError: module 'networkx' has no attribute 'topological_sort_recursive'#TITLE_END#topological_sort_recursive does not seem to be in the code I am using.  I have download the latest version from githib and installed it but it gives this error:  ``` Traceback (most recent call last):   File "call_tasks..py", line 87, in <module>     get_dependency_sorted_node_list()   File "call_tasks..py", line 76, in get_dependency_sorted_node_list     for node_id in nx.topological_sort_recursive(G): AttributeError: module 'networkx' has no attribute 'topological_sort_recursive' ```  Doing a dir on the networkx module shows that topological_sort exists but not topological_sort_recursive  ``` (venv3.6) root@ubuntu-s-1vcpu-1gb-lon1-01:~# python Python 3.6.3 (default, Oct  3 2017, 21:45:48) [GCC 7.2.0] on linux Type "help", "copyright", "credits" or "license" for more information. >>> import networkx >>> dir(networkx) ['AmbiguousSolution', 'DiGraph', 'ExceededMaxIterations', 'Graph', 'GraphMLReader', 'GraphMLWriter', 'HasACycle', 'LCF_graph', 'MultiDiGraph', 'MultiGraph', 'NetworkXAlgorithmError', 'NetworkXError', 'NetworkXException', 'NetworkXNoCycle', 'NetworkXNoPath', 'NetworkXNotImplemented', 'NetworkXPointlessConcept', 'NetworkXTreewidthBoundExceeded', 'NetworkXUnbounded', 'NetworkXUnfeasible', 'NodeNotFound', 'NotATree', 'OrderedDiGraph', 'OrderedGraph', 'OrderedMultiDiGraph', 'OrderedMultiGraph', 'PowerIterationFailedConvergence', '__author__', '__bibtex__', '__builtins__', '__cached__', '__date__', '__doc__', '__file__', '__license__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', 'absolute_import', 'adamic_adar_index', 'add_cycle', 'add_path', 'add_star', 'adj_matrix', 'adjacency', 'adjacency_data', 'adjacency_graph', 'adjacency_matrix', 'adjacency_spectrum', 'adjlist', 'algebraicconnectivity', 'algorithms', 'all', 'all_neighbors', 'all_node_cuts', 'all_pairs_bellman_ford_path', 'all_pairs_bellman_ford_path_length', 'all_pairs_dijkstra', 'all_pairs_dijkstra_path', 'all_pairs_dijkstra_path_length', 'all_pairs_lowest_common_ancestor', 'all_pairs_node_connectivity', 'all_pairs_shortest_path', 'all_pairs_shortest_path_length', 'all_shortest_paths', 'all_simple_paths', 'ancestors', 'antichains', 'approximate_current_flow_betweenness_centrality', 'articulation_points', 'assortativity', 'astar', 'astar_path', 'astar_path_length', 'atlas', 'attr_matrix', 'attr_sparse_matrix', 'attracting', 'attracting_component_subgraphs', 'attracting_components', 'attribute_assortativity_coefficient', 'attribute_mixing_dict', 'attribute_mixing_matrix', 'attrmatrix', 'authority_matrix', 'average_clustering', 'average_degree_connectivity', 'average_neighbor_degree', 'average_node_connectivity', 'average_shortest_path_length', 'balanced_tree', 'barabasi_albert_graph', 'barbell_graph', 'beamsearch', 'bellman_ford_path', 'bellman_ford_path_length', 'bellman_ford_predecessor_and_distance', 'betweenness', 'betweenness_centrality', 'betweenness_centrality_source', 'betweenness_centrality_subset', 'betweenness_subset', 'bfs_beam_edges', 'bfs_edges', 'bfs_predecessors', 'bfs_successors', 'bfs_tree', 'biconnected', 'biconnected_component_edges', 'biconnected_component_subgraphs', 'biconnected_components', 'bidirectional_dijkstra', 'bidirectional_shortest_path', 'binary', 'binomial_graph', 'bipartite', 'boundary', 'boundary_expansion', 'breadth_first_search', 'bridges', 'bull_graph', 'capacity_scaling', 'cartesian_product', 'caveman_graph', 'center', 'centrality', 'chain_decomposition', 'chains', 'chordal', 'chordal_cycle_graph', 'chordal_graph_cliques', 'chordal_graph_treewidth', 'chvatal_graph', 'circulant_graph', 'circular_ladder_graph', 'circular_layout', 'classes', 'classic', 'clique', 'cliques_containing_node', 'closeness', 'closeness_centrality', 'closeness_vitality', 'cluster', 'clustering', 'cn_soundarajan_hopcroft', 'coloring', 'common_neighbors', 'communicability', 'communicability_alg', 'communicability_betweenness_centrality', 'communicability_exp', 'community', 'complement', 'complete_bipartite_graph', 'complete_graph', 'complete_multipartite_graph', 'components', 'compose', 'compose_all', 'condensation', 'conductance', 'configuration_model', 'connected', 'connected_caveman_graph', 'connected_component_subgraphs', 'connected_components', 'connected_double_edge_swap', 'connected_watts_strogatz_graph', 'connectivity', 'constraint', 'contracted_edge', 'contracted_nodes', 'convert', 'convert_matrix', 'convert_node_labels_to_integers', 'core', 'core_number', 'coreviews', 'correlation', 'cost_of_flow', 'could_be_isomorphic', 'covering', 'create_empty_copy', 'cubical_graph', 'current_flow_betweenness', 'current_flow_betweenness_centrality', 'current_flow_betweenness_centrality_subset', 'current_flow_betweenness_subset', 'current_flow_closeness', 'current_flow_closeness_centrality', 'cut_size', 'cuts', 'cycle_basis', 'cycle_graph', 'cycles', 'cytoscape', 'cytoscape_data', 'cytoscape_graph', 'dag', 'dag_longest_path', 'dag_longest_path_length', 'dag_to_branching', 'davis_southern_women_graph', 'degree', 'degree_alg', 'degree_assortativity_coefficient', 'degree_centrality', 'degree_histogram', 'degree_mixing_dict', 'degree_mixing_matrix', 'degree_pearson_correlation_coefficient', 'degree_seq', 'degree_sequence_tree', 'dense', 'dense_gnm_random_graph', 'density', 'depth_first_search', 'desargues_graph', 'descendants', 'dfs_edges', 'dfs_labeled_edges', 'dfs_postorder_nodes', 'dfs_predecessors', 'dfs_preorder_nodes', 'dfs_successors', 'dfs_tree', 'diameter', 'diamond_graph', 'difference', 'digraph', 'dijkstra_path', 'dijkstra_path_length', 'dijkstra_predecessor_and_distance', 'directed', 'directed_configuration_model', 'directed_havel_hakimi_graph', 'directed_laplacian_matrix', 'directed_modularity_matrix', 'disjoint_union', 'disjoint_union_all', 'dispersion', 'distance_measures', 'distance_regular', 'dodecahedral_graph', 'dominance', 'dominance_frontiers', 'dominating', 'dominating_set', 'dorogovtsev_goltsev_mendes_graph', 'double_edge_swap', 'draw', 'draw_circular', 'draw_kamada_kawai', 'draw_networkx', 'draw_networkx_edge_labels', 'draw_networkx_edges', 'draw_networkx_labels', 'draw_networkx_nodes', 'draw_random', 'draw_shell', 'draw_spectral', 'draw_spring', 'drawing', 'duplication', 'duplication_divergence_graph', 'eccentricity', 'edge_betweenness', 'edge_betweenness_centrality', 'edge_betweenness_centrality_subset', 'edge_boundary', 'edge_connectivity', 'edge_current_flow_betweenness_centrality', 'edge_current_flow_betweenness_centrality_subset', 'edge_dfs', 'edge_disjoint_paths', 'edge_expansion', 'edge_load_centrality', 'edge_subgraph', 'edgedfs', 'edgelist', 'edges', 'effective_size', 'efficiency', 'ego', 'ego_graph', 'eigenvector', 'eigenvector_centrality', 'eigenvector_centrality_numpy', 'empty_graph', 'enumerate_all_cliques', 'erdos_renyi_graph', 'estrada_index', 'euler', 'eulerian_circuit', 'exception', 'expanders', 'expected_degree_graph', 'extended_barabasi_albert_graph', 'extrema_bounding', 'fast_could_be_isomorphic', 'fast_gnp_random_graph', 'faster_could_be_isomorphic', 'filters', 'find_cliques', 'find_cliques_recursive', 'find_cores', 'find_cycle', 'find_induced_nodes', 'florentine_families_graph', 'flow', 'flow_hierarchy', 'flow_matrix', 'floyd_warshall', 'floyd_warshall_numpy', 'floyd_warshall_predecessor_and_distance', 'freeze', 'from_dict_of_dicts', 'from_dict_of_lists', 'from_edgelist', 'from_graph6_bytes', 'from_nested_tuple', 'from_numpy_array', 'from_numpy_matrix', 'from_pandas_adjacency', 'from_pandas_edgelist', 'from_prufer_sequence', 'from_scipy_sparse_matrix', 'from_sparse6_bytes', 'frucht_graph', 'fruchterman_reingold_layout', 'full_rary_tree', 'function', 'gaussian_random_partition_graph', 'general_random_intersection_graph', 'generalized_degree', 'generate_adjlist', 'generate_edgelist', 'generate_gexf', 'generate_gml', 'generate_graphml', 'generate_multiline_adjlist', 'generate_pajek', 'generators', 'generic', 'geographical_threshold_graph', 'geometric', 'get_edge_attributes', 'get_node_attributes', 'gexf', 'global_efficiency', 'global_parameters', 'global_reaching_centrality', 'gml', 'gn_graph', 'gnc_graph', 'gnm_random_graph', 'gnp_random_graph', 'gnr_graph', 'goldberg_radzik', 'gomory_hu_tree', 'google_matrix', 'gpickle', 'graph', 'graph6', 'graph_atlas', 'graph_atlas_g', 'graph_clique_number', 'graph_edit_distance', 'graph_number_of_cliques', 'graphical', 'graphmatrix', 'graphml', 'graphviews', 'greedy_color', 'grid_2d_graph', 'grid_graph', 'harmonic', 'harmonic_centrality', 'has_bridges', 'has_path', 'havel_hakimi_graph', 'heawood_graph', 'hexagonal_lattice_graph', 'hierarchy', 'hits', 'hits_alg', 'hits_numpy', 'hits_scipy', 'hoffman_singleton_graph', 'house_graph', 'house_x_graph', 'hub_matrix', 'hybrid', 'hypercube_graph', 'icosahedral_graph', 'identified_nodes', 'immediate_dominators', 'in_degree_centrality', 'incidence_matrix', 'induced_subgraph', 'info', 'information_centrality', 'intersection', 'intersection_all', 'intersection_array', 'inverse_line_graph', 'is_aperiodic', 'is_arborescence', 'is_attracting_component', 'is_biconnected', 'is_bipartite', 'is_branching', 'is_chordal', 'is_connected', 'is_digraphical', 'is_directed', 'is_directed_acyclic_graph', 'is_distance_regular', 'is_dominating_set', 'is_edge_cover', 'is_empty', 'is_eulerian', 'is_forest', 'is_frozen', 'is_graphical', 'is_isolate', 'is_isomorphic', 'is_k_edge_connected', 'is_kl_connected', 'is_matching', 'is_maximal_matching', 'is_multigraphical', 'is_negatively_weighted', 'is_pseudographical', 'is_semiconnected', 'is_simple_path', 'is_strongly_connected', 'is_strongly_regular', 'is_tree', 'is_valid_degree_sequence_erdos_gallai', 'is_valid_degree_sequence_havel_hakimi', 'is_valid_joint_degree', 'is_weakly_connected', 'is_weighted', 'isolate', 'isolates', 'isomorphism', 'jaccard_coefficient', 'jit', 'jit_data', 'jit_graph', 'johnson', 'join', 'joint_degree_graph', 'joint_degree_seq', 'json_graph', 'k_components', 'k_core', 'k_corona', 'k_crust', 'k_edge_augmentation', 'k_edge_components', 'k_edge_subgraphs', 'k_nearest_neighbors', 'k_random_intersection_graph', 'k_shell', 'kamada_kawai_layout', 'karate_club_graph', 'katz', 'katz_centrality', 'katz_centrality_numpy', 'kl_connected_subgraph', 'kosaraju_strongly_connected_components', 'krackhardt_kite_graph', 'ladder_graph', 'laplacian_matrix', 'laplacian_spectrum', 'laplacianmatrix', 'lattice', 'layout', 'leda', 'lexicographic_product', 'lexicographical_topological_sort', 'linalg', 'line', 'line_graph', 'link_analysis', 'link_prediction', 'load', 'load_centrality', 'local_bridges', 'local_constraint', 'local_efficiency', 'local_reaching_centrality', 'lollipop_graph', 'lowest_common_ancestor', 'lowest_common_ancestors', 'make_clique_bipartite', 'make_max_clique_graph', 'make_small_graph', 'margulis_gabber_galil_graph', 'matching', 'max_flow_min_cost', 'max_weight_matching', 'maximal_independent_set', 'maximal_matching', 'maximum_branching', 'maximum_flow', 'maximum_flow_value', 'maximum_spanning_arborescence', 'maximum_spanning_edges', 'maximum_spanning_tree', 'min_cost_flow', 'min_cost_flow_cost', 'min_edge_cover', 'minimum_branching', 'minimum_cut', 'minimum_cut_value', 'minimum_cycle_basis', 'minimum_edge_cut', 'minimum_node_cut', 'minimum_spanning_arborescence', 'minimum_spanning_edges', 'minimum_spanning_tree', 'minors', 'mis', 'mixing', 'mixing_dict', 'mixing_expansion', 'modularity_matrix', 'modularity_spectrum', 'modularitymatrix', 'moebius_kantor_graph', 'multi_source_dijkstra', 'multi_source_dijkstra_path', 'multi_source_dijkstra_path_length', 'multidigraph', 'multigraph', 'multiline_adjlist', 'mycielski', 'mycielski_graph', 'mycielskian', 'navigable_small_world_graph', 'negative_edge_cycle', 'neighbor_degree', 'neighbors', 'network_simplex', 'networkx', 'newman_watts_strogatz_graph', 'node_attribute_xy', 'node_boundary', 'node_clique_number', 'node_connected_component', 'node_connectivity', 'node_degree_xy', 'node_disjoint_paths', 'node_expansion', 'node_link', 'node_link_data', 'node_link_graph', 'nodes', 'nodes_with_selfloops', 'non_edges', 'non_neighbors', 'nonisomorphic_trees', 'normalized_cut_size', 'normalized_laplacian_matrix', 'not_implemented_for', 'null_graph', 'number_attracting_components', 'number_connected_components', 'number_of_cliques', 'number_of_edges', 'number_of_isolates', 'number_of_nodes', 'number_of_nonisomorphic_trees', 'number_of_selfloops', 'number_strongly_connected_components', 'number_weakly_connected_components', 'numeric_assortativity_coefficient', 'numeric_mixing_matrix', 'nx', 'nx_agraph', 'nx_pydot', 'nx_pylab', 'nx_shp', 'nx_yaml', 'octahedral_graph', 'operators', 'optimal_edit_paths', 'optimize_edit_paths', 'optimize_graph_edit_distance', 'ordered', 'out_degree_centrality', 'overall_reciprocity', 'pagerank', 'pagerank_alg', 'pagerank_numpy', 'pagerank_scipy', 'pairs', 'pajek', 'pappus_graph', 'parse_adjlist', 'parse_edgelist', 'parse_gml', 'parse_graphml', 'parse_leda', 'parse_multiline_adjlist', 'parse_pajek', 'partial_duplication_graph', 'path_graph', 'periphery', 'petersen_graph', 'planted_partition_graph', 'power', 'powerlaw_cluster_graph', 'predecessor', 'preferential_attachment', 'prefix_tree', 'product', 'project', 'projected_graph', 'quotient_graph', 'ra_index_soundarajan_hopcroft', 'radius', 'random_clustered', 'random_clustered_graph', 'random_degree_sequence_graph', 'random_geometric_graph', 'random_graphs', 'random_k_out_graph', 'random_kernel_graph', 'random_layout', 'random_lobster', 'random_partition_graph', 'random_powerlaw_tree', 'random_powerlaw_tree_sequence', 'random_regular_graph', 'random_shell_graph', 'random_tree', 'reaching', 'read_adjlist', 'read_edgelist', 'read_gexf', 'read_gml', 'read_gpickle', 'read_graph6', 'read_graphml', 'read_leda', 'read_multiline_adjlist', 'read_pajek', 'read_shp', 'read_sparse6', 'read_weighted_edgelist', 'read_yaml', 'readwrite', 'reciprocity', 'recursive_simple_cycles', 'relabel', 'relabel_gexf_graph', 'relabel_nodes', 'relaxed_caveman_graph', 'release', 'reportviews', 'rescale_layout', 'resource_allocation_index', 'restricted_view', 'reverse', 'reverse_view', 'rich_club_coefficient', 'richclub', 'ring_of_cliques', 'rooted_product', 's_metric', 'scale_free_graph', 'sedgewick_maze_graph', 'selfloop_edges', 'semiconnected', 'set_edge_attributes', 'set_node_attributes', 'shell_layout', 'shortest_path', 'shortest_path_length', 'shortest_paths', 'shortest_simple_paths', 'similarity', 'simple_cycles', 'simple_paths', 'single_source_bellman_ford', 'single_source_bellman_ford_path', 'single_source_bellman_ford_path_length', 'single_source_dijkstra', 'single_source_dijkstra_path', 'single_source_dijkstra_path_length', 'single_source_shortest_path', 'single_source_shortest_path_length', 'single_target_shortest_path', 'single_target_shortest_path_length', 'small', 'smetric', 'social', 'soft_random_geometric_graph', 'sparse6', 'spectral_layout', 'spectrum', 'spring_layout', 'square_clustering', 'star_graph', 'stochastic', 'stochastic_graph', 'stoer_wagner', 'strong_product', 'strongly_connected', 'strongly_connected_component_subgraphs', 'strongly_connected_components', 'strongly_connected_components_recursive', 'structuralholes', 'subgraph', 'subgraph_alg', 'subgraph_centrality', 'subgraph_centrality_exp', 'swap', 'symmetric_difference', 'tensor_product', 'test', 'tests', 'tetrahedral_graph', 'thresholded_random_geometric_graph', 'to_dict_of_dicts', 'to_dict_of_lists', 'to_directed', 'to_edgelist', 'to_graph6_bytes', 'to_nested_tuple', 'to_networkx_graph', 'to_numpy_array', 'to_numpy_matrix', 'to_numpy_recarray', 'to_pandas_adjacency', 'to_pandas_edgelist', 'to_prufer_sequence', 'to_scipy_sparse_matrix', 'to_sparse6_bytes', 'to_undirected', 'topological_sort', 'tournament', 'transitive_closure', 'transitive_reduction', 'transitivity', 'traversal', 'tree', 'tree_all_pairs_lowest_common_ancestor', 'tree_data', 'tree_graph', 'trees', 'triad_graph', 'triadic_census', 'triads', 'triangles', 'triangular_lattice_graph', 'trivial_graph', 'truncated_cube_graph', 'truncated_tetrahedron_graph', 'turan_graph', 'tutte_graph', 'unary', 'uniform_random_intersection_graph', 'union', 'union_all', 'unweighted', 'utils', 'vitality', 'volume', 'voronoi', 'voronoi_cells', 'watts_strogatz_graph', 'waxman_graph', 'weakly_connected', 'weakly_connected_component_subgraphs', 'weakly_connected_components', 'weighted', 'wheel_graph', 'wiener', 'wiener_index', 'windmill_graph', 'within_inter_cluster', 'write_adjlist', 'write_edgelist', 'write_gexf', 'write_gml', 'write_gpickle', 'write_graph6', 'write_graphml', 'write_graphml_lxml', 'write_graphml_xml', 'write_multiline_adjlist', 'write_pajek', 'write_shp', 'write_sparse6', 'write_weighted_edgelist', 'write_yaml'] >>>       ```
issue
duplicate edge IDs when exporting to GraphML#TITLE_END#Hello,  I used the following code to create the graph from a list of tuples [(start, end)] and export it to graphml:  ``` import networkx as nx g = nx.MultiDiGraph() dir_edges = reduce(lambda x, y: x + y, map(list, self._walked_path.values())) # list of tuples g.add_edges_from(dir_edges) pos = nx.spring_layout(g) nx.draw_networkx_nodes(g, pos, node_size=75) nx.draw_networkx_edges(g, pos, arrows=True) ```  When yEd showed me all the nodes but no edges, I looked into the graphml file and saw the following:  ``` <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"><graph edgedefault="directed"> <node id="1node"/> <node id="2node"/> <node id="3node"/> <node id="4node"/> <edge id="0" source="1node" target="2node"/> <edge id="0" source="1node" target="3node"/> <edge id="0" source="3node" target="4node"/> <edge id="0" source="1node" target="4node"/> </graph></graphml> ```  After changing the IDs to unique values, yEd displayed the graph perfectly fine. Is there some issue with the generation or am I overlooking something? Also, yEd does not seem to be able to extract node IDs as nodes remain unnamed.  Python3.6 Ubuntu 17.10 networkx2.0
issue
Add directed graphs support for jit_graph reading#TITLE_END#Just added the support for getting directed graphs from a previously generated JIT file.
issue
Can't import directed graphs with jit_graph#TITLE_END#`jit_graph` only imports non-oriented graphs.
issue
PyPy on travis is very old#TITLE_END#https://travis-ci.org/networkx/networkx look here, PyPy is version 2.5, BUT there's already 5.4.1! Can you please update PyPy to the latest? https://github.com/travis-ci/travis-ci/issues/5027 here this issue. In this issue you can find a script to test against latest stable PyPy 
issue
eigenvector_centrality does not converge for 'periodic' graphs#TITLE_END#The way eigenvector_centrality is implemented, it cannot work for some 'periodic' graphs because of the way power iteration works. (By periodicity, I mean the same definition than a periodicity of a Markov Chain cf https://en.wikipedia.org/wiki/Markov_chain paragraph 4.2).  For example, it will not work for nx.path_graph(n) where n is an odd number. For example, the eigenvector in the main loop the the graph nx.path_graph(3) oscillates between these two values:  ['0 0.333', '1 0.333', '2 0.333'] ['0 0.408', '1 0.816', '2 0.408'] ['0 0.577', '1 0.577', '2 0.577'] ['0 0.408', '1 0.816', '2 0.408'] ['0 0.577', '1 0.577', '2 0.577'] ['0 0.408', '1 0.816', '2 0.408'] ['0 0.577', '1 0.577', '2 0.577'] etc...  This convergence issue is linked to the power iteration method and to the fact that the graph is periodic. One easy way to solve this issue is to make the graph aperiodic by adding to the adjacency matrix a non-null diagonal when doing the power iteration method.  For example, we could insert in line https://github.com/networkx/networkx/blob/master/networkx/algorithms/centrality/eigenvector.py#L119 the following (outside of the second loop):  x[n] += xlast[n]  This cheap trick works in my case. 
issue
Graph Initialisation Support for Tuple Edge-lists#TITLE_END#Currently `convert.py` explicitly checks the type of a potential edge list. This disallows you from using tuples (which is pretty well-supported in the Python syntax) and causes some rather unexpected crashes when you use tuples as opposed to lists or iterators.  ``` yuzucha> python Python 2.7.4 (default, Sep 26 2013, 03:20:56)  [GCC 4.7.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. >>> from networkx import Graph >>> Graph(data=((1, 0, ), )) Traceback (most recent call last):   File "<stdin>", line 1, in <module>   File "networkx/classes/graph.py", line 214, in __init__     convert.to_networkx_graph(data,create_using=self)   File "networkx/convert.py", line 149, in to_networkx_graph     raise nx.NetworkXError("Input is not a valid edge list") networkx.exception.NetworkXError: Input is not a valid edge list >>> Graph(data=[(1, 0, ), ]) <networkx.classes.graph.Graph object at 0xab89fac> >>> Graph(data=iter(((1, 0, ), ))) <networkx.classes.graph.Graph object at 0xab8e0cc> ```  The patch passes the test suite, but I have not added any additional tests for this specific feature. 
issue
[SUGGESTION] Change convert_node_labels_to_integers to behave nicer#TITLE_END#While there is nothing wrong with convert_node_labels_to_integers(), I suggest changing its name and/or description, for I find it a bit misleading right now.  Right now it says: "Return a copy of the graph G with the nodes relabeled with integers.", without further explaining (magic integers?). I think it'd be nice if it said something like: "Return a copy of the graph G with the nodes relabeled to a succession of consecutive integers."  I am aware this is a very subtle change, but I believe it will work to make it easier to understand.  Cheers  PS: now the title of this thing is misleading. Sorry about that. 
issue
[NX1.7] Crash with read_gexf(g) if there are boolean attributes#TITLE_END#Repro steps:  > > > import networkx as nx > > > g = nx.Graph() > > > g.add_node(1, attrib=True) > > > nx.write_gexf(g, 'out.gexf') > > > nx.read_gexf('out.gexf')  How to fix it:  In networkx/readwrite/gexf.py :  line 208: convert_bool={'true':True,'false':False} edit into: line 208: convert_bool={'True':True, 'false':False} 
issue
draw_networkx_edge_labels misdocumented keyword#TITLE_END#http://networkx.lanl.gov/archive/networkx-1.5/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edge_labels.html  For networkx.draw_networkx_edge_labels, the documentation indicates that the keyword "labels" should be used. However the keyword "edge_labels" actually needs to be used. 
issue
networkx gml export linux ubuntu 12.04#TITLE_END#When running the code below the GML file that is generated contains to many quotations. For example:    node [     id 0     label "C00394"     graphics [        outline_width 1.0       outline ""#666666""       w 20.0       h 20.0       y "290"       x "1722"       type ""ellipse""       fill ""#FF0000""     ]   ]  y, x, type and fill contain either 1 or two quotes where they should have 0 or 1.   import networkx as nx  G = nx.Graph() G.add_edge(0, 1, weight=0.1, label='edge', graphics={     'width': 1.0, 'fill': '"#0000ff"', 'type': '"line"', 'Line': [],     'source_arrow': 0, 'target_arrow': 0}) nx.set_node_attributes(G, 'graphics', {     0: {'x': -85.0, 'y': -97.0, 'w': 20.0, 'h': 20.0,         'type': '"ellipse"', 'fill': '"#889999"', 'outline': '"#666666"',         'outline_width': 1.0},     1: {'x': -16.0, 'y': -1.0, 'w': 40.0, 'h': 40.0,         'type': '"ellipse"', 'fill': '"#ff9999"', 'outline': '"#666666"',         'outline_width': 1.0}     }) nx.set_node_attributes(G, 'label', {0: "0", 1: "1"}) nx.write_gml(G, 'network.gml') 
comment
Thanks for your contribution! Some thoughts:  - How slow/fast is this algorithm? Is the problem NP-hard? If so, it may be wise to mention that in the doc_string. How is this function related to `complete_to_chordal_graph` ? - The name of the new function isn't particularly instructive to me. Is there a better name? - Your example doesn't show the expected output - Is this algorithm implemented for directed, multigraphs, directed multigraph and disconnected graphs? It isn't mentioned in the docs, nor it is implemented. Don't forget to add tests as well. - Move the text under "Notes" to the second line of the documentation. This is crucial information to understand what the function does. I'm no expert in this field, so I don't understand what it means, but try to make it as easy to read as possible - In the `Notes` it is mentioned that the input graph should be chordal. Why isn't that tested? - Add another non-Wikipedia reference, if available - Add more tests, covering edge cases, like disconnected graphs, graphs with only 1 node, etc. - As mentioned before, you may consider answering the questions raised in #6873 if you have the time and expertise
comment
The functions seem useful and appropriate for NX. I would advocate to move all functions to Distance measures.
comment
Please have a look at https://github.com/networkx/nx-parallel if you can contribute there :)
comment
Just a note:  I know networkx no longer supports Python 3.8 in the next version, but this change crashes on Python 3.8 See the discussion here: https://github.com/mu-editor/pup/issues/35
comment
Another, very recent method to project nodes on a line is using this Linear Clustering Algorithm (read Section 3): https://doi.org/10.1109/TNSE.2023.3271360 It is intended for finding clusters in the graph, but it also provides a projection of the graph to a one-dimensional line.
comment
@rat-h I didn't see any code attached to that paper, so perhaps you can contact the authors directly?
comment
thanks for your work on this! i'm looking to contribute and would like to pick this up.  if the dict is returned, what's the value in the key? it seems indeterminate because of the node shuffle. 
comment
I don't think the usage of the dict is confusing so much as the key is unnecessary to return because it's indeterminate due to line 76 `seed.shuffle(nodes)`, iinm:   ``` diff --git a/networkx/algorithms/community/label_propagation.py b/networkx/algorithms/community/label_propagation.py index 424b773d..fd3315d7 100644 --- a/networkx/algorithms/community/label_propagation.py +++ b/networkx/algorithms/community/label_propagation.py @@ -98,7 +98,7 @@ def asyn_lpa_communities(G, weight=None, seed=None):              cont = cont or len(best_labels) > 1       # TODO In Python 3.3 or later, this should be `yield from ...`. -    return iter(groups(labels).values()) +    return groups(labels)  >>> import networkx as nx >>> y = nx.social.davis_southern_women_graph() >>> list(nx.community.asyn_lpa_communities(y).keys()) [20] >>> list(nx.community.asyn_lpa_communities(y).keys()) [24] >>> list(nx.community.asyn_lpa_communities(y).keys()) [18] >>> list(nx.community.asyn_lpa_communities(y).keys()) [22] ```  I like your suggestion of returning a dict-value view.
comment
Is there an existing pull request for this functionality?
comment
Hi, I happened to see this post, and did some profiling. I might be the case that the implementation is correct, just inefficient. Not sure if this will help anyone, but here's the profiling result. ![tarjan](https://user-images.githubusercontent.com/32769797/35210630-20b70272-ffa7-11e7-9599-7b707706089e.PNG)  
comment
Hi, my name is Johanan Wahlang. I'm currently a 5th year student at the Indian Institute of Science Education and Research, Kolkata. Sorry for writing so late in the application process, can I still give my proposal now? I'm actually interested in implementing two and eight.  > Add community finding algorithms. A previous GSoC project made some progress on this #764. There have been other contributions since #951, #1092 (Louvain) and #1265 (Girvan-Newman), #617 (label propagation) >  > Add network metrics for weighted networks #730  @bjedwards can you please list out specifically which community detection algorithms you have implemented in your GSoC project? Also, what has been the cause of delay for merging them so far? 
comment
I won't be able to participate in GSoC this year, but I would still like to contribute. 
comment
Since not having ordered edges for a DiGraph is pretty much a deal-breaker for me, I hacked it in. I am leaving my quick hack here, it may be useful for someone:  ``` class OrderedEdgesDiGraph(DiGraph):     def add_node(self, n, attr_dict=None, **attr):         raise NotImplementedError      def add_nodes_from(self, nodes, **attr):         raise NotImplementedError      def add_edge(self, u, v, attr_dict=None, **attr):         if attr_dict is None:             attr_dict=attr         else:             try:                 attr_dict.update(attr)             except AttributeError:                 raise NetworkXError(                     "The attr_dict argument must be a dictionary.")         if u not in self.succ:             self.succ[u] = OrderedDict()             self.pred[u] = OrderedDict()             self.node[u] = {}         if v not in self.succ:             self.succ[v] = OrderedDict()             self.pred[v] = OrderedDict()             self.node[v] = {}         datadict = self.adj[u].get(v,{})         datadict.update(attr_dict)         self.succ[u][v] = datadict         self.pred[v][u] = datadict      def add_edges_from(self, ebunch, attr_dict=None, **attr):         raise NotImplementedError ```  This isn't pretty, but since the vanilla dictionary type is explicitly assigned in so many places I simply don't know of a better way. I left place-holders for `add_node`, `add_nodes_from` and `add_edges_from` to reduce the code footprint, these can of course trivially be added in the same way that I did for `add_edge`. Side-note, I am currently using NetworkX 1.7. 
comment
@dschult:  > So, you've got ordered adjlists, but not ordered edges.  Am I understanding correctly?  To get ordered edges you'd have to keep track across the dicts which was added first (perhaps with a list of edge-tuples).  Thank you for forcing me to think about my wording, what I am going for is not a global ordering of the edges but rather a local ordering for each vertex. In code:  ``` nodes = sample(xrange(256), 5) child = nodes.pop() parents = nodes print('Child:', child) print('Parents (ordered):', parents) print()  for graph_class in (DiGraph, OrderedEdgesDiGraph, ):     print(graph_class.__name__)     graph = graph_class()      for parent in parents:         graph.add_edge(child, parent)      print('Parents:', graph.neighbors(child))     print() ```  Output:  ``` Child: 143 Parents (ordered): [118, 45, 165, 247]  DiGraph Parents: [247, 45, 118, 165]  OrderedEdgesDiGraph Parents: [118, 45, 165, 247] ```  > What application uses ordered adjlists?  In my specific case that would be Recursive Neural Networks-esque models and linguistic Dependency Graphs. The latter you can handle by sorting based on for example the word order of the sentence, but for the former, in the general case, there is no global ordering of the edges but it is rather a local ordering for each vertex in relation to its parents/children. I currently have my own DiGraph implementation for this but I would like to rip it out considering how often I have found bugs in my graph code.  Also, thank you very very much for the fast feedback. 
comment
Dear Roguebee:  It seems that there might be a confusion between two different formats called "GML": 1. GML - http://en.wikipedia.org/wiki/Graph_Modelling_Language  (a format for graphs, supported by NX) 1. GML - http://en.wikipedia.org/wiki/Geography_Markup_Language    (an XML format for storing geographic data)  The process for converting between the two is not trivial. Generally speaking, you would need to 1. Load the GML format using the GDAL/OGR 2. Select the layer containing the points 3. Create an empty NX graph 4. Going through the features in the file, create nodes and edges, based on your criteria for defining the network.  Some useful snippets of code are here http://www.gdal.org/ogr/ogr_apitut.html  Feel free to follow up with more questions.  Hope it helps, -Sasha.  On 06/10/2013 03:32 PM, wschlauch wrote:  > roguebee, >  > I am not familiar with shapefiles. Still, I think you load it not > correctly. Don't you have to specify a file instead of a folder? > Meaning by this: just providing the foldername "Streetview" won't help > you a bit. >  > I can't help more right now since I don't even get that GDAL-stuff to > run on my linux. >  > — > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/879#issuecomment-19224344.  ##   Alexander "Sasha" Gutfraind, Ph.D. Research Assistant Professor University of Illinois - Chicago 
