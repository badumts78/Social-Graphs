issue
pass numpy seed by value not index#TITLE_END#This PR replaces `@np_random_state(10)` with `@np_random_state("seed")` in the `spring_layout` function to ensure correct handling of the seed argument. Using a positional index assumes that seed is always passed as the 11th positional argument, which is fragile and fails when seed is passed as a keyword (the common case).  By switching to the argument name "seed", we make the decorator robust to both positional and keyword usage, aligning with best practices and preventing subtle bugs in layout reproducibility.  We ran into an issue when parallelizing our tests with networks.
issue
Forceatlas2 networkx implementation#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Implementation of forceatlas2 layout based on https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0098679&type=printable  Example:   ```python import networkx as nx, matplotlib.pyplot as plt fig, ax = plt.subplots() g = nx.florentine_families_graph() pos =nx.forceatlas2_layout(g) nx.draw(g, pos = pos) # or #nx.draw_forceatlas2(g, ax = ax) plt.show(block = 1) ``` ![image](https://user-images.githubusercontent.com/19485143/158342482-14dbed70-e15d-4eb8-af21-70404cb6a5c1.png)    
issue
Forceatlas2 networkx clean#TITLE_END#Continuation of  #5392. The goal is to clean up the files so they are up to par with the qualities of networkx.
issue
Added arc_layout#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html -->  Added arc layout for clustered graphs, e.g.  ![image](https://github.com/networkx/networkx/assets/19485143/bc0f0dbd-d231-498a-ac68-621fd0681247) 
issue
3d plotting fix#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Fixed 3d plotting for networkx layouts This example works now without an issue: ```python  from matplotlib.collections import LineCollection as LC import networkx as nx, numpy as np from mpl_toolkits.mplot3d.art3d import Line3DCollection import matplotlib.pyplot as plt   G = nx.gnm_random_graph(n=10, m=15, seed=1) pos = nx.spring_layout(G, dim=3, seed=1)  kw = dict(projection = '3d') fig, ax = plt.subplots(subplot_kw = kw) nx.draw_networkx_nodes(G, pos = pos, ax = ax) nx.draw_networkx_edges(G, pos = pos, ax = ax)  fig.show() ```  The problem was in using the 2d versions and not correctly applying the `xy`-coordinates in the axis objects.
issue
[ENH] Adding typing support#TITLE_END#Hi, There is a general trend to add type hinting support to help guide the programmer and reader for adding new functionality. Type hinting was added in python 3.6, numpy added typing support in 1.20. Would it be an idea to add type support to networkx? It was thinking of adding a `typing` modules with something along the lines of   - `AbstractGraph` - `Graph` - `DiGraph` - `Edge` (directed or non-directed).
issue
Arf layout#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Implements arf layout (Geipel 2006) which provides improvements over the traditional spring layout. Short description      The attractive and repulsive forces (arf) layout (Geipel     2006) improves  the spring layout in  three ways. First,     it prevents congestion of  highly connected nodes due to     strong forcing  between nodes.  Second, it  utilizes the     layout space  more effectively by preventing  large gaps     that  spring layout  tends  to create.  Lastly, the  arf     layout represents symmmetries in  the layout better than     the default spring layout.  Example: <details> <summary>Plotting code </summary>  ``` python import networkx as nx, numpy as np, matplotlib.pyplot as plt from functools import partial graphs = [nx.krackhardt_kite_graph(),           nx.florentine_families_graph(),           nx.grid_graph((5,5)),           nx.erdos_renyi_graph(100, 0.02, seed = 0)           ] fig, ax = plt.subplots(ncols = 2, nrows = 2, share = 0)  layouts = [partial(nx.arf_layout, alpha = 10, b = 5, seed = 0),            partial(nx.spring_layout, seed = 0)] centers = [np.array([-1.5, 0]), np.array([1.5, 0])] for axi, g in zip(ax, graphs):     for layout, center in zip(layouts, centers):         pos = layout(g)         pos = nx.rescale_layout_dict(pos)         pos = {x: y + center for x, y in pos.items()}         nx.draw(g, pos = pos,                 ax = axi, node_size = 10)     axi.annotate("Spring", xy = [0.75, 1.02], xycoords = axi.transAxes,         va = "center", ha = "center")     axi.annotate("Arf", xy = [0.25, 1.02], xycoords = axi.transAxes,         va = "center", ha = "center")     axi.axis("equal") fig.show() ``` </details>  ![image](https://user-images.githubusercontent.com/19485143/182322237-8f7f73d7-dd38-42b3-be68-1a865c4dbc53.png) 
issue
Added forceatlas2 layout#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> # Added forceatlas 2 layout I've added the ForceAtlas2 layout from gephi that was implemented by [bhargavchippada](https://github.com/bhargavchippada) with linLog merge from [victorbenichoux](https://github.com/victorbenichoux). The ForceAtlas2 layout forms a fast alternative for spring layout and work particularly well for large graphs. It originates from gephi and is a good addition to the networkx toolkit.  Best wishes, C 
issue
Consistent return type in dictionary output of rescale_layout and rescale_layout_dict#TITLE_END### Summary Most layouts (if not all) return a dictionary of (key, value) pairs that are of type (<int | float | string| tuple>, <np.ndarray>), however the `rescale_dict_layout` function explicitly converts the value type to a `np.ndarray`. This PR fixes that problem.  ## Problem Removes conversion of value-type to tuple in `rescale_layout_dict` function.  ## Example  ```python g = nx.erdos_renyi_graph(100, .3) pos = nx.random_layout(g) dict_pos = nx.rescale_layout_dict(pos, 100) # produces (key, value) -> (<node label type>, <np.ndarray>)) for k, v in pos.items():     assert type(v) is type(dict_pos[k]) ```    
issue
Recursive tree generator#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Added a recursive tree generator with pytests in the `generator` submodule. An example is here:  ```python import networkx as nx, matplotlib.pyplot as plt  def get_shells(graph):     shells = {}     for k, v in dict(graph.degree()).items():         shells[v] = shells.get(v, []) + [k]     return dict(sorted(shells.items(), key = lambda x: x[0])[::-1])  def get_shell_layout(graph, **kwargs):     shells = get_shells(graph)     return nx.shell_layout(graph, nlist = list(shells.values()), **kwargs)  g = nx.recursive_tree(4) pos = get_shell_layout(g, rotate = -.2) fig, ax = plt.subplots() nx.draw(g, pos = pos, ax = ax) ax.axis('square') fig.show() ``` 
comment
It may have been lost in the refactor that I wrote. I moved from the cython implementation to numpy; the cython implementation uses dissuade hubs as this: https://github.com/bhargavchippada/forceatlas2/blob/da3ece0b559efcc1cee51bd0f1d56db4732ce50c/fa2/forceatlas2.py#L164C1-L166C69
comment
I think it probably I ended up forgetting to add this in and we missed it during review. We can add it back in using the median or mean.
comment
Gravity should pull towards the center of mass of the graph not the origin of the plot. Good spot. It's been a long time since I reviewed this code but the calculation needs to be made based on the center of mass.
comment
I guess something like  ```python  @np_random_state("seed") def forceatlas2_layout(     G,     pos=None,     *,     max_iter=100,     jitter_tolerance=1.0,     scaling_ratio=2.0,     gravity=1.0,     distributed_action=False,     strong_gravity=False,     node_mass=None,     node_size=None,     weight=None,     dissuade_hubs=False,     linlog=False,     seed=None,     dim=2, ):     import numpy as np      if len(G) == 0:         return {}      # Parse optional pos positions     if pos is None:         pos = nx.random_layout(G, dim=dim, seed=seed)         pos_arr = np.array(list(pos.values()))     else:         pos_init = np.array(list(pos.values()))         max_pos = pos_init.max(axis=0)         min_pos = pos_init.min(axis=0)         dim = max_pos.size         pos_arr = min_pos + seed.rand(len(G), dim) * (max_pos - min_pos)         for idx, node in enumerate(G):             if node in pos:                 pos_arr[idx] = pos[node].copy()      mass = np.zeros(len(G))     size = np.zeros(len(G))      adjust_sizes = False     if node_size is None:         node_size = {}     else:         adjust_sizes = True      if node_mass is None:         node_mass = {}      for idx, node in enumerate(G):         mass[idx] = node_mass.get(node, G.degree(node) + 1)         size[idx] = node_size.get(node, 1)      n = len(G)     gravities = np.zeros((n, dim))     attraction = np.zeros((n, dim))     repulsion = np.zeros((n, dim))     A = nx.to_numpy_array(G, weight=weight)      def estimate_factor(n, swing, traction, speed, speed_efficiency, jitter_tolerance):         import numpy as np         opt_jitter = 0.05 * np.sqrt(n)         min_jitter = np.sqrt(opt_jitter)         max_jitter = 10         min_speed_efficiency = 0.05          other = min(max_jitter, opt_jitter * traction / n**2)         jitter = jitter_tolerance * max(min_jitter, other)          if swing / traction > 2.0:             if speed_efficiency > min_speed_efficiency:                 speed_efficiency *= 0.5             jitter = max(jitter, jitter_tolerance)         if swing == 0:             target_speed = np.inf         else:             target_speed = jitter * speed_efficiency * traction / swing          if swing > jitter * traction:             if speed_efficiency > min_speed_efficiency:                 speed_efficiency *= 0.7         elif speed < 1000:             speed_efficiency *= 1.3          max_rise = 0.5         speed = speed + min(target_speed - speed, max_rise * speed)         return speed, speed_efficiency      # Compute the center of mass of the graph     center_of_mass = np.mean(pos_arr, axis=0)      speed = 1     speed_efficiency = 1     swing = 1     traction = 1     for _ in range(max_iter):         diff = pos_arr[:, None] - pos_arr[None]         distance = np.linalg.norm(diff, axis=-1)          if linlog:             attraction = -np.log(1 + distance) / distance             np.fill_diagonal(attraction, 0)             attraction = np.einsum("ij, ij -> ij", attraction, A)             attraction = np.einsum("ijk, ij -> ik", diff, attraction)         else:             attraction = -np.einsum("ijk, ij -> ik", diff, A)          if distributed_action:             attraction /= mass[:, None]          tmp = mass[:, None] @ mass[None]         if adjust_sizes:             distance += -size[:, None] - size[None]          d2 = distance**2         np.fill_diagonal(tmp, 0)         np.fill_diagonal(d2, 1)         factor = (tmp / d2) * scaling_ratio         repulsion = np.einsum("ijk, ij -> ik", diff, factor)          # Gravity towards the center of mass         gravities = (             -gravity             * mass[:, None]             * (pos_arr - center_of_mass)             / (np.linalg.norm(pos_arr - center_of_mass, axis=-1)[:, None])         )         gravities = np.nan_to_num(gravities, nan=0)  # Handle gravity at the center          if strong_gravity:             gravities *= np.linalg.norm(pos_arr - center_of_mass, axis=-1)[:, None]          update = attraction + repulsion + gravities          swing += (mass * np.linalg.norm(pos_arr - update, axis=-1)).sum()         traction += (0.5 * mass * np.linalg.norm(pos_arr + update, axis=-1)).sum()          speed, speed_efficiency = estimate_factor(             n,             swing,             traction,             speed,             speed_efficiency,             jitter_tolerance,         )          if adjust_sizes:             swinging = mass * np.linalg.norm(update, axis=-1)             factor = 0.1 * speed / (1 + np.sqrt(speed * swinging))             df = np.linalg.norm(update, axis=-1)             factor = np.minimum(factor * df, 10.0 * np.ones(df.shape)) / df         else:             swinging = mass * np.linalg.norm(update, axis=-1)             factor = speed / (1 + np.sqrt(speed * swinging))          pos_arr += update * factor[:, None]         if abs((update * factor[:, None]).sum()) < 1e-10:             break      return dict(zip(G, pos_arr)) ```
comment
You are right @dschult the center of mass should be in the loop (!). The other suggestion looks good to me. Thanks for being vigilant ;-). 
