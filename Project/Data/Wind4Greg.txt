comment
A while ago, for teaching and R&D purposes, I implemented a version of Yen's K-shortest path algorithm in Python/NetworkX.  The code has been posted with the rest of the code for a (data/optical) network course at http://grotto-networking.com/netDesignCourse.html#Code with Sphinx generated documentation at http://grotto-networking.com/files/NetDesignCourse/code_doc/Utilities.html#module-Utilities.YenKShortestPaths.  I recently heard from a biophysics PhD student that has used this code on networks with several thousand nodes and links to find hundreds of shortest paths.   If there is sufficient interest I can try to modify these to meet NetworkX coding/style/API standards, but would need a bit of guidance from the NetworkX developers.  Cheers Greg B. 
comment
Good idea Andrey, definitely a more Python way to handle the situation.  I'll do an update and post the code with some examples to my website this week. Cheers Greg B. 
comment
I converted the interface to the K shortest path algorithm (Yen's) to use the iterator pattern, cleaned up all PEP 8 errors (except camel case), Created two different test examples on three different networks and zipped it all to http://www.grotto-networking.com/files/KShortestPaths.zip.  Cheers Greg B. 
comment
Hi all, will try to get up to speed on the issues raised by @jtorrents.  Some of those concepts could be useful for some stuff I'm trying to point some of my students at, e.g., k-widest paths.  I make no claims for the speed of my code ;-).  I needed something in Java way back in 2007 or so. Then in 2011 or so needed something in Python.  Didn't have time to get the Epstein algorithm working (couldn't get their C code to compile even), nor time to get the algorithm referenced below to work.  [1]J. Hershberger, M. Maxel, and S. Suri, “Finding the k shortest simple paths: A new algorithm and its implementation,” ACM Trans. Algorithms, vol. 3, no. 4, p. 45, 2007.  Couldn't we (NetworkX) decide on the API for a K-shortest paths algorithm then use Andrey's or my implementation and possibly swap it out in the future if a more efficient implementation gets implemented?  There is a moderately strong need for this functionality in networkX, as I discovered when a PhD candidate in biophysics managed to find my code "hiding" within my website in a network design course zip file.  However his networks were much bigger and he mentioned 30 minute run times with my code (which sounds kind of long to me).  Cheers Greg 
comment
Hi all, will try to get up to speed on the issues raised by @jtorrents.  Some of those concepts could be useful for some stuff I'm trying to point some of my students at, e.g., k-widest paths.  I make no claims for the speed of my code ;-).  I needed something in Java way back in 2007 or so. Then in 2011 or so needed something in Python.  Didn't have time to get the Epstein algorithm working (couldn't get their C code to compile even), nor time to get the algorithm referenced below to work.  [1]J. Hershberger, M. Maxel, and S. Suri, “Finding the k shortest simple paths: A new algorithm and its implementation,” ACM Trans. Algorithms, vol. 3, no. 4, p. 45, 2007.  Couldn't we (NetworkX) decide on the API for a K-shortest paths algorithm then use Andrey's or my implementation and possibly swap it out in the future if a more efficient implementation gets implemented?  There is a moderately strong need for this functionality in networkX, as I discovered when a PhD candidate in biophysics managed to find my code "hiding" within my website in a network design course zip file.  However his networks were much bigger and he mentioned 30 minute run times with my code (which sounds kind of long to me).  Cheers Greg 
comment
This sounds very good.  Andrey performance numbers are impressive! Cheers Greg B. 
comment
I took a quick peek at the code in @jtorrents fork it looks good.  I saw comments about more tests and examples.  In the Zip that I previously posted there were two different JSON example networks (in addition to the very simple code constructed network). One with 17 nodes & 27 edges, and one with 54 nodes & 102 edges along with a script to read these and compute some of the k-shortest paths (would need to change the call to use the new alg rather than mine). There are also SVGs of the networks that could be used in documentation. 
