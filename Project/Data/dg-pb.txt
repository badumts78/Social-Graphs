issue
Implement Bar ConnectionStyle for labels#TITLE_END#Closes: https://github.com/networkx/networkx/issues/7735  With this addition, all existing connection styles are supported for both fancy arrows and labels.
issue
Draw MultiDiGraph edges and labels qa7008#TITLE_END#[Following on my Q&A](https://github.com/networkx/networkx/discussions/7008)  All tests running. Fairly minimal changes. See discussion for my concerns regarding `rad` argument sourcing.  Everything is working as expected, except self-loop labels are not positioned properly.  Minimal Example: ```python import networkx as nx import matplotlib.pyplot as plt from netgraph import MultiGraph  G = nx.MultiDiGraph() for i, (u, v) in enumerate([('a', 'b'), ('a', 'b'), ('a', 'b'), ('b', 'a'),                             ('b', 'c'), ('b', 'c'), ('c', 'a'), ('c', 'c')]):     G.add_edge(u, v, weight=round(i / 3, 2))   pos = nx.spring_layout(G, seed=7) nx.draw_networkx_nodes(G, pos) nx.draw_networkx_labels(G, pos, font_size=20) nx.draw_networkx_edges(G, pos, connectionstyle=[     'arc3,rad=0.1', 'arc3,rad=0.2', 'arc3,rad=0.3' ])  nx.draw_networkx_edge_labels(G, pos, rad=[0.1, 0.2, 0.3]) plt.show() ```  ![](https://gcdnb.pbrd.co/images/ITaavGlFTqjY.png?o=1)  Negative radians also work, and makes a nicer graph in this case.  ```python rad = [-0.1, -0.25, -0.35] nx.draw_networkx_edges(G, pos, connectionstyle=[f'arc3,rad={r}' for r in rad]) nx.draw_networkx_edge_labels(G, pos, rad=rad) ```  ![](https://gcdnb.pbrd.co/images/m4oB613uvfA9.png?o=1) 
comment
If you could provide a step-by-step guide how to reproduce this random-hit behaviour, then I can have a look.  I tried adding `assert` in `draw` and running `pytest networkx/drawing/tests/test_pylab.py::test_draw_bipartite`  But from your description, it seems that this only happens when running test in batches?
comment
I can not reproduce.  I run Python 3.13.4 on OSX.  So can not help much.  ---  Failing tests are not using `CurvedArrowText`, so this is strange.  Could be related to `matplotlib` backend not clearing canvas after previous use in another test.  Not sure where the randomness is from though. Tests always seem to be run in the same order... Don't think randomness in `networkx` graph creation functions can cause this.  Try adding `plt.figure()` at the beginning of `nx_pylab.py:def draw()` to ensure new figure is created every time.  This is my best speculation.  Also, try limiting the scope. E.g. try removing tests and see what is the minimal amount of accompanying tests that still results in failures.  Fast check could be - remove everything except failing ones and those that call `draw_networkx_edge_labels`.
comment
> I'm not sure the `AssertionError` for invalid `pos` is sufficiently clear.  I added it as a precaution thinking that some higher level assertion already exists. But it doesn't. And maybe it shouldn't as values below 0 and above 1 are most likely valid. They should just extrapolate beyond bounds.  Try removing the assertion altogether and try values -0.1, 1.1 and see if all works as expected.
comment
> I meant the check on the length of `points`  That is adaptation to `matplotlib`. Given its current state it is exact and IMO unlikely to change.  You can check those classes in `import matplotlib.patches` - it can be seen very clearly what numbers of vertices are possible for each and what sort of bezier curve it is constructing.  By the way, maybe renaming `points` to `vertices` would be a good idea - just to keep variable names consistent.    > Perhaps a warning makes sense if we're relying on extrapolation?  If extrapolation works, then I don't think a warning is needed. If this is allowed and considered a feature then it would be very annoying to get warnings if one decides to make use of it.  So I say either restrict it at higher level or leave it as it is without errors or warnings if it works well.
comment
Yes, it wasn't correctly picking it up. 3 edits above fix it if that is preferred.
comment
> I apologize for the additional burden I'm placing on you.  Doesn't feel like it at all. Happy to be of help. And thank you for doing this!
comment
It would be great to avoid keeping 2 copies of such a thing.  We could place it outside those functions as a base, then Inherit within functions: ```python class CurvedArrowTextBase:     # All code here     ...  def foo():     class CurvedArrowText(CurvedArrowTextBase, mpl.text.Text)         pass  def bar():     class CurvedArrowText(CurvedArrowTextBase, mpl.text.Text)         pass ```
comment
> I think the duplication is only temporary, so imo it makes more sense to keep it for now and just get rid of the old copy for the `draw_*` functions whenever they get replaced by wrappers around equivalent `display_*` functions.  The reason why the class is not in the main module in the first place is because it inherits from `matplotlib` class. My best guess is that for this exact reason it was duplicated.  But this can be solved by the above. Can be left for another PR ofc, but I think this is a perfect opportunity to do it.
comment
> I'm not 100% sure we're covering all the cases  I think I have covered all of them.  Angle has 2 possibilities: 1. [MOVETO, LINETO, LINETO] 2. [MOVETO, LINETO, CURVE3, CURVE3, LINETO]  Arc has 3: 1. [MOVETO, LINETO] 2. [MOVETO, LINETO, CURVE3, CURVE3, LINETO] (this one has 2 variations, but the treatment of them both is the same) 3. [MOVETO, LINETO, CURVE3, CURVE3, LINETO, CURVE3, CURVE3, LINETO]  We are interested in `[ANY, LINETO]`, which I think I extract for each case correctly. These are lines, the rest is edge rounding, which I do not take into account (that would just be extra 100% of complexity for 1% benefit).  Then, all that is left is to identify in which line the requested position resides.  ---  I think this is good to go and with this, ~99% of connection styles are covered (except label adaptation to minuscule curvature of rounded edges).  ---  I would just like to reiterate myself that I think it would be of benefit to factor out `CurvedArrowText` class as I suggested in https://github.com/networkx/networkx/pull/8108#issuecomment-2968295897 to avoid unnecessary repetition of pretty hefty code. If not in this PR, then at least promptly after.
comment
> Ultimately it'd be great to see if some of this code wouldn't be a nice candidate for upstreaming to `matplotlib`.  If that is needed and someone is willing, then I think this contains big part of components and logic for some generic solution: 1. Segment any path to its constituent components. Currently this is done only for LINETO segments. Would need to incorporate CURVE3 and CURVE4, but that is easy. 2. Calculate lengths of all of those. Currently this is done only for LINETO. CURVE3 and CURVE4 are missing. 3. Identify which segment desired point lies in. Logic is there. 4. Calculate the position and angle on the segment of interest. Logic is there for CURVE3 and LINETO. CURVE4 is missing.  --- ---  Thanks everyone! Was a pleasure. (As always is in this repo.)
comment
> I also still think that there is value in avoiding the duplicated code with the old and new visualization APIs.  There is a discrepancy between 2 classes in `_get_arrow_path_disp` method...  I would say it would be good to do this as part of this PR, it is a very simple change and is directly related to what was done here.  Just put this above `draw_networkx_edge_labels`:  <details> <summary>CurvedArrowTextBase</summary>  ```python class CurvedArrowTextBase:     def __init__(         self,         arrow,         *args,         label_pos=0.5,         labels_horizontal=False,         ax=None,         **kwargs,     ):         # Bind to FancyArrowPatch         self.arrow = arrow         # how far along the text should be on the curve,         # 0 is at start, 1 is at end etc.         self.label_pos = label_pos         self.labels_horizontal = labels_horizontal         if ax is None:             ax = plt.gca()         self.ax = ax         self.x, self.y, self.angle = self._update_text_pos_angle(arrow)          # Create text object         super().__init__(self.x, self.y, *args, rotation=self.angle, **kwargs)         # Bind to axis         self.ax.add_artist(self)      def _get_arrow_path_disp(self, arrow):         """         This is part of FancyArrowPatch._get_path_in_displaycoord         It omits the second part of the method where path is converted             to polygon based on width         The transform is taken from ax, not the object, as the object             has not been added yet, and doesn't have transform         """         dpi_cor = arrow._dpi_cor         trans_data = self.ax.transData         if arrow._posA_posB is None:             raise ValueError(                 "Can only draw labels for fancy arrows with "                 "posA and posB inputs, not custom path"             )         posA = arrow._convert_xy_units(arrow._posA_posB[0])         posB = arrow._convert_xy_units(arrow._posA_posB[1])         (posA, posB) = trans_data.transform((posA, posB))         _path = arrow.get_connectionstyle()(             posA,             posB,             patchA=arrow.patchA,             patchB=arrow.patchB,             shrinkA=arrow.shrinkA * dpi_cor,             shrinkB=arrow.shrinkB * dpi_cor,         )         # Return is in display coordinates         return _path      def _update_text_pos_angle(self, arrow):         # Fractional label position         # Text position at a proportion t along the line in display coords         # default is 0.5 so text appears at the halfway point         import matplotlib as mpl         import matplotlib.path         import numpy as np         t = self.label_pos         tt = 1 - t         path_disp = self._get_arrow_path_disp(arrow)         conn = arrow.get_connectionstyle()         # 1. Calculate x and y         points = path_disp.vertices         if is_curve := isinstance(             conn,             mpl.patches.ConnectionStyle.Angle3 | mpl.patches.ConnectionStyle.Arc3,         ):             # Arc3 or Angle3 type Connection Styles - Bezier curve             (x1, y1), (cx, cy), (x2, y2) = points             x = tt**2 * x1 + 2 * t * tt * cx + t**2 * x2             y = tt**2 * y1 + 2 * t * tt * cy + t**2 * y2         else:             if not isinstance(                 conn,                 mpl.patches.ConnectionStyle.Angle                 | mpl.patches.ConnectionStyle.Arc                 | mpl.patches.ConnectionStyle.Bar,             ):                 msg = f"invalid connection style: {type(conn)}"                 raise TypeError(msg)             # A. Collect lines             codes = path_disp.codes             lines = [                 points[i - 1 : i + 1]                 for i in range(1, len(points))                 if codes[i] == mpl.path.Path.LINETO             ]             # B. If more than one line, find the right one and position in it             if (nlines := len(lines)) != 1:                 dists = [math.dist(*line) for line in lines]                 dist_tot = sum(dists)                 cdist = 0                 last_cut = 0                 i_last = nlines - 1                 for i, dist in enumerate(dists):                     cdist += dist                     cut = cdist / dist_tot                     if i == i_last or t < cut:                         t = (t - last_cut) / (dist / dist_tot)                         tt = 1 - t                         lines = [lines[i]]                         break                     last_cut = cut             [[(cx1, cy1), (cx2, cy2)]] = lines             x = cx1 * tt + cx2 * t             y = cy1 * tt + cy2 * t          # 2. Calculate Angle         if self.labels_horizontal:             # Horizontal text labels             angle = 0         else:             # Labels parallel to curve             if is_curve:                 change_x = 2 * tt * (cx - x1) + 2 * t * (x2 - cx)                 change_y = 2 * tt * (cy - y1) + 2 * t * (y2 - cy)             else:                 change_x = (cx2 - cx1) / 2                 change_y = (cy2 - cy1) / 2             angle = np.arctan2(change_y, change_x) / (2 * np.pi) * 360             # Text is "right way up"             if angle > 90:                 angle -= 180             elif angle < -90:                 angle += 180         (x, y) = self.ax.transData.inverted().transform((x, y))         return x, y, angle      def draw(self, renderer):         # recalculate the text position and angle         self.x, self.y, self.angle = self._update_text_pos_angle(self.arrow)         self.set_position((self.x, self.y))         self.set_rotation(self.angle)         # redraw text         super().draw(renderer)  ``` </details>  Where all that I have done is added internal imports for `_update_text_pos_angle` method, removed inheritance and appended `Base` to the name.  And add the following in place of both classes: ```python class CurvedArrowText(CurvedArrowTextBase, mpl.text.Text):         pass ```  This is pretty much it. Tested it and all seems to be ok.
comment
![Image](https://github.com/user-attachments/assets/25a49c1c-277d-4a3e-9729-be6fce8f91cd)  Sorry, still few bugs to fix.
comment
Yeah, it works for piecewise variations as well:  ![Image](https://github.com/user-attachments/assets/1c0ea9dc-cf82-4399-8df5-2eedc0c3a67d)   I don't have `networkx` on my computer. Any chance someone else can add this?  Straight forward replace (just add `math` import): ```python         def _update_text_pos_angle(self, arrow):             # Fractional label position             # Text position at a proportion t along the line in display coords             # default is 0.5 so text appears at the halfway point             t = self.label_pos             tt = 1 - t             path_disp = self._get_arrow_path_disp(arrow)             conn = arrow.get_connectionstyle()             is_line = True             # 1. Calculate x and y             points = path_disp.vertices             if isinstance(conn, (mpl.patches.ConnectionStyle.Arc3,                                  mpl.patches.ConnectionStyle.Angle3)):                 # Arc3 or Angle3 type Connection Styles - Bezier curve                 (x1, y1), (cx, cy), (x2, y2) = points                 x = tt**2 * x1 + 2 * t * tt * cx + t**2 * x2                 y = tt**2 * y1 + 2 * t * tt * cy + t**2 * y2                 is_line = False             else:                 if isinstance(conn, mpl.patches.ConnectionStyle.Bar):                     # Bar Connection Style - straight line                     assert len(points) == 4                     lines = [points[1:3]]                 else:                     if isinstance(conn, mpl.patches.ConnectionStyle.Angle):                         assert len(points) in {3, 5}                         lines = [points[:2], points[-2:]]                     else:                         assert isinstance(conn, mpl.patches.ConnectionStyle.Arc)                         if len(points) == 2:                             lines = [points]                         elif len(points) == 5:                             lines = [points[:2], points[-2:]]                         else:                             assert len(points) == 8                             lines = [points[:2], points[3:5], points[-2:]]                      if len(lines) != 1:                         assert len(lines) in {2, 3}                         dists = [math.dist(*line) for line in lines]                         dist_tot = sum(dists)                         cdist = 0                         last_cut = 0                         for i, dist in enumerate(dists):                             cdist += dist                             cut = cdist / dist_tot                             if t <= cut:                                 t = (t - last_cut) / (dist / dist_tot)                                 tt = 1 - t                                 lines = [lines[i]]                                 break                             last_cut = cut                         else:                             raise ValueError(f'not 0 <= label_pos={t} <= 1')                 [[(cx1, cy1), (cx2, cy2)]] = lines                 x = cx1 * tt + cx2 * t                 y = cy1 * tt + cy2 * t              # 2. Calculate Angle             if self.labels_horizontal:                 # Horizontal text labels                 angle = 0             else:                 # Labels parallel to curve                 if is_line:                     change_x = (cx2 - cx1) / 2                     change_y = (cy2 - cy1) / 2                 else:                     change_x = 2 * tt * (cx - x1) + 2 * t * (x2 - cx)                     change_y = 2 * tt * (cy - y1) + 2 * t * (y2 - cy)                 angle = np.arctan2(change_y, change_x) / (2 * np.pi) * 360                 # Text is "right way up"                 if angle > 90:                     angle -= 180                 elif angle < -90:                     angle += 180             (x, y) = self.ax.transData.inverted().transform((x, y))             return x, y, angle ```
comment
> I can take a look at adding it, if nobody else is doing so already.  Note, I fixed ` if t <= cut:`
comment
will look into it.
comment
Ah, at the time I have only made sure it works for `arc` and `angle` connection styles.  However, I think it is simple and useful style to have: ![Figure_1](https://github.com/user-attachments/assets/f4611956-5779-4bcd-ae5c-83f142a4aa79)  Simple and small change as it is always a straight line.
comment
> Yep, looks great, thanks!  Thanks for this.  I am not sure why i have decided that `bar` is not going to be useful at a time, but currently, to me, it seems to be the "cleanest" option which I, personally, would prefer whenever possible.
comment
See https://github.com/networkx/networkx/pull/7010  I tried to keep it minimal. Your approach seems more comprehensive. If you continue to work on this, maybe some of the notes will be helpful.
comment
Just a note.  Deprecation warning could be improved with "will return an iterator of pairs". Had to browse issues for a while to make sure I know what sort of iterator it is referring to.
