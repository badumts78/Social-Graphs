issue
Quotient graphs - option to label block nodes via a mapping on creation#TITLE_END#There doesn't seem to be an option to set the labels of the block nodes of a quotient graph via a mapping passed in to the creation method [`networkx.quotient_graph`](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.minors.quotient_graph.html#networkx.algorithms.minors.quotient_graph). There is a `relabel` boolean that labels the block nodes as non-negative integers, but there is no way of controlling this if the block nodes have to be labelled according to some mapping.  This is an example to illustrate the problem. I have a (directed) strongly connected graph `G` with 21 nodes      [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]  There is an equivalence relation `nrel` on these nodes which produces the following six blocks      [0, 2, 4, 6, 8]      #B1     [16, 10, 12, 14]     #B2     [24, 18, 20, 22]     #B3     [32, 26, 28, 30]     #B4     [34, 36]             #B5     [40, 38]             #B6  and an edge relation `brel` on the blocks given by      >>> brel = lambda B, C: any(e in G.edges for e in product(B, C))  (A simple extension of the edge relation of `G` to the blocks of `Q` - there is an edge from block `B` to `C` if there is an edge in `G` from a node in `B` to a node in `C`).  I create the quotient `Q` using      >>> Q = nx.quotient_graph(G, nrel, edge_relation=brel)  The nodes of `Q` are now these `frozenset` objects      >>> Q.nodes     >>> NodeView((frozenset({34, 36}), frozenset({16, 10, 12, 14}), frozenset({32, 26, 28, 30}), frozenset({40, 38}), frozenset({0, 2, 4, 6, 8}), frozenset({24, 18, 20, 22})))  But I would like to pass a mapping to `nx.quotient_graph` which sets the labels of the block nodes according to this mapping      >>> block_relabelling = {frozenset({0, 2, 4, 6, 8}): 2, frozenset({10, 12, 14, 16}): 3, frozenset({18, 20, 22, 24}): 4, frozenset({[26, 28, 30, 32]}): 5, frozenset({34, 36}): 6, frozenset({38, 40}): 7}     >>> nx.relabel_nodes(Q, block_relabelling, copy=False)     >>> sorted(Q.nodes)     >>> [2, 3, 4, 5, 6, 7]  It would be convenient if this could be done via an optional argument during the creation of the quotient graph, i.e. if [`networkx.quotient_graph`](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.minors.quotient_graph.html#networkx.algorithms.minors.quotient_graph) had an optional argument `block_relabel` (or something like that) which accepted a mapping from blocks to labels and applied the mapping to the blocks on creation of the quotient graph. 
issue
Partitions for quotient graphs#TITLE_END#Various updates in `algorithms/minors.py`:  * make `equivalence_classes` a public method * tweak `quotient_graph` to accept partitions as dicts (of block labels as keys and block lists/tuples/sets as values) * update `quotient_graph` docstring to provide examples to the user of how to use `equivalence_classes` to represent different representations of partitions in a form acceptable to `quotient_graph` (see discussion in https://github.com/networkx/networkx/pull/3839#issuecomment-675217619)
issue
User-defined labelling of block nodes when creating quotient graphs#TITLE_END#* Tweak quotient graph method (`networkx.algorithms.minors.quotient_graph` - allow user-defined mapping of blocks (`frozenset` objects) to labels via dicts and functions via an optional argument with default of `None`; no labels dict or function will cause blocks to be labelled/represented by themselves as `frozenset` objects * update all tests for quotient graphs involving block relabelling (`networkx.algorithms.tests.test_minors`).
issue
Subgraphs#TITLE_END#Unless I'm mistaken, the documentation on getting a subgraph from a subset of the nodes of a directed graph (digraph) `G` doesn't seem to work. I'm referring to this page here  https://networkx.github.io/documentation/stable/reference/classes/generated/networkx.DiGraph.subgraph.html?highlight=subgraph#networkx.DiGraph.subgraph  	In [127]: g = nx.path_graph(4)                                                                                                      	In [128]: g                                                                                                                        	Out[128]: <networkx.classes.graph.Graph at 0x123e2e250>  	In [129]: g.nodes                                                                                                                  	Out[129]: NodeView((0, 1, 2, 3))  	In [130]: g.edges                                                                                                                  	Out[130]: EdgeView([(0, 1), (1, 2), (2, 3)])  	In [131]: H = G.subgraph([0, 1, 2])                                                                                                	--------------------------------------------------------------------------- 	TypeError                                 Traceback (most recent call last) 	<ipython-input-131-6d7126a95783> in <module> 	----> 1 H = G.subgraph([0, 1, 2])  	~/Documents/dev/devenv/lib/python3.7/site-packages/networkx/classes/graph.py in subgraph(self, nodes) 	   1688         if hasattr(self, '_NODE_OK'): 	   1689             return subgraph(self._graph, induced_nodes, self._EDGE_OK) 	-> 1690         return subgraph(self, induced_nodes) 	   1691  	   1692     def edge_subgraph(self, edges):  	~/Documents/dev/devenv/lib/python3.7/site-packages/networkx/classes/graphviews.py in subgraph_view(G, filter_node, filter_edge) 	    156     EdgeView([(0, 1), (1, 2), (2, 3)]) 	    157     """ 	--> 158     newG = nx.freeze(G.__class__()) 	    159     newG._NODE_OK = filter_node 	    160     newG._EDGE_OK = filter_edge  	TypeError: __init__() missing 1 required positional argument: 'x'
comment
In an undirected graph, which is what `t` is here, edges don't have a direction or orientation, so it doesn't really matter how they are represented - the edge `(1, 2)` is the same as `(2, 1)`.  BTW using the `.edges` attribute is the simplest way of looking at graph edges      >>> t.edges     EdgeView([(1, 2), (1, 3)])
