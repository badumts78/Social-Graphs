issue
optimize _single_shortest_path function#TITLE_END#Applied here the same optimizations in  #6299 (the ones already not included) for the function `_single_shortest_path`.  <details> <summary> Code for benchmarking the new algorithm vs the current one on some example graphs </summary>  ```python import timeit, prettytable  def join(p1, p2):     return p1 + p2  def _single_shortest_path(adj, firstlevel, paths, cutoff, join):     """Returns shortest paths     Shortest Path helper function     Parameters     ----------         adj : dict             Adjacency dict or view         firstlevel : dict             starting nodes, e.g. {source: 1} or {target: 1}         paths : dict             paths for starting nodes, e.g. {source: [source]}         cutoff : int or float             level at which we stop the process         join : function             function to construct a path from two partial paths. Requires two             list inputs `p1` and `p2`, and returns a list. Usually returns             `p1 + p2` (forward from source) or `p2 + p1` (backward from target)     """     level = 0  # the current level     nextlevel = firstlevel     while nextlevel and cutoff > level:         thislevel = nextlevel         nextlevel = {}         for v in thislevel:             for w in adj[v]:                 if w not in paths:                     paths[w] = join(paths[v], [w])                     nextlevel[w] = 1         level += 1     return paths  def _single_shortest_path_2(adj, firstlevel, paths, cutoff, join):     """Returns shortest paths     Shortest Path helper function     Parameters     ----------         adj : dict             Adjacency dict or view         firstlevel : dict             starting nodes, e.g. {source: 1} or {target: 1}         paths : dict             paths for starting nodes, e.g. {source: [source]}         cutoff : int or float             level at which we stop the process         join : function             function to construct a path from two partial paths. Requires two             list inputs `p1` and `p2`, and returns a list. Usually returns             `p1 + p2` (forward from source) or `p2 + p1` (backward from target)     """     level = 0     nextlevel = list(firstlevel)     n = len(adj)     while nextlevel and cutoff > level:         thislevel = nextlevel         nextlevel = []         for v in thislevel:             for w in adj[v]:                 if w not in paths:                     paths[w] = join(paths[v], [w])                     nextlevel.append(w)             if len(paths) == n:                 return paths         level += 1     return paths  graphs = [  "nx.gaussian_random_partition_graph(100, 10, 5, 0.5, 0.05, seed=4241)",             "nx.gaussian_random_partition_graph(100, 10, 5, 0.8, 0.3, seed=4241)",             "nx.random_regular_graph(d=2, n=1000, seed=4241)", "nx.random_regular_graph(d=5, n=1000, seed=4241)",             "nx.random_regular_graph(d=10, n=1000, seed=4241)", "nx.random_regular_graph(d=50, n=1000, seed=4241)",             "nx.random_regular_graph(d=100, n=1000, seed=4241)", "nx.random_regular_graph(d=200, n=1000, seed=4241)",             "nx.random_regular_graph(d=500, n=1000, seed=4241)", "nx.random_regular_graph(d=700, n=1000, seed=4241)",             "nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)", "nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)",             "nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241)", "nx.connected_caveman_graph(100,10)",               "nx.caveman_graph(100,10)",  "nx.windmill_graph(10, 10)", "nx.full_rary_tree(3, 1000)",               "nx.complete_graph(100)", "nx.complete_graph(10)",  "nx.cycle_graph(100)", "nx.cycle_graph(10)",             "nx.binomial_tree(10)", "nx.path_graph(10)" ]  stmt_1 = "q = random.randrange(len(G)-1); list(_single_shortest_path(G.adj, {q: 1}, {q:[q]}, float('inf'), join))" stmt_2 = "q = random.randrange(len(G)-1); list(_single_shortest_path_2(G._adj, {q: 1}, {q:[q]}, float('inf'), operator.add))" table = prettytable.PrettyTable() table.field_names = ["graph", "time: current main", "time: this pr", "times faster"]  for graph in graphs:     setup_1 = "import networkx as nx; import collections, random; from __main__ import _single_shortest_path, join; random.seed(4241); G = {}".format(graph)     setup_2 = "import networkx as nx; import collections, random, operator; from __main__ import _single_shortest_path_2; random.seed(4241); G = {}".format(graph)     main_time = timeit.timeit(stmt_1, setup_1, number=200)     pr_time = timeit.timeit(stmt_2, setup_2, number=200)     a, b, c, d = graph, round(main_time,2), round(pr_time,2), round(main_time/pr_time, 2)     table.add_row([a, b, c, d])     print(d)  print(table) ``` </details>  which produces in 3.11:  ``` +----------------------------------------------------------------------+--------------------+---------------+--------------+ |                                graph                                 | time: current main | time: this pr | times faster | +----------------------------------------------------------------------+--------------------+---------------+--------------+ | nx.gaussian_random_partition_graph(100, 10, 5, 0.5, 0.05, seed=4241) |        0.02        |      0.01     |     2.12     | | nx.gaussian_random_partition_graph(100, 10, 5, 0.8, 0.3, seed=4241)  |        0.05        |      0.01     |     5.09     | |           nx.random_regular_graph(d=2, n=1000, seed=4241)            |        0.49        |      0.4      |     1.23     | |           nx.random_regular_graph(d=5, n=1000, seed=4241)            |        0.21        |      0.12     |     1.73     | |           nx.random_regular_graph(d=10, n=1000, seed=4241)           |        0.25        |      0.13     |     1.97     | |           nx.random_regular_graph(d=50, n=1000, seed=4241)           |        0.59        |      0.13     |     4.73     | |          nx.random_regular_graph(d=100, n=1000, seed=4241)           |        0.99        |      0.12     |     8.59     | |          nx.random_regular_graph(d=200, n=1000, seed=4241)           |        1.82        |      0.11     |    16.99     | |          nx.random_regular_graph(d=500, n=1000, seed=4241)           |        3.16        |      0.07     |    45.24     | |          nx.random_regular_graph(d=700, n=1000, seed=4241)           |        4.33        |      0.06     |    67.32     | |            nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)             |        0.07        |      0.0      |    14.12     | |            nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)            |        4.87        |      0.06     |    81.57     | |        nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241)        |        0.02        |      0.01     |     2.35     | |                  nx.connected_caveman_graph(100,10)                  |        0.19        |      0.14     |     1.37     | |                       nx.caveman_graph(100,10)                       |        0.0         |      0.0      |     1.36     | |                      nx.windmill_graph(10, 10)                       |        0.01        |      0.0      |     3.52     | |                      nx.full_rary_tree(3, 1000)                      |        0.12        |      0.06     |     2.12     | |                        nx.complete_graph(100)                        |        0.07        |      0.0      |    19.01     | |                        nx.complete_graph(10)                         |        0.0         |      0.0      |     3.0      | |                         nx.cycle_graph(100)                          |        0.01        |      0.01     |     1.81     | |                          nx.cycle_graph(10)                          |        0.0         |      0.0      |     1.79     | |                         nx.binomial_tree(10)                         |        0.13        |      0.08     |     1.69     | |                          nx.path_graph(10)                           |        0.0         |      0.0      |     1.68     | +----------------------------------------------------------------------+--------------------+---------------+--------------+ ```  As you can see the second optimization in some cases brings to a big improvement in performance.
issue
avoid some looping in is_connected function#TITLE_END#the loop wasn't necessary to find the length of the component in `connected.py` while the implementation here was better for the same function in  `weakly_connected.py`. I'm asking myself if aligning the outputs of `_plain_bfs` in the two files (both generators or both concrete sets) would be better. What do you think about this?
issue
simplify stack in dfs#TITLE_END#The stack in dfs can have only parent and children, the depth can be controlled from the outside of it, making the function slightly better in terms of time and space, but also readibility in my opinion :-)
issue
optimize generic_bfs_edges function#TITLE_END#Another bfs which could be updated. Here it is the table of comparison of performance between the current implementation vs. the new one:  ``` +--------------------------------------------------------+--------------------+---------------+--------------+ |                         graph                          | time: current main | time: this pr | times faster | +--------------------------------------------------------+--------------------+---------------+--------------+ |     nx.random_regular_graph(d=1, n=10, seed=4241)      |        0.0         |      0.0      |     1.56     | |     nx.random_regular_graph(d=9, n=10, seed=4241)      |        0.0         |      0.0      |     3.77     | |    nx.random_regular_graph(d=10, n=100, seed=4241)     |        0.01        |      0.0      |     3.86     | |    nx.random_regular_graph(d=99, n=100, seed=4241)     |        0.06        |      0.0      |    27.23     | |    nx.random_regular_graph(d=1, n=1000, seed=4241)     |        0.0         |      0.0      |     1.55     | |    nx.random_regular_graph(d=3, n=1000, seed=4241)     |        0.08        |      0.04     |     1.89     | |    nx.random_regular_graph(d=10, n=1000, seed=4241)    |        0.12        |      0.04     |     2.88     | |    nx.random_regular_graph(d=50, n=1000, seed=4241)    |        0.35        |      0.04     |     8.34     | |   nx.random_regular_graph(d=100, n=1000, seed=4241)    |        0.65        |      0.04     |    16.09     | |   nx.random_regular_graph(d=200, n=1000, seed=4241)    |        1.22        |      0.04     |    30.69     | |   nx.random_regular_graph(d=500, n=1000, seed=4241)    |        2.97        |      0.04     |    80.08     | |   nx.random_regular_graph(d=700, n=1000, seed=4241)    |        4.11        |      0.04     |    116.05    | |     nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)      |        0.06        |      0.0      |    22.98     | |     nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)     |        4.66        |      0.03     |    146.43    | | nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241) |        0.01        |      0.0      |     3.12     | |           nx.connected_caveman_graph(100,10)           |        0.11        |      0.05     |     2.22     | |                nx.caveman_graph(100,10)                |        0.0         |      0.0      |     2.1      | |               nx.windmill_graph(10, 10)                |        0.01        |      0.0      |     4.33     | |               nx.full_rary_tree(3, 1000)               |        0.07        |      0.03     |     2.17     | |                 nx.complete_graph(100)                 |        0.06        |      0.0      |     28.8     | |                 nx.complete_graph(10)                  |        0.0         |      0.0      |     3.83     | |                  nx.cycle_graph(100)                   |        0.01        |      0.0      |     2.17     | |                   nx.cycle_graph(10)                   |        0.0         |      0.0      |     1.9      | +--------------------------------------------------------+--------------------+---------------+--------------+ ```  <details> <summary> benchmark code </summary>  ```python  import timeit, prettytable import collections  def generic_bfs_edges(G, source, neighbors=None, depth_limit=None, sort_neighbors=None):     if neighbors is None:         neighbors = G.neighbors     if callable(sort_neighbors):         _neighbors = neighbors         neighbors = lambda node: iter(sort_neighbors(_neighbors(node)))      visited = {source}     if depth_limit is None:         depth_limit = len(G)     queue = collections.deque([(source, depth_limit, neighbors(source))])     while queue:         parent, depth_now, children = queue[0]         try:             child = next(children)             if child not in visited:                 yield parent, child                 visited.add(child)                 if depth_now > 1:                     queue.append((child, depth_now - 1, neighbors(child)))         except StopIteration:             queue.popleft()  def generic_bfs_edges_2(G, source, neighbors=None, depth_limit=float("inf"), sort_neighbors=None):     if neighbors is None:         neighbors = G.neighbors     if sort_neighbors is not None:         neighbors = lambda node: iter(sort_neighbors(neighbors(node)))      seen = {source}     n = len(G)     depth = 0     next_parents_children = [(source, neighbors(source))]     while next_parents_children and depth < depth_limit:         this_parents_children = next_parents_children         next_parents_children = []         for parent, children in this_parents_children:             for child in children:                 if child not in seen:                     seen.add(child)                     next_parents_children.append((child, neighbors(child)))                     yield parent, child             if len(seen) == n:                 return         depth += 1  graphs = [  "nx.random_regular_graph(d=1, n=10, seed=4241)", "nx.random_regular_graph(d=9, n=10, seed=4241)",             "nx.random_regular_graph(d=10, n=100, seed=4241)", "nx.random_regular_graph(d=99, n=100, seed=4241)",             "nx.random_regular_graph(d=1, n=1000, seed=4241)", "nx.random_regular_graph(d=3, n=1000, seed=4241)",             "nx.random_regular_graph(d=10, n=1000, seed=4241)", "nx.random_regular_graph(d=50, n=1000, seed=4241)",             "nx.random_regular_graph(d=100, n=1000, seed=4241)", "nx.random_regular_graph(d=200, n=1000, seed=4241)",             "nx.random_regular_graph(d=500, n=1000, seed=4241)", "nx.random_regular_graph(d=700, n=1000, seed=4241)",             "nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)", "nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)",             "nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241)", "nx.connected_caveman_graph(100,10)",               "nx.caveman_graph(100,10)",  "nx.windmill_graph(10, 10)", "nx.full_rary_tree(3, 1000)",               "nx.complete_graph(100)", "nx.complete_graph(10)",  "nx.cycle_graph(100)", "nx.cycle_graph(10)" ]  stmt_1 = "a = list(generic_bfs_edges(G, random.randrange(len(G)-1))); #print(len(a))" stmt_2 = "b = list(generic_bfs_edges_2(G, random.randrange(len(G)-1))); #print(len(b))" table = prettytable.PrettyTable() table.field_names = ["graph", "time: current main", "time: this pr", "times faster"]  for graph in graphs:     setup_1 = "import networkx as nx; import collections, random; from __main__ import generic_bfs_edges; random.seed(4241); G = {}".format(graph)     setup_2 = "import networkx as nx; import collections, random; from __main__ import generic_bfs_edges_2; random.seed(4241); G = {}".format(graph)     main_time = timeit.timeit(stmt_1, setup_1, number=100)     pr_time = timeit.timeit(stmt_2, setup_2, number=100)     a, b, c, d = graph, round(main_time,2), round(pr_time,2), round(main_time/pr_time, 2)     table.add_row([a, b, c, d])     print(d) print(table) ```  </details>  I also assigned G.neighbors to neighbors if nothing is passed for the parameter (to be coherent with what was written in the docstring)
issue
Optimize _plain_bfs functions#TITLE_END#Optimization of _plain_bfs for undirected graphs through the same principles described in #6299 and #6337.  This is a table which summarizes the new times in relation to the old ones for some graphs, as you can see there are some huge improvements in performance :-)  ``` +--------------------------------------------------------+--------------------+---------------+--------------+ |                         graph                          | time: current main | time: this pr | times faster | +--------------------------------------------------------+--------------------+---------------+--------------+ |     nx.random_regular_graph(d=1, n=10, seed=4241)      |        0.0         |      0.0      |     2.91     | |     nx.random_regular_graph(d=9, n=10, seed=4241)      |        0.03        |      0.0      |     12.3     | |    nx.random_regular_graph(d=10, n=100, seed=4241)     |        0.29        |      0.03     |     9.94     | |    nx.random_regular_graph(d=99, n=100, seed=4241)     |        1.67        |      0.02     |    109.89    | |    nx.random_regular_graph(d=1, n=1000, seed=4241)     |        0.0         |      0.0      |     2.7      | |    nx.random_regular_graph(d=3, n=1000, seed=4241)     |        1.75        |      0.31     |     5.7      | |    nx.random_regular_graph(d=10, n=1000, seed=4241)    |        2.91        |      0.28     |    10.58     | |    nx.random_regular_graph(d=50, n=1000, seed=4241)    |        6.94        |      0.27     |    25.98     | |   nx.random_regular_graph(d=100, n=1000, seed=4241)    |       13.59        |      0.26     |    52.84     | |   nx.random_regular_graph(d=200, n=1000, seed=4241)    |       29.19        |      0.25     |    118.5     | |   nx.random_regular_graph(d=500, n=1000, seed=4241)    |        85.0        |      0.21     |    405.64    | |   nx.random_regular_graph(d=700, n=1000, seed=4241)    |       121.13       |      0.18     |    667.0     | |     nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)      |        1.09        |      0.01     |    95.36     | |     nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)     |       107.46       |      0.17     |    624.35    | | nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241) |        0.2         |      0.02     |     8.34     | |           nx.connected_caveman_graph(100,10)           |        1.92        |      0.43     |     4.52     | |                nx.caveman_graph(100,10)                |        0.02        |      0.01     |     3.99     | |               nx.windmill_graph(10, 10)                |        0.18        |      0.01     |    18.01     | |               nx.full_rary_tree(3, 1000)               |        1.09        |      0.14     |     7.86     | |                 nx.complete_graph(100)                 |        1.2         |      0.01     |    110.49    | |                 nx.complete_graph(10)                  |        0.02        |      0.0      |    11.63     | |                  nx.cycle_graph(100)                   |        0.11        |      0.02     |     6.25     | |                   nx.cycle_graph(10)                   |        0.01        |      0.0      |     5.44     | +--------------------------------------------------------+--------------------+---------------+--------------+ ```   <details> <summary> Code to recreate the benchmark table</summary>   ```python import timeit, prettytable  def _plain_bfs(G, source):     """A fast BFS node generator      The direction of the edge between nodes is ignored.      For directed graphs only.      """     Gsucc = G.succ     Gpred = G.pred     seen = set()     nextlevel = {source}     while nextlevel:         thislevel = nextlevel         nextlevel = {}         for v in thislevel:             if v not in seen:                 seen.add(v)                 nextlevel.update(Gsucc[v])                 nextlevel.update(Gpred[v])                 yield v  def _plain_bfs_2(G, source):     """A fast BFS node generator      The direction of the edge between nodes is ignored.      For directed graphs only.     """     Gsucc = G._succ     Gpred = G._pred     n = len(G)     seen = set()     nextlevel = [source]     yield source     while nextlevel:         thislevel = nextlevel         nextlevel = []         for v in thislevel:             for w in Gsucc[v]:                 if w not in seen:                     seen.add(w)                     nextlevel.append(w)                     yield w             for w in Gpred[v]:                 if w not in seen:                     seen.add(w)                     nextlevel.append(w)                     yield w             if len(seen) == n:                 return  graphs = [  "nx.random_regular_graph(d=1, n=10, seed=4241)", "nx.random_regular_graph(d=9, n=10, seed=4241)",             "nx.random_regular_graph(d=10, n=100, seed=4241)", "nx.random_regular_graph(d=99, n=100, seed=4241)",             "nx.random_regular_graph(d=1, n=1000, seed=4241)", "nx.random_regular_graph(d=3, n=1000, seed=4241)",             "nx.random_regular_graph(d=10, n=1000, seed=4241)", "nx.random_regular_graph(d=50, n=1000, seed=4241)",             "nx.random_regular_graph(d=100, n=1000, seed=4241)", "nx.random_regular_graph(d=200, n=1000, seed=4241)",             "nx.random_regular_graph(d=500, n=1000, seed=4241)", "nx.random_regular_graph(d=700, n=1000, seed=4241)",             "nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)", "nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)",             "nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241)", "nx.connected_caveman_graph(100,10)",               "nx.caveman_graph(100,10)",  "nx.windmill_graph(10, 10)", "nx.full_rary_tree(3, 1000)",               "nx.complete_graph(100)", "nx.complete_graph(10)",  "nx.cycle_graph(100)", "nx.cycle_graph(10)" ]  stmt_1 = "a = list(_plain_bfs(G, random.randrange(len(G)-1)))" stmt_2 = "b = list(_plain_bfs_2(G, random.randrange(len(G)-1)))" table = prettytable.PrettyTable() table.field_names = ["graph", "time: current main", "time: this pr", "times faster"]  for graph in graphs:     setup_1 = "import networkx as nx; import collections, random; from __main__ import _plain_bfs; random.seed(4241); G = {}".format("nx.DiGraph(" +graph+")")     setup_2 = "import networkx as nx; import collections, random; from __main__ import _plain_bfs_2; random.seed(4241); G = {}".format("nx.DiGraph(" +graph+")")     main_time = timeit.timeit(stmt_1, setup_1, number=500)     pr_time = timeit.timeit(stmt_2, setup_2, number=500)     a, b, c, d = graph, round(main_time,2), round(pr_time,2), round(main_time/pr_time, 2)     table.add_row([a, b, c, d])     print(d) print(table) ```  </details> 
issue
Optimize _single_shortest_path_length function#TITLE_END#Hi! I have modified the function `_single_shortest_path_length` making it more performing. I was inspired by the first implementation in #3647, because it seemed to perform better and also it yielded the nodes in a reproducible fashion, since passing nodes to sets was avoided. I improved that version and recalculated the times of execution against the current main in python 3.11. It gives the following results:  ``` +--------------------------------------------------------+--------------------+---------------+--------------+ |                         graph                          | time: current main | time: this pr | times faster | +--------------------------------------------------------+--------------------+---------------+--------------+ |     nx.random_regular_graph(d=1, n=10, seed=4241)      |        0.01        |      0.0      |     1.93     | |     nx.random_regular_graph(d=9, n=10, seed=4241)      |        0.01        |      0.01     |     1.39     | |    nx.random_regular_graph(d=10, n=100, seed=4241)     |        0.15        |      0.08     |     1.96     | |    nx.random_regular_graph(d=99, n=100, seed=4241)     |        0.05        |      0.04     |     1.24     | |    nx.random_regular_graph(d=1, n=1000, seed=4241)     |        0.01        |      0.01     |     1.71     | |    nx.random_regular_graph(d=3, n=1000, seed=4241)     |        1.86        |      0.89     |     2.08     | |    nx.random_regular_graph(d=10, n=1000, seed=4241)    |        1.51        |      0.98     |     1.53     | |    nx.random_regular_graph(d=50, n=1000, seed=4241)    |        3.13        |      0.77     |     4.06     | |   nx.random_regular_graph(d=100, n=1000, seed=4241)    |        0.7         |      0.68     |     1.03     | |   nx.random_regular_graph(d=200, n=1000, seed=4241)    |        1.34        |      0.65     |     2.07     | |   nx.random_regular_graph(d=500, n=1000, seed=4241)    |        5.51        |      0.56     |     9.91     | |   nx.random_regular_graph(d=700, n=1000, seed=4241)    |       10.27        |      0.51     |    20.14     | |     nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)      |        0.23        |      0.04     |     6.34     | |     nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)     |       11.82        |      0.46     |    25.85     | | nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241) |        0.11        |      0.07     |     1.63     | |           nx.connected_caveman_graph(100,10)           |        1.44        |      0.98     |     1.48     | |                nx.caveman_graph(100,10)                |        0.02        |      0.01     |     1.38     | |               nx.windmill_graph(10, 10)                |        0.04        |      0.03     |     1.32     | |               nx.full_rary_tree(3, 1000)               |        0.79        |      0.43     |     1.85     | |                 nx.complete_graph(100)                 |        0.03        |      0.03     |     1.21     | |                 nx.complete_graph(10)                  |        0.01        |      0.01     |     1.11     | |                  nx.cycle_graph(100)                   |        0.14        |      0.06     |     2.43     | |                   nx.cycle_graph(10)                   |        0.02        |      0.01     |     2.11     | +--------------------------------------------------------+--------------------+---------------+--------------+ ```  <details> <summary> Benchmark code </summary>  ```python import timeit, prettytable  def _single_shortest_path_length(adj, firstlevel, cutoff):     """Yields (node, level) in a breadth first search     Shortest Path Length helper function     Parameters     ----------         adj : dict             Adjacency dict or view         firstlevel : dict             starting nodes, e.g. {source: 1} or {target: 1}         cutoff : int or float             level at which we stop the process     """     seen = {}  # level (number of hops) when seen in BFS     level = 0  # the current level     nextlevel = set(firstlevel)  # set of nodes to check at next level     n = len(adj)     while nextlevel and cutoff >= level:         thislevel = nextlevel  # advance to next level         nextlevel = set()  # and start a new set (fringe)         found = []         for v in thislevel:             if v not in seen:                 seen[v] = level  # set the level of vertex v                 found.append(v)                 yield (v, level)         if len(seen) == n:             return         for v in found:             nextlevel.update(adj[v])         level += 1     del seen  def _single_shortest_path_length_2(adj, firstlevel, cutoff):     """Yields (node, level) in a breadth first search      Shortest Path Length helper function     Parameters     ----------         adj : dict             Adjacency dict or view         firstlevel : dict             starting nodes, e.g. {source: 1} or {target: 1}         cutoff : int or float             level at which we stop the process     """     seen = set(firstlevel)     level = 0     nextlevel = list(firstlevel)     n = len(adj)     for v in nextlevel:         yield (v, level)     while nextlevel and cutoff > level:         level += 1         thislevel = nextlevel         nextlevel = []         for v in thislevel:             for w in adj[v]:                 if w not in seen:                     seen.add(w)                     nextlevel.append(w)                     yield (w, level)             if len(seen) == n:                 return  graphs = [  "nx.random_regular_graph(d=1, n=10, seed=4241)", "nx.random_regular_graph(d=9, n=10, seed=4241)",             "nx.random_regular_graph(d=10, n=100, seed=4241)", "nx.random_regular_graph(d=99, n=100, seed=4241)",             "nx.random_regular_graph(d=1, n=1000, seed=4241)", "nx.random_regular_graph(d=3, n=1000, seed=4241)",             "nx.random_regular_graph(d=10, n=1000, seed=4241)", "nx.random_regular_graph(d=50, n=1000, seed=4241)",             "nx.random_regular_graph(d=100, n=1000, seed=4241)", "nx.random_regular_graph(d=200, n=1000, seed=4241)",             "nx.random_regular_graph(d=500, n=1000, seed=4241)", "nx.random_regular_graph(d=700, n=1000, seed=4241)",             "nx.erdos_renyi_graph(n=100, p=0.9, seed=4241)", "nx.erdos_renyi_graph(n=1000, p=0.8, seed=4241)",             "nx.watts_strogatz_graph(n=100, k=10, p=0.3, seed=4241)", "nx.connected_caveman_graph(100,10)",               "nx.caveman_graph(100,10)",  "nx.windmill_graph(10, 10)", "nx.full_rary_tree(3, 1000)",               "nx.complete_graph(100)", "nx.complete_graph(10)",  "nx.cycle_graph(100)", "nx.cycle_graph(10)" ]  stmt_1 = "list(_single_shortest_path_length(G.adj, {random.randrange(len(G)-1): 1}, float('inf')))" stmt_2 = "list(_single_shortest_path_length_2(G._adj, {random.randrange(len(G)-1): 1}, float('inf')))" table = prettytable.PrettyTable() table.field_names = ["graph", "time: current main", "time: this pr", "times faster"]  for graph in graphs:     setup_1 = "import networkx as nx; import collections, random; from __main__ import _single_shortest_path_length; random.seed(4241); G = {}".format(graph)     setup_2 = "import networkx as nx; import collections, random; from __main__ import _single_shortest_path_length_2; random.seed(4241); G = {}".format(graph)     main_time = timeit.timeit(stmt_1, setup_1, number=20000)     pr_time = timeit.timeit(stmt_2, setup_2, number=20000)     a, b, c, d = graph, round(main_time,2), round(pr_time,2), round(main_time/pr_time, 2)     table.add_row([a, b, c, d])     print(d) print(table) ```  </details>  As you see the new implementation is marginally better for many cases  (but also sometimes marginally worse) . Though, there are also some cases where the time of execution is **more than an order of magnitude better than the current one**. I want also to stress the point about reproducibility which can be very useful sometimes (I actually tried to optimize this algorithm for this reason!).
