comment
Dear @jtorrents, The same note (This algorithm does not work if edge weights are floating-point numbers.) is present in the capacity_scaling method. Is it the same issue? If yes, which parts of the code make the issue?  I didn't notice this note, and did run the method plenty of times before (with float weights), it worked most of the time. Only thing I realised is that the **total** runtime of solving a certain **group** of problems was higher than usual. But when I solved the instances of that group **separately**, they didn't show the issue, they all took normal time. Only when the whole group is run, collectively it takes 2x-5x the normal time. My only idea for this was that it's a [branch prediction fail](https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array). Do you have any thoughts on this?  Thank you very much in advance.
