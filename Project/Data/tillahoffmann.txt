issue
Pin last value to 1.0 in `cumulative_distribution` to address floating-point errors.#TITLE_END#When parameters to `cumulative_distribution` are low-precision floats, e.g., from NumPy with `dtype=np.float32`, floating-point errors can accumulate. This leads to the last cdf value in `cumulative_distribution` being < 1.0, and the samples returned by `discrete_sequence` can be out-of-bounds. This PR makes a minimal change and fixes the last cdf value to 1.0, overcoming possible rounding errors.  Here's a snippet that fails before this change and passes afterwards.  ```python import networkx as nx import numpy as np   gamma = np.asarray(0.8586120009422302, dtype=np.float32) num_nodes = 1000 seed = 15_158   graph = nx.gn_graph(num_nodes, lambda k: k**gamma, seed=seed) assert nx.number_of_selfloops(graph) == 0, (     f"Self loops in DIRECTED graph for seed {seed}: {list(nx.selfloop_edges(graph))}" ) ```
issue
Add `create_using` parameter for random graphs.#TITLE_END#This PR adds the `create_using` parameter to random graph and duplication divergence models, allowing users to create graphs of the desired type.
issue
Add option to hide or show tick labels.#TITLE_END#This PR adds a flag `hide_ticks` to drawing functions so tick labels can be shown. This can be useful for debugging or spatial networks, for example. The default is `hide_ticks=True` to ensure functionality does not change.  *Edit*: I'm not sure why the Circle CI test fails. *Edit*: It seemed that Circle CI was failing because I hadn't updated my default branch from `master` to `main` yet.
issue
networkx.navigable_small_world_graph generator produces self-loops#TITLE_END#The graph generator networkx.navigable_small_world_graph produces self-loops. The current implementation is  ``` python G = nx.DiGraph() nodes = list(product(range(n),repeat=dim)) for p1 in nodes: probs = [0] for p2 in nodes:     if p1==p2:         continue     d = sum((abs(b-a) for a,b in zip(p1,p2)))     if d <= p:         G.add_edge(p1,p2)     probs.append(d**-r) cdf = list(nx.utils.cumulative_sum(probs)) for _ in range(q):     target = nodes[bisect_left(cdf,random.uniform(0, cdf[-1]))]     G.add_edge(p1,target) return G ```  The problem arises because of line 4 `probs = [0]` which results in the first node `(0,0)` never being selected as a random long-range connection. Furthermore, this leads to the creation of self loops in the graph.  The implementation should read  ``` python G = nx.DiGraph() nodes = list(product(range(n),repeat=dim)) for p1 in nodes: probs = [] #No 0 added here for p2 in nodes:     if p1==p2:         probs.append(0) #But 0 added here         continue     d = sum((abs(b-a) for a,b in zip(p1,p2)))     if d <= p:         G.add_edge(p1,p2)     probs.append(d**-r) cdf = list(nx.utils.cumulative_sum(probs)) for _ in range(q):     target = nodes[bisect_left(cdf,random.uniform(0, cdf[-1]))]     G.add_edge(p1,target) return G ``` 
