issue
Connected graph generation with Havel-Hakimi#TITLE_END#This PR: * Adds a new `is_potentially_connected` function, which checks whether there exists a connected graph realizing a degree sequence. * Modifies the `havel_hakimi_graph` algorithm to allow for connected graph generation.  #### Notes: `dmin` is still partially computed even when not necessary in `havel_hakimi_graph` , as the code seemed more readable to me without the extra conditionals. Let me know if you'd prefer a clean separation between both cases.  I'm also not sure whether `is_potentially_connected` belongs in `graphical.py`.
issue
Default to Prim's algorithm in mst#TITLE_END#Following #5455, the prim algorithm is much faster.  I set out to benchmark it in order to figure out if it would make sense to change the default algorithm used in MST-related functions from Kruskal to Prim.  To do so, I sampled 2000 points (n, p) uniformly at random in [5, 2000] x [0, 1], generated a G_{n,p} graph for each of these points, and ran both the Prim and Kruskal version of `nx.minimum_spanning_edges` on them.  The average measured speedup gained by using Prim was of 1.79, and detailed results can be found below: ![foo](https://user-images.githubusercontent.com/46298009/162063919-cb602bc9-cfdc-4007-ae60-3a68a524fb3c.png) ![bar](https://user-images.githubusercontent.com/46298009/162062167-4af4b756-6a5b-411a-9b53-b7e40065d838.png)  Similar results were found for N=3000 and N=5000. <details>   <summary>Code to reproduce benchmark</summary>    The following code runs in ~35 minutes on my machine. ```python import networkx as nx import matplotlib.pyplot as plt import time from tqdm import tqdm from matplotlib import colors from pylab import cm import random import numpy as np  plt.rc('axes', axisbelow=True)  # Run benchmark res = {} d = 0 N = 1000 for _ in tqdm(range(N)):     n = random.randint(5,2000)     p = random.uniform(0,1)     G = nx.gnp_random_graph(n, p)     # Prim     start = time.perf_counter()     list(nx.minimum_spanning_edges(G, algorithm="prim"))     stop = time.perf_counter()     prim_time = stop - start     # Kruskal     start = time.perf_counter()     list(nx.minimum_spanning_edges(G, algorithm="kruskal"))     stop = time.perf_counter()     kruskal_time = stop - start     conn = sum(d for n_prime, d in G.degree())/(n*(n-1))     res[(n, conn, d)] = {"prim": prim_time, "kruskal": kruskal_time}     d+=1     #print(f"{n}, {conn:.2f}: {kruskal_time/prim_time}")  # Plot results x,y,c = [],[],[] for (N,C,_), r in res.items():     x.append(N)     y.append(C)     c.append(r['kruskal']/r['prim'])  # Speedup distribution plt.figure(figsize=(15,8)) plt.hist(c, bins=75, weights=np.zeros_like(c) + 1. / len(c)) plt.xlabel("Speedup obtained by using Prim instead of Kruskal") plt.ylabel("Frequency") plt.title("Speedup distribution") plt.xticks(np.arange(0, 10, 1)) plt.show();  # Speedup depending on n and p cmap = cm.get_cmap('RdYlGn', 20) plt.figure(figsize=(15,8)) plt.grid(alpha=0.4) plt.scatter(x=x, y=y, c=c, cmap=cmap, vmin=0, vmax=2) plt.xlabel("Number of nodes $n$") plt.ylabel("Edge frequency $p := \dfrac{num\_edges}{n(n-1)}$") plt.title("Prim and Kruskal benchmarks on $G_{n,p}$ graphs") cbar = plt.colorbar() cbar.set_label("Prim speedup") print(f"Average speedup: {sum(c)/len(c)}") plt.show(); ``` </details> 
issue
Optimize prim for mst#TITLE_END#The current implementation of Prim's algorithm in `prim_mst_edges` is inefficient: it keeps iterating over all the edges in the frontier even though all the nodes in the graph have been added to the tree. This version allows the algorithm to return as soon as the MST has been computed, allowing for a major speedup on large graphs.  ### Quick benchmarks  Some quick benchmarks on a randomly generated complete graph of N nodes showed:  - the new version is 2x faster for N=1000 - the new version is 3.5x faster for N=2000 - no performance deterioration was measured for small graph sizes (N=5, N=50, N=100)  <details>   <summary>Click to show code used for random complete graph generation</summary>    ``` import random import networkx as nx N = 500  G = nx.complete_graph(N) for (u,v,w) in G.edges(data=True):     w['weight'] = random.random() ``` </details>  
