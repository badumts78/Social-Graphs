issue
Added lowest common ancestor algorithm for trees and DAGs.#TITLE_END#This adds LCA for trees and DAGs, using Tarjan's offline lowest common ancestors algorithm and the DAG algorithm described in Bender et al (2005).  In addition to the  included unit tests, this was tested against a naive algorithm on a bunch of random graphs, and run (not compared to a naive) in on a ~40,000 node subgraph of the Wikipedia category graph to check for crashes and sanity of output (this was done as 40,000 different compute tasks on PiCloud; I need the data anyway.)  Two points of interest for the code review: 1) I have attempted to follow the style of many NetworkX algorithms of minimizing names (even _ ones) in the namespace. As such, this file is two long functions. If appropriate, I could split them into smaller, focused private helpers to make the code more clear. 2) Please take a look at lines 64 and 165; this is my attempt to balance generality and efficiency (especially since the DAG algorithm makes use of the tree algorithm). I know it violates the spirit of duck typing, but I would like to avoid an unnecessary double copy of large data structures. 
issue
is_directed_acyclic_graph now returns false on undirected graphs rather ...#TITLE_END#...than raising NetworkXError. Tests updated to expose old behavior and verify change. 
comment
I remember not really understanding why you could just pick any spanning tree when I was implementing this, but it worked for every input I fed it, including some rather large random tests I never committed to networkx, and not having a background in graph theory, I was content to trust the authors combined with randomized testing. And to be honest the project I needed this for was...tolerant to the occasional error shall we say -- I wouldn't have noticed any coming up in actual use so long as it was mostly accurate most of the time on nltk ontologies.  It did not occur to me to do exhaustive random tests on simple graphs -- instead I generated large graphs and only ever used the DFS spanning tree. If we ever do find a fix it would be good to add a test that generates all spanning trees over a simple graph.  This is all based on memory; I haven't reread the paper since I wrote this in 2013, and haven't re-read the code since the PR was finally merged in 2017.  IIRC most of Bender et al is devoted to describing an asymptotically more efficient algorithm than the one implemented here. The O(n^3) algorithm I implemented is included as well, described relatively briefly, as a suggested to implementers.  So if there is an error, it's possible that the core algorithm is correct, and only the simplified version is wrong.  It's tempting to try to duct tape on a fix to paper over this particular case, but without an understanding of why the algorithm works or why it fails in this case, I think that would be somewhat irresponsible. Pretty sure considering all spanning trees would work, but that's going to get expensive.  It may be worth contacting the authors, if the bug is in the algorithm itself rather than our code. We may be interpreting it wrong, or there may be a simple fix. I would need to reread the paper carefully before I'd feel comfortable doing so personally, which unfortunately I don't think I can commit to these days, but it sounds like you have already done so based on the excellent write up above, so it may be worth a try.  Of course it's been 18 years for them, vs just 8 for me, and I still remember little:-)
comment
Thinking about this some more, is the problem the added edges for the root node? Would it suffice to consider one arbitrary spanning tree per source?
comment
I really wish they would have explained the ordered ancestor lists thing better.  Does the all-pairs LCA you link to work on graphs? the readme says tree only. I believe it's the same algorithm used as a subroutine in my implementation.
