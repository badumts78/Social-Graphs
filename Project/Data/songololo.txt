issue
Closeness centrality - normalisation flag - clarity necessary for what normalisation means in this context.#TITLE_END#When trying the `networkx.algorithms.centrality.closeness` method it seems to return the same values whether setting `normalisation` to true or false.  Looking at the code:  ``` closeness_centrality = {} for n in nodes:     sp = path_length(G,n)     totsp = sum(sp.values())     if totsp > 0.0 and len(G) > 1:         closeness_centrality[n] = (len(sp)-1.0) / totsp        # normalize to number of nodes-1 in connected part         if normalized:             s = (len(sp)-1.0) / ( len(G) - 1 )             closeness_centrality[n] *= s     else:         closeness_centrality[n] = 0.0 ```  In most cases the length of the `sp` dictionary will be the same as the number of nodes in the graph, thus multiplying `closeness_centrality[n]` by 1 and having no effect?  It seems like the intent is to normalise values across disconnected graphs? 
comment
Another voice in support of type annotations. It seems like a large amount of hard work / discussion / thought has gone into the above and I truly hope it makes it across the line.  The benefit of type hinting from a developer experience point of view is substantial. Both in terms of anticipating what a library such as NetworkX expects or returns from classes and methods, and in terms of greatly reducing bugs and streamlining work downstream.  In the meantime (i.e. before a pull request such as the above is merged), is there anyway to make this work available as a `netoworkx-stubs` form of package? I'm tempted to create my own `pyi` files from the above but don't want to do so if there is already notable work in this direction elsewhere?
comment
I agree that stub files should be a last resort.  The initial overhead of properly incorporating typing might seem like an encumbrance or a lot of effort at first, but once it is set up it is a **massive** help to developing and maintaining complex code bases: the IDE constantly feeds back and catches errors as you go. I've been using `vscode` and `pyright` / `pylance` and I'm completely floored by how much more manageable previously gnarly projects have become.
comment
I've personally run into an issue where `Type | AnotherType` raised issues in Python3.8 environments and had to change everything back to `Union` and `Optional`. I honestly can't remember what the exact issue was, and maybe there was a misstep on my part, but just a mention for now to double check any edge cases for older versions before making any major changes.
comment
From the above discussion, my interpretation is: - typehints are the way to go - they make an immense improvement to the developer experience because the intention of code becomes crystal clear and mistakes are caught before they happen. The benefit to downstream code and dependent packages is immense.  - typehints can be included either via stub files or inline:   - 1 - stub files are significantly harder to maintain and would involve either tedious effort or complex CI workflows to generate and keep in sync with the main development work.   - 2 - stub files do not transparently communicate the intention of the code when reading the source because they are split from the main code.   -  3 - inline typehints add more verbosity - though when well designed this is a benefit, not a detriment, because it more clearly communicates the intention of the code.  The only concrete objection I'm hearing is that beginners would find inline type hinting more challenging. Several questions in this regard: - Beginners and general users are more likely to read the documentation than the source code? - Those that progress to reading the source code would surely benefit from seeing the parameters coupled to types, and understanding what types are accepted by and returned from functions? - Basic type hinting can be learned relatively quickly, so that those beginners who do need or want to interact with the source code will surely figure things out with relatively minimal effort, and would very quickly start benefitting from typehints by having more clarity on what the code is doing? - Instead of using complex CI to keep inline typehints out of code, wouldn't it be easier and better to do the opposite, i.e. use CI to strip out inline types for those that want to read type-free source?  All in all, inline type hinting is an inevitability for well supported Python packages and the momentum is only growing.  I'd encourage the core networkx maintainers not to pass up the excellent opportunity to take advantage of the hard work offered by the above contributors.
comment
> I don't find this convincing. We see in practice that type annotations can make it hard, even for experienced Python developers, to follow code. This situation will improve as type syntax is simplified, but currently typing can quickly get hairy for, e.g., Callables, as well as most other non-trivial examples.  A respectful and hopefully constructive disagreement on this point. The reasons: - The contributors proposing the inline type hint changes are aware of, and are using, strategies for wrapping complexities in more intuitive and simplified forms per earlier discussions in this thread. - Please consider that typehints help rather than hinder experienced developers in understanding code on first sight and allows them to contribute more easily with a bit less digging through related code. It should help onboard new contributors and helps to maintain code quality because intentions are explicit and mistakes are immediately flagged by IDEs.
comment
@a-r-j worth notifying people on this discussion as well: https://github.com/networkx/networkx/pull/4014  
