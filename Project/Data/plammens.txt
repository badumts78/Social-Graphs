issue
all_simple_paths on MultiGraph fails when multiple targets are reached exactly at the cutoff#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  ### Steps to Reproduce  ```python import networkx as nx  G = nx.MultiGraph([(0, 1), (0, 2)]) list(nx.all_simple_paths(G, 0, {1, 2}, cutoff=1)) ```   ### Current Behavior  ```python >>> list(nx.all_simple_paths(G, 0, {1, 2}, cutoff=1)) [[0, 1]] ```  ### Expected Behavior  ```python >>> list(nx.all_simple_paths(G, 0, {1, 2}, cutoff=1)) [[0, 1], [0, 2]] ```  ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.11 NetworkX version: 3.2rc0.dev0  ### Additional context  This is a bug I encountered while working on #6694 . The cause of the bug is here:  https://github.com/networkx/networkx/blob/5fcf01b9a43a097c4f579486023d1279b2b88619/networkx/algorithms/simple_paths.py#L315-L318  Since `children` is an iterator, the first time `list(children)` is computed, the iterator is consumed, and it returns an empty list afterwards.  I will fix it in #6694 because I need to refactor this function in any case. 
issue
all_simple_paths returns empty generator when the source is one of the possible targets#TITLE_END#### Current Behavior  Due to this conditional:  https://github.com/networkx/networkx/blob/5f2f88f6afc385892d91c20676d7dc6aa80d52bb/networkx/algorithms/simple_paths.py#L253-L254  whenever the `source` node appears as one of the possible targets, `all_simple_paths` always generates an empty list of paths.  For example:  ```python import networkx as nx  graph = nx.Graph([(1, 2), (1, 3)]) ``` ```python >>> list(nx.all_simple_paths(graph, source=1, target={1, 2, 3})) [] ```   ### Expected Behavior  Apologies if I have misunderstood what the function is meant to do. Here's what I understand.  The function generates a list of simple paths from the given source to (any of the) given target(s). The docstring says: > Pass an iterable of nodes as target to generate all paths ending in **any** of several nodes  So the fact that the source node is in the set of target nodes does not necessarily exclude _all_ paths, there could be some other target that works. For instance, in the example above the function missed out on two perfectly reasonable paths: `[1, 2]` and `[1, 3]`. As far as I understand they both satisfy the description above: they're simple paths from the source (1) to any of the targets (1, 2, 3).  So why does it return an empty generator? It should return the same as `list(nx.all_simple_paths(graph, source=1, target={2, 3}))`, that is, `[[1, 2], [1, 3]]`.  I understand that any path from source to itself wouldn't be simple, but again this doesn't automatically exclude paths to any of the other specified targets.  ### Steps to Reproduce  ```python import networkx as nx  graph = nx.Graph([(1, 2), (1, 3)]) list(nx.all_simple_paths(graph, source=1, target={1, 2, 3})) ```   ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.11 NetworkX version: 5f2f88f6afc385892d91c20676d7dc6aa80d52bb (3.1)  
issue
fix: Include singleton/trivial paths in all_simple_paths & other functions#TITLE_END#The source being one of the targets shouldn't automatically exclude all other solutions.  Closes #6690, closes #6732  - [x] Waiting on a response to https://github.com/networkx/networkx/issues/6690#issuecomment-1550373302 before marking as ready for review. - [x] Report the single node paths (and show this in doc_string examples). - [x] Add a test that these functions report single node paths. - [x] Add tests to the other functions mentioned above to ensure that they treat single node paths as paths. Those tests may already exist. But if they don't it'd be good to add them. - [x] For consistency, report empty edge paths in `all_simple_edge_paths` (pending discussion, see https://github.com/networkx/networkx/issues/6690#issuecomment-1575578041)   <!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Add method to clear edges only#TITLE_END#Add method `clear_edges` to `Graph` and its subclasses that clears all edges without altering nodes or graph attributes.
issue
Network simplex does not terminate in certain cases#TITLE_END#The implementation of `networkx.network_simplex` does not terminate in certain specific cases in which the selection of the exiting basic variable while on a degenerate base forms an infinite cycle. The documentation says the implementation uses the "leaving arc rule" to prevent cycling, but apparently it's not working.  I believe the culprit is the selection of the entering edge:   https://github.com/networkx/networkx/blob/2db5f8663deacc501c7472c3a60884a2ca8be45a/networkx/algorithms/flow/networksimplex.py#L325-L326  Selecting the entering nonbasic variable as the one with the minimum reduced cost is a known source of cycling in the general simplex algorithm, and I would believe it still applies here. It causes problems in those rare (in non-academic problems) cases in which a degenerate base is found.  The most straightforward solution is using [Bland's rule](https://en.wikipedia.org/wiki/Bland%27s_rule), which according to this comment is already implemented:  https://github.com/networkx/networkx/blob/2db5f8663deacc501c7472c3a60884a2ca8be45a/networkx/algorithms/flow/networksimplex.py#L307-L310  Even so, it's still cycling, so there's something wrong with the implementation.  CC: @ysitu @loicseguin   ### Reproducible example  Since it's hard to make a *minimal* reproducible example, I'll just show the specific case I was working on. I haven't been able to reproduce it otherwise, sorry.  Preliminaries (these aren't actually relevant to the core of the problem itself, it's just what I was working on when I stumbled on this):  ```python from typing import Dict, Iterable, Set, Tuple  import math import networkx as nx import pandas as pd from haversine import Unit, haversine from haversine.haversine import _AVG_EARTH_RADIUS_KM  # Constants _AVG_EARTH_RADIUS_M = 1000 * _AVG_EARTH_RADIUS_KM  _URL_STATION_INFO = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_information' _URL_STATION_STATUS = 'https://api.bsmsa.eu/ext/api/bsm/gbfs/v2/en/station_status' _DATA_COLUMNS = ['lat', 'lon', 'num_bikes_available', 'num_docks_available']   class Coordinate:     """Represents a geographical coordinate."""     __slots__ = 'lat', 'lon'     lat: float  # latitude     lon: float  # longitude      def __init__(self, latitude: float, longitude: float):         self.lat = latitude         self.lon = longitude      def __iter__(self):         yield self.lat         yield self.lon      def __repr__(self):         return f'({self.lat}, {self.lon})'      def __str__(self):         return f'({self.lat}ยบ N, {self.lon}ยบ E)'   class StationWrapper:     """     Wrapper for a Bicing station. Can be constructed from any object that has     the same attributes as the rows in the DataFrame returned by ``fetch_data``.     Implements some extra utilities on top of the data storage.     """      def __init__(self, station):         self.__station = station      def __getattr__(self, item):         return getattr(self.__station, item)      def __repr__(self):         return repr(self.__station)      @property     def coords(self):         """Get the coordinates for this station as a ``Coordinate`` object"""         return Coordinate(self.lat, self.lon)   class BicingGraph(nx.Graph):     def __init__(self, stations: Iterable, **attr):         super().__init__(**attr)         self.add_nodes_from(stations)         self._distance: float = 0.0      @classmethod     def from_dataframe(cls, stations: pd.DataFrame, **kwargs) -> 'BicingGraph':         rows = stations.itertuples(name='Station')         return cls(tuple(map(StationWrapper, rows)), **kwargs)      def construct_graph(self, dist: float):         """         Construct geometric graph with a new distance         :param dist: new distance, in meters         """         if dist < 0:             raise ValueError("distance should be non-negative")          self.remove_edges_from(tuple(self.edges))  # No method to clear all edges in networkx's API         if dist > 0:             self._add_edges_in_grid(_DistanceGrid(self.nodes, dist), dist)         self._distance = dist      def _add_edges_in_grid(self, grid: '_DistanceGrid', dist: float):         """         Helper method for ``construct_graph``. Adds edges among neighbouring         nodes in a pre-constructed grid.         :param grid: grid such that within each cell all nodes are within `dist`         meters apart         :param dist: distance         """          def neighbours(cell_idx: Tuple[int, int]) -> Iterable[Tuple[int, int]]:             i, j = cell_idx             step_range = (0, -1, 1)             indices = ((i + di, j + dj) for di in step_range for dj in step_range)             next(indices)  # discard (i + 0, j + 0)             return indices          grid_dict = grid.cell_dict         for index, cell in grid_dict.items():             # connect neighbours:             for neighbour_index in neighbours(index):                 neighbour = grid_dict.get(neighbour_index, tuple())  # default is empty cell                 self.add_edges_from((a, b) for a in cell for b in neighbour                                     if distance(a, b) <= dist)             # mark cell as empty (to avoid repeated computations)             cell.clear()      def distribute(self, min_bikes: int, min_free_docks: int) -> Tuple[float, dict]:         if not isinstance(min_bikes, int) or not isinstance(min_free_docks, int) or \                 min_bikes < 0 or min_free_docks < 0:             raise ValueError("constraints should be non-negative integers")          self._write_bike_demands(min_bikes, min_free_docks)         self._write_edge_costs()         return nx.network_simplex(self.to_directed(),                                   demand='bike_demand', weight='distance')      def _write_bike_demands(self, min_bikes: int, min_free_docks: int):         total_demand: int = 0          for node, attributes in self.nodes(data=True):             bikes, free_docks = node.num_bikes_available, node.num_docks_available             total_docks = bikes + free_docks             if total_docks < min_bikes + min_free_docks:                 raise nx.NetworkXUnfeasible(                     f'cannot satisfy constraints min_bikes={min_bikes}, min_free_docks='                     f'{min_free_docks} on a station with {total_docks} total docks'                 )              bike_deficit = ramp(min_bikes - bikes)             dock_deficit = ramp(min_free_docks - free_docks)             demand = bike_deficit or -dock_deficit             assert bikes + demand >= min_bikes             assert free_docks - demand >= min_free_docks              attributes['bike_demand'] = demand             total_demand += demand          self._distribute_surplus_demand(min_bikes, min_free_docks, total_demand)      def _distribute_surplus_demand(self, min_bikes: int, min_free_docks: int, total_demand: int):         gen = iter(self.nodes(data=True))         while total_demand < 0:             # Try to find free docks in which to place surplus bikes             node, attributes = next(gen)             demand = attributes['bike_demand']             free_docks = node.num_docks_available             surplus_docks = min([free_docks - demand - min_free_docks, -total_demand])             demand += surplus_docks              total_demand += surplus_docks             attributes['bike_demand'] = demand          while total_demand > 0:             # Try to find surplus bikes to satisfy demand             node, attributes = next(gen)             demand = attributes['bike_demand']             bikes = node.num_bikes_available             surplus_bikes = min([bikes + demand - min_free_docks, total_demand])             demand -= surplus_bikes             total_demand -= surplus_bikes             attributes['bike_demand'] = demand      def _write_edge_costs(self):         for u, v, attributes in self.edges(data=True):             attributes['distance'] = distance(u, v)   class _DistanceGrid:     """     Helper class for the construction of a geometric graph; specifically, for     ``BicingGraph.construct_graph``. Represents a grid of geographical locations     such that each pair of points within a cell is less than a certain distance apart.     """      def __init__(self, nodes: Iterable, dist: float):         """Construct a grid with the given distance         :param nodes: iterable of geographical location objects (with 'lat' and 'lon' attributes)         :param dist: maximum distance between points in a single cell         """         bottom_left = Coordinate(min(n.lat for n in nodes), min(n.lon for n in nodes))          delta_lat, delta_lon = self._get_degree_side_lengths(bottom_left.lat, dist)         grid = {}         for node in nodes:             lat_index = int((node.lat - bottom_left.lat) / delta_lat)             lon_index = int((node.lon - bottom_left.lon) / delta_lon)             grid.setdefault((lat_index, lon_index), set()).add(node)          self._grid: Dict[Tuple[int, int], Set] = grid      @property     def cell_dict(self) -> Dict[Tuple[int, int], Set]:         return self._grid      @staticmethod     def _get_degree_side_lengths(lat: float, dist: float) -> Tuple[float, float]:         """         Calculate the (approximate) latitude/longitude degree-increments of the sides of a         "square" on the earth's surface such that any pair of points within it is at most         ``dist`` meters away. Here we assume the Earth is a sphere and we         approximate great-circle distances with planar distances.          :param lat: latitude degrees at which to perform computations         :param dist: maximum distance between points in a single cell         :return: the ``(latitude, longitude)`` degree increments         """          # Scale the distance so that every pair of points in a (planar) square with this         # side length is at most ``self._distance`` meters apart:         side_length = dist          lat = math.radians(lat)         latitude_radius = _AVG_EARTH_RADIUS_M * math.cos(lat)         return math.degrees(side_length / _AVG_EARTH_RADIUS_M), \                math.degrees(side_length / latitude_radius)   def distance(station1: StationWrapper, station2: StationWrapper) -> float:     """Utility for the distance between two stations, in meters"""     return haversine(tuple(station1.coords), tuple(station2.coords), unit=Unit.METERS)   def fetch_stations() -> pd.DataFrame:     """Fetches Bicing station data from the official database URL"""     info = _fetch_station_data_from_json(_URL_STATION_INFO)     status = _fetch_station_data_from_json(_URL_STATION_STATUS)     merged = info.join(status, how='inner')     return merged[_DATA_COLUMNS]   def _fetch_station_data_from_json(url: str) -> pd.DataFrame:     json_data = pd.read_json(url).data.stations     return pd.DataFrame.from_records(data=json_data, index='station_id')   def ramp(x):     """     :param x: numeric value     :return: max{0, x}     """     return x if x > 0 else 0 ```  Here is the error producing code:  ``` stations = fetch_stations() graph = BicingGraph.from_dataframe(stations.iloc) graph.construct_graph(10000.0) graph.distribute(4, 3) ```  The `nx.network_simplex(self.to_directed(), demand='bike_demand', weight='distance')` call in `BicingGraph.distribute` does not terminate.  ---------------  I've confirmed this was a cycling issue by adding the following `print` statement in  [line 525 of `networkx.network_simplex`](https://github.com/networkx/networkx/blob/2db5f8663deacc501c7472c3a60884a2ca8be45a/networkx/algorithms/flow/networksimplex.py#L525):  ```python     ...     # Pivot loop     for i, p, q in find_entering_edges():         print(i, p, q)         Wn, We = find_cycle(i, p, q)         ... ```  While running the previous example this sequence repeated over and over:  ```text ... 212 250 106 616 92 250 1387 250 320 74 250 37 90 250 45 160 250 80 ... ```
comment
> Finding the hamiltonian path is a hard problem and it's not trivial to generalize the hamiltonian function for a tournament graph to work with any general graph :)  I would add that even though the implementation might not be efficient, a basic function for finding hamiltonian paths in general (for small graphs) is clearly needed in a reference graph package such as `networkx`.
comment
> We are happy to include a submission along those lines if it is well tested and documented. This [wikipedia article](https://en.wikipedia.org/wiki/Hamiltonian_path_problem#:~:text=An%20early%20exact%20algorithm%20for,in%20the%20path%2C%20and%20undecided.) hints at some algorithms to try.  The most basic option that occurs to me is something like this:  ```python def hamiltonian_paths(graph: nx.Graph):     for source in graph.nodes:         yield from _hamiltonian_paths(graph, source)   def _hamiltonian_paths(graph: nx.Graph, source):     total_nodes = len(graph.nodes)      def dfs(node, path: tuple):         if len(path) == total_nodes:             yield path          for neighbour in graph[node].keys() - path:             yield from dfs(neighbour, path=path + (neighbour,))      yield from dfs(source, path=(source,)) ```  Perhaps rewriting the recursion with a stack for efficiency.   Or even just filtering the results from `nx.all_simple_paths` to avoid re-implementing a DFS.  But I assume you're looking for a more sophisticated algorithm than this, like those mentioned in the Wikipedia article?
