issue
shortest_path: Return the internal nodes#TITLE_END#When using objects that implement their own hash and equality methods this is pretty unexpected behaviour:  ```python import networkx as nx  class Foo:     def __init__(self, id, foo=None):         self.id  = id         self.foo = foo      def __eq__(self, other):         return hash(self) == hash(other)      def __hash__(self):         return self.id      def __repr__(self):         return str(self)      def __str__(self):         return f'Foo({self.id}, {self.foo})'  G = nx.Graph() nodes = [Foo(0, foo='zero'), Foo(1, foo='one')] G.add_node(nodes[0]) G.add_node(nodes[1]) G.add_edge(nodes[0], nodes[1], weight=1) w = 'weight'  print(f'{nx.shortest_path(G, Foo(0), Foo(1))}') print(f'{nx.shortest_path(G, Foo(0), Foo(1), method="dijkstra", weight=w)}') print(f'{nx.shortest_path(G, Foo(0), Foo(1), method="bellman-ford", weight=w)}') ```  The above program prints  ``` [Foo(0, None), Foo(1, one)] [Foo(0, None), Foo(1, one)] [Foo(0, None), Foo(1, None)] ```  which seems rather odd. Ie. it reflects the source for all three shortest path methods, but uses the internal node object of the target for `'unweighted'` and `'dijkstra'`.  Since the library will need to use the internal objects for nodes on the path (otherwise one wouldn't need to call `nx.shortest_path`..) it would make for the library to always use the internal nodes. Keeping everything consistent.  So I would expect the above code to print the following:  ``` [Foo(0, zero), Foo(1, one)] [Foo(0, zero), Foo(1, one)] [Foo(0, zero), Foo(1, one)] ```
issue
shortest paths: use internal nodes#TITLE_END#This implements the changes proposed in #3765 and also adds some more sanity checks.  Regarding the newly introduced function `.get_node` on graphs, you guys probably must decide how to name it and whether you want to make it publicly documented or a dunder method, rename it etc.
