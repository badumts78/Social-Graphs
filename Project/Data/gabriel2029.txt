issue
network_simplex falsely reports negative cycle with infinite capacity#TITLE_END#### Current Behavior  For specific networks, I observe that the `network_simplex` method claims `nx.NetworkXUnbounded("negative cycle with infinite capacity found")`, although this should not be the case. When adding to some edges an arbitrary but high capacity, I obtain a valid result, although the additionally introduced capacities are not exhausted.  After some light debugging, I found out that the condition is checked in the file `networksimplex.py` at: ```python if any(DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count)) or any(     e[-1].get(capacity, inf) == inf and e[-1].get(weight, 0) < 0     for e in nx.selfloop_edges(G, data=True) ):     raise nx.NetworkXUnbounded("negative cycle with infinite capacity found") ``` Here, the problem is ```any(DEAF.edge_flow[i] * 2 >= faux_inf for i in range(DEAF.edge_count))```. As `faux_inf` is calculated with ```python faux_inf = (     3     * max(         chain(             [                 sum(c for c in DEAF.edge_capacities if c < inf),                 sum(abs(w) for w in DEAF.edge_weights),             ],             (abs(d) for d in DEAF.node_demands),         )     )     or 1 ) ``` its result is dependent on the capacity of an edge. So obviously, when the of one edge is increased to a large value, `faux_inf` becomes quite big and the test does not fail anymore.  ### Expected Behavior  The report for a negative cycle with infinite capacity should only happen when this is actually the case, without a need for the workaround specifying an artificial `capacity` value.  ### Steps to Reproduce  I've prepared a small script that (i) creates a network with weights and demands and tries to run the `network_simplex` method and (ii) does the same, but now adds a capacity to two edges. While (i) reports a negative cycle with infinite capacity, (ii) works fine. I'm sorry that the network is quite large but I did not find a smaller one.  ```python import networkx as nx import traceback   def create_graph(with_capacity):     G = nx.DiGraph()      # Add nodes with demands     G.add_node('s0', demand=-89)     G.add_node('s1', demand=-197)     G.add_node('s2', demand=89)     G.add_node('s3', demand=212)     G.add_node('s4', demand=32)     G.add_node('s5', demand=83)     G.add_node('s6', demand=-159)     G.add_node('s7', demand=-68)     G.add_node('s8', demand=116)     G.add_node('s9', demand=120)     G.add_node('s10', demand=-65)     G.add_node('s11', demand=-74)      # Add edges     if with_capacity:         G.add_edge('s0', 's0', weight=1, capacity=10000)         G.add_edge('s0', 's1', weight=1, capacity=10000)     else:         G.add_edge('s0', 's0', weight=1)         G.add_edge('s0', 's1', weight=1)      G.add_edge('s1', 's0', weight=1)     G.add_edge('s1', 's2', weight=1)     G.add_edge('s1', 's3', weight=1)     G.add_edge('s1', 's4', weight=1)     G.add_edge('s10', 's0', weight=1)     G.add_edge('s10', 's10', weight=1)     G.add_edge('s10', 's7', weight=1)     G.add_edge('s11', 's0', weight=1)     G.add_edge('s11', 's11', weight=1)     G.add_edge('s11', 's5', weight=1)     G.add_edge('s11', 's7', weight=1)     G.add_edge('s11', 's9', weight=1)     G.add_edge('s2', 's0', weight=1)     G.add_edge('s2', 's1', weight=1)     G.add_edge('s2', 's2', weight=1)     G.add_edge('s2', 's5', weight=1)     G.add_edge('s3', 's0', weight=1)     G.add_edge('s3', 's1', weight=1)     G.add_edge('s3', 's2', weight=1)     G.add_edge('s3', 's3', weight=1)     G.add_edge('s4', 's0', weight=1)     G.add_edge('s4', 's6', weight=1)     G.add_edge('s4', 's7', weight=1)     G.add_edge('s5', 's0', weight=1)     G.add_edge('s5', 's10', weight=1)     G.add_edge('s5', 's11', weight=1)     G.add_edge('s5', 's8', weight=1)     G.add_edge('s5', 's9', weight=1)     G.add_edge('s6', 's0', weight=1)     G.add_edge('s6', 's10', weight=1)     G.add_edge('s6', 's4', weight=1)     G.add_edge('s6', 's6', weight=1)     G.add_edge('s7', 's0', weight=1)     G.add_edge('s7', 's10', weight=1)     G.add_edge('s7', 's4', weight=1)     G.add_edge('s7', 's6', weight=1)     G.add_edge('s8', 's0', weight=1)     G.add_edge('s8', 's11', weight=1)     G.add_edge('s8', 's8', weight=1)     G.add_edge('s8', 's9', weight=1)     G.add_edge('s9', 's0', weight=1)     G.add_edge('s9', 's11', weight=1)     G.add_edge('s9', 's5', weight=1)     G.add_edge('s9', 's7', weight=1)     G.add_edge('s9', 's8', weight=1)      return G   # Calculate min-cost flow try:     G1 = create_graph(False)     flow_value, flow_dict = nx.network_simplex(G1)  # fails except Exception:     print(traceback.format_exc())  G2 = create_graph(True) flow_value, flow_dict = nx.network_simplex(G2)  # succeeds print(flow_value, flow_dict) ```  ### Environment  Python version: 3.12.4 NetworkX version: 3.3 
