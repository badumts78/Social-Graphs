comment
All of `scipy.sparse.csgraph` is in Cython. A quick look at SciPy's `dijkstra` implementation shows that the core of it is triple-nested loop (`for`-`while`-`for` with some `if`-statements in the inner loop). Doing that in Python would be super slow, independent of data structure. I can't imagine `csr_matrix` in a Python algorithm won't help much.  > I guess I should ask a question: Is it better to have an interface that allows NetworkX algorithms to run on csgraph objects, or to have an interface that allows the csgraph algorithms to work on a NetworkX graph?  I would expect the latter to be easier, and more beneficial performance-wise.  Taking a step back, I'm not sure I understand why you'd consider adding a new interface to run NetwokX algorithms on a `csr_matrix` - _if the reason is performance_. It sounds like doing work and potentially making the UX more confusing, for some limited performance gain. You can't write many of these graph algorithms with their nested loops in Python and expect good performance, it's always going to be 10-100x slower.    On the other hand if we're not talking about performance at all here, and the philosopy is: "people should use `scipy.sparse.csgraph` for whatever it offers, and then when they have their data in `csr_matrix` format but need an algorithm that SciPy doesn't have, then NetworkX offers more" - that would make sense perhaps.  So: maybe you can do both? But I think it would help to start with the goals. There's performance on the one hand, and flexibility of pure Python and breath of algorithms offered on the other hand. Maybe you should split those off into separate topics, because they'll have different answers for "how do we leverage `scipy.sparse`" and are fairly orthogonal.
comment
> it seems like we need a networkx[minimal] a networkx[default] (or maybe recommended?) and a networkx[extras] > ... > And we need pypi to allow options like this is standard `requirements.txt` files (and maybe conda use of requirements files too)  Some context that may be helpful here:  - `requirements.txt` is not a thing PyPI knows about, it's an ad-hoc lock-file-type-thing that gets turned into something `setuptools`-specific. It works with `pip install networkx` only because in your `setup.py` file you have: ``` install_requires = parse_requirements_file("requirements/default.txt") extras_require = {     dep: parse_requirements_file("requirements/" + dep + ".txt")     for dep in ["developer", "doc", "extra", "test"] } ```  - Pip does know how to install `setuptools`-style extras: https://pip.pypa.io/en/stable/cli/pip_install/?highlight=extras#examples. It's not a standard though, and not all installers may support it. - `conda` does not have this feature. It will let a package author give constraints for optional dependencies with [`run_constrained`](https://docs.conda.io/projects/conda-build/en/latest/resources/define-metadata.html#run-constrained) in `metadata.yaml`, but there's no way to tell conda "install all optional dependencies". - The future proper way to implement optional dependencies is in `pyproject.toml`: https://www.python.org/dev/peps/pep-0621/#dependencies-optional-dependencies. Installers are in the process of implementing support for this. - Either way, there is no support for _subtracting_ dependencies, so `networkx[minimal]` cannot be a thing. There are only "dependencies" and "optional dependencies". There may be multiple sets of optional dependencies, like `[test]`, `[dev]`, `[extras]`. But if you want your default to be heavier and also offer a minimal version, you should publish the latter as a separate package like `networkx-minimal`.    
