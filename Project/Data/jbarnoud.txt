issue
Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated#TITLE_END#Running code that depends on networkx with the upcoming python 3.8 yields the following warnings:  ``` /coarse/jon/Envs/pygit/lib/python3.8/site-packages/networkx/classes/graph.py:23: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working   from collections import Mapping  /coarse/jon/Envs/pygit/lib/python3.8/site-packages/networkx/classes/reportviews.py:95: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working   from collections import Mapping, Set, Iterable ```  The abstract syntax classes are in the `collections.abc` module since python 3.3. Python 2.7 still defines them directly in the `collections` module.
issue
Import ABCs from collections.abc#TITLE_END#Importing Abstract Base Classes directly from the collections module is deprecated in python 3.8 in favour of the collections.abc module. Importing from collections is the only option on python 2.7, though.  This PR tries to import ABCs from collections.abc, and fallback to collections in case of failure.  Fixes #3170
issue
`OrderedGraph.subgraph` does not maintain the order of the nodes#TITLE_END#A subgraph built from a `OrderedGraph` should keep the order of the nodes, yet nodes in the subgraph are neither in the order of the initial graph, nor in the order of the selection. The issue can be seen from the following snippet:  ```python graph = nx.OrderedGraph() nodes = list(range(10)) random.shuffle(nodes) graph.add_nodes_from(nodes)  # key order is (7, 2, 1, 9, 0, 8, 6, 4, 3, 5)  # We create a selection in the same order as the initial graph keys to_keep = [key for key in graph if key % 2 == 0]  # [2, 0, 8, 6, 4] subgraph = graph.subgraph(to_keep)  # (0, 2, 4, 6, 8)  # We create a selection in a different order subgraph = graph.subgraph([5, 3, 1])  # (1, 3, 5) ```  From what I see, the issue is due to `Graph.subgraph` passing the selection to `nx.filters.show_nodes` that transforms it to a set. The nodes in the subgraph are then in the order of the set; as sets do not preserve the order, the order of the initial graph if not preserved.
issue
Avoid loosing the order of the nodes in subraphs#TITLE_END#* Make sure the tests catch the issue. The order of the nodes was   already tested for subgraphs of OrderGraph. However, the nodes in the   reference were sorted integer; as the faulty behavior was happened to   be sorting the keys, the issue was not reported. * Fix `classes.filters.show_nodes` to keep the order of the selection.  Fixes #2911
comment
Are the correct steps for subclassing a graph documented somewhere? The pages for each type of graph has a section on subclassing, but it does not mention `fresh_copy`.  What would be the steps to follow to have a subclass of `Graph` that does not have its method revert back to the parent class? From a quick look at the code I see that I would need to: * write a new version of `graphviews.SubGraph`, and `graphviews.GraphView` to subgraph the orrect class; * overwrite `G.fresh_copy`; * overwrite `G.subgraph` to return the new `SubGraph`; * overwrite `G.copy` to return the new `GraphView` when the "as_view" argument is `True`;  Am I missing something? Could the classes to use as `SubGraph` and `GraphView` be class attributes in the way `node_dict_factory` is? This would allow avoid to rewrite `G.subgraph` and `G.copy`.
comment
The problem I see with the views is that they inherit from a specific graph class. Even if the graph logic is untouched in the subclass, the subclassing itself is lost with the view. One demonstration of this is to make a copy of a view, even with the existing subclasses:  ```python graph = nx.OrderedGraph()  # OrderedGraph graph.add_nodes_from(range(10)) subgraph = graph.subgraph([2, 3, 4])  # SubGraph graph_copy = subgraph.copy()  # Graph ```  In the example above, we expect `graph_copy` to be an instance of the same class as `graph`, but because `SubGraph` subclasses `Graph` and not `OrderedGraph`, `graph_copy` is an instance of `Graph`.  The same goes for `GraphView` for the same reasons:  ```python graph = nx.OrderedGraph()  # OrderedGraph graph.add_nodes_from(range(10)) graph_view = graph.copy(as_view=True)  # GraphView graph_copy = graph_view.copy()  # Graph ```  Finally, for the same reason, views do not make available the additional method a subclass may have:  ```python class MyGraph(nx.Graph):     def my_method(self):         print('I am a ustom method.')          def fresh_copy(self):         return MyGraph()   graph = MyGraph() graph.add_nodes_from(range(10)) graph.my_method()  graph_view = graph.copy(as_view=True) # graph_view.my_method()  not available  graph_copy = graph_view.copy() # graph_copy.my_method()  not available ```  With the way views are implemented, I do not see an other way than have a custom version of `SubGraph` and `GraphView` for every subclass.  One way around the issue would be to have views not be subclasses, but wrapper that use `__get_attr__` magic to emulate the underlying graph object.
comment
I had a deeper look at the question. My suggestion of having what `SubGraph` and `GraphView` classes declared as class attribute of the graph class cause some cyclic references, and threfore does not work. It implies to reference a class that is not yet declared in the graph object, or to subclass that does not exist yet in the views.  My wrapping suggestion may work, but requires profound changes that are likely not desirable.  I managed some result with a bit of meta programming. In the example bellow, I create a non-functional template for a view class: `MyGraphViewTemplate`. When an instance of a graph is created, the view template is combined with the `ReadOnly` class and the graph class to create a functional view class that subclasses the 3 classes. It is that class that is used in the subsequent method instead of the hard coded class that are used currently.  ```python class MyGraphViewTemplate():     UnionAdj = nx.classes.coreviews.UnionAdjacency      def __init__(self, graph):         if graph.is_multigraph():             msg = 'Wrong View class. Use MultiGraphView.'             raise NetworkXError(msg)         self._graph = graph         self.root_graph = graph         while hasattr(self.root_graph, '_graph'):             self.root_graph = self.root_graph._graph         self.graph = graph.graph         self._node = graph._node         if graph.is_directed():             self._adj = self.UnionAdj(graph._succ, graph._pred)         else:             self._adj = graph._adj   class MyGraph4(nx.Graph):     view_factory_template = MyGraphViewTemplate          def __init__(self, incoming_graph_data=None, **attr):         super().__init__(incoming_graph_data, **attr)         self._view_factory = type(             '{}View'.format(self.__class__.__name__),  # name             (self.view_factory_template,  # base classes              nx.classes.coreviews.ReadOnlyGraph,              self.__class__),             {}  # class attributes         )      def my_method(self):         print('I am a custom method.')          def fresh_copy(self):         return MyGraph4()          def copy(self, as_view=False):         if as_view is True:             return self._view_factory(self)         G = self.fresh_copy()         G.graph.update(self.graph)         G.add_nodes_from((n, d.copy()) for n, d in self._node.items())         G.add_edges_from((u, v, datadict.copy())                          for u, nbrs in self._adj.items()                          for v, datadict in nbrs.items())         return G   graph = MyGraph4()  # MyGraph4 graph.add_nodes_from(range(10)) graph.my_method()  graph_view = graph.copy(as_view=True)  # MyGraph4View created for that instance of MyGraph4 graph_view.my_method() print(type(graph_view))  graph_copy = graph_view.copy()  # MyGraph4 graph_copy.my_method() ```  In this example, the creation of the view class from the template is done in the `__init__` of `MyGraph4`. Ideally, it should be in the `__init__` of `nx.Graph` instead, so that all the subclasses can benefit from it.  This approach should be as flexible as what is used currently. A type of graph that needs to change the logic of the view can define a new template and declare it with the `view_factory_template` class attribute.  One thing that is not ideal is that a view class is created for each instance. It may be fixed by using a metaclass that would create the view class only once per subclass.  The main point of the approach is that it streamlines the subclassing. In the example above I had to include quite some code in `MyGraph4` to implement the new logic, but subclassing from it looks like:  ```python class MyGraph5(MyGraph4):     def my_method_from_5(self):         print('I am an **other** custom method!')          def fresh_copy(self):         return MyGraph5()   graph = MyGraph5() graph.add_nodes_from(range(10)) graph.my_method() graph.my_method_from_5()  graph_view = graph.copy(as_view=True) graph_view.my_method() graph_view.my_method_from_5() print(type(graph_view))  graph_copy = graph_view.copy() graph_copy.my_method() graph_copy.my_method_from_5() ```  If this approach is not deemed to crazy, I can work on a PR to fix the ability to subclass graphs.
