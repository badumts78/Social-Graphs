comment
Hi, I'm the author of graph-tool. thecolourblue posted a message on the graph-tool mailing list, and I responded to him there, but I decided to reproduce the information here as well. In short, I agree that if everyone extends graphml to their needs, it will become a mess. On the other hand the proper way of extending graphml via xml schemas is not only  very cumbersome, it does not really solve much, since it is still necessary for the different programs to agree on the extensions. I decided to include new nonstandard types, since it was much simpler, and I wasn't needing anything exotic, only vectors and a generic (pickled) python object type. If the user wants interoperability, he can simply avoid those types.   Currently the vector types are encoded in graph-tool via comma-delimeted lists. In case of floating types, the values are encoded in the hexadecimal format from C99 to guarantee perfect binary representation. From the printf manpage:  ``` a, A   (C99;  not  in  SUSv2)  For a conversion, the double argument is converted to          hexadecimal notation (using the letters abcdef) in the  style  [-]0xh.hhhhp±;          for  A conversion the prefix 0X, the letters ABCDEF, and the exponent separa‐          tor P is used.  There is one hexadecimal digit before the decimal point,  and          the  number of digits after it is equal to the precision.  The default preci‐          sion suffices for an exact representation of the value if an exact  represen‐          tation  in  base  2 exists and otherwise is sufficiently large to distinguish          values of type double.  The digit before the decimal point is unspecified for          nonnormalized  numbers,  and nonzero but otherwise unspecified for normalized          numbers. ```  I'm not sure if it's possible to parse this automatically from python, other than using ctypes. But writing a simple parser should be straightforward. 
comment
Yes, thecolorblue just pointed out to me as well that the hex/fromhex functions do exactly what is needed. It seems therefore that a Python implementation which is compatible with graph-tool is indeed quite easy.  In graph-tool there is also support for a generic python_object type, which is just a base64 encoded pickled object. You may consider supporting this as well, if you so desire. 
comment
Does the other way around (networkx -> graph-tool) also work properly? 
comment
If graph-tool interprets them a strings, it means they were declared as strings (actually vector_string) in the graphml file... How does the graphml file actually looks like in your example?  Also it seems that  the format is wrong, i.e. the vectors are enclosed with square brackets....  Can you read your own graphml files in networkx without loss? 
comment
It should be possible to fix networkx so that a little introspection is made, and the most appropriate type is set in the graphml file. I guess the problem here is that one has no way of determining if all the values of a list are numeric, other than verifying. I see a couple of options: - Go through all the list values, for all lists, and decide on the least common type - Let the user specify the type explicitly (I don't like this option) - Make some basic rules, such as lists are always vector_strings, but numpy arrays are vector_int/double/long_double  I think I would prefer the last option. In any case the input and output of networkx should be self-consistent, regardless of the interoperability with other software. This means that properties loaded as, say, vector_double should be converted automatically to a numpy array.  In my opinion, a solution which is close to ideal would be to convert only numpy arrays to the vector_\* types, and everything else would be stored as a generic python_object type (a pickle object as a base64 encoded string), the way graph-tool does. In this way, the user can _always_ store _whatever_ data he/she has, without losing a single bit, in a completely consistent manner.  I could provide the implementation for this last bit, if you want.  > My original target was to have one file format to work with several different tools (including boost bgl, graph-tool,  > networkx, gephi and a few others)- graphml is looking bit less likely now. >  > Alternatives are gexf (http://gexf.net/format/) which is supported in networkx, gephi but not graph-tool/boost. > Although this could be possible- there is code available on gexf.net for python/js/java/c++ etc.  I think this issue has nothing to do with the actual format. The problem is simply that since networkx has the pythonic characteristic of being type agnostic with regards to the graph properties, it chokes when it needs to provide a type specification to the file format. However, this type of information is essential for interoperability, and  graphml provides all the necessary support. In fact, gexf is virtually identical to it in this respect, and using it would not change a thing. In fact it makes me wonder why this format exists in the first place... 
comment
Here is an illustration of what I mean, by looking at how graph-tool does things:  ``` python     >>> g  = Graph()     >>> g.add_vertex(2)     <generator object <genexpr> at 0x6c2cb90>     >>> vprop = g.new_vertex_property("long double")     >>> vprop.a = random(2)     >>> oprop = g.new_vertex_property("object")     >>> oprop[g.vertex(0)] = {"foo":2, 4:"bar"}     >>> g.vp["vprop"] = vprop     >>> g.vp["oprop"] = oprop     >>> g.save("test.xml")      >>> g = load_graph("test.xml")     >>> g.vp["oprop"][g.vertex(0)]     {'foo': 2, 4: 'bar'}     >>> g.vp["vprop"].a     PropertyArray([ 0.93101101,  0.17042522], dtype=float128) ```  The generated file test.xml is as follows:  ``` <?xml version="1.0" encoding="UTF-8"?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns"          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"          xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">    <!-- property keys -->   <key id="key0" for="node" attr.name="oprop" attr.type="python_object" />   <key id="key1" for="node" attr.name="vprop" attr.type="double" />    <graph id="G" edgedefault="directed" parse.nodeids="canonical" parse.edgeids="canonical" parse.order="nodesfirst">     <!-- graph properties -->     <!-- vertices -->     <node id="n0">       <data key="key0">gAN9cQAoWAMAAABmb29xAUsCSwRYAwAAAGJhcnECdS4=</data>       <data key="key1">0xf.4a4461681ffd8p-4</data>     </node>     <node id="n1">       <data key="key0">gANOLg==</data>       <data key="key1">0xa.c0681f1a149c8p-4</data>     </node>     <!-- edges -->    </graph> </graphml> ``` 
comment
On the compatibility issue: I don't think it is a problem. You still have perfect compatibility if you use the standard graphml types (int, double, float, string, bool). If you use something else, _only then_ it does not work. But you haven't really _lost_ anything in terms of compatibility. 
comment
Well, this would work, but I think it punts the problem to the user, which I think the library should be able to deal with automatically. Furthermore, this would be inconsistent in the sense that an user could read a graphml file but whenever they are saved again, it would not store the same information which it read in, at least not without passing extra options. I think this would be confusing to the user, and error prone.  I believe the proper way to address this is to implement the code in such a way that, e.g. the question "what should I do if an node/edge property is a list" is answered in a satisfactory way, which means not simply to dump it as a string.  But if you guys find that it would take too much effort to refactor the graphml code, a parameter-based approach could work as an interim solution, until someone decides to improve on it. 
comment
I agree that a specific networkx <-> graph_tool compatibility would be easier to implement without dwelling into graphml, but I think we should aim higher. I think there are two main goals here: 1. Wide interoperability 2. Exact representation of the graph and its metadata  These two goals are connected: I don't think we can fully have 1 if we don't have 2. In graph-tool I have tried (I believe successfully) to solve 2, but I don't think 1 can be really fully solved at the moment, since there are no graph format standards with more than very few basic types (int, double, string, bool). I have tried, therefore, to stick to the most general format I found (graphml) and extend it to cover the more specific cases (lists, and arbitrary python objects via pickle). I did this not only to achieve 2, but also to stay as close as possible to 1. I think it goes pretty much without saying that I think this solution would make sense for networkx as well.  If we agree on a common format which is not intrinsically tied to python, it would be a further incentive for other projects such as Gephi to adopt it as well, so that one day we could achieve goal 1.   I should state, of course, that if you guys find any problems with the way with graph-tool does things, I would also be willing to adapt things on my side (provided it does not affect either goal 1 or 2). 
comment
From what I can see, the GEXF is virtually indistinguishable from graphml in this regard. It only supports the following types: string, integer, float, double, boolean, date, and anyURI.  I also do not think creating a new format is the best idea. I do think, however, that properly extending an existing format is not complicated, and seems the most appropriate approach. 
