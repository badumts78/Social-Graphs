issue
[easy] Add to Contributor List#TITLE_END#As title, add myself to the contributor list #4842.   
issue
bugfix-for-issue-4353: modify default edge_id format#TITLE_END#The issue is about failing to preserve edge global uniqueness while calling `write_graphml()` in MultiGraph format with the `keys` field.  My idea is to write the edge_id in `id = (src, dest, key)` format, instead of `id = key`. While selecting one of the edge attributes to be the edge_id might be viable, it would cause the loss of local uniqueness when reading the graphML.   This is the first time that I open a pull request in this project. Happy to discuss the issue with the contributors.
comment
Hi, @rossbar. I am new to networkx community and interested in tackling this issue. Should I focus on adding texts to the example or focus more on finding other parallel alternatives? Thank you.  
comment
Hi,  I am interested in this issue and #4347. I have read the [document](http://graphml.graphdrawing.org/primer/graphml-primer.html#GraphEdge) of graphml that the edge `id` is an optional field.   > 2.3.3 Declaring an Edge > Optionally an identifier for the edge can be specified with the XML Attribute id. When it is necessary to reference the edge, the id XML-Attribute is used.  It seems to me that the Multi(Di)Graph edge `key` value and any edge attributes in networkx are not strong enough to enforce uniqueness across the whole graph for the use case of Gephi.  Also, to preserve the original `key` value (edge uniqueness within multi-edges) in graphml, the first thought in my mind is  to generate a new `id` (e.g. use a delimiter `id = "a_b_0"`, where `a` is the source, `b` is the target, and `0` is edge key) while writing edge information in graphml format and parse it later while reading the file, instead of only using edge `key` to represent `id` value. I am not sure whether it is a good idea. I am happy to discuss this issue further. ```python import networkx as nx G = nx.MultiDiGraph(((0, 1, 0), (0, 1, 1), (1, 2, 0), (2, 0, 0))) nx.write_graphml(G, './test.graphml') ``` ```xml <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">.    <graph edgedefault="directed"><node id="0"/>     <node id="1"/>     <node id="2"/>     <edge id="0_1_0" source="0" target="1"/>     <edge id="0_1_1" source="0" target="1"/>     <edge id="1_2_0" source="1" target="2"/>     <edge id="2_0_0" source="2" target="0"/>   </graph> </graphml> ``` 
comment
Using the format, `"(node1, node2, key)"`, sounds like a good idea.  I am thinking about adding a new input argument (e.g. edge_id) into `networkx.write_graphml()` and `networkx.generate_graphml()` to allow users to specify an edge attribute. If the argument is not specified, perhaps, we could set the `id` with `"(node1, node2, key)"` format.  My thought is like below ```python import networkx as nx G = nx.MultiDiGraph(((0, 1, 0, {'eid': 1}), (0, 1, 1, {'eid': 2}), (1, 2, 0, {'eid': 3}), (2, 0, 0, {'eid': 4}))) nx.write_graphml(G=G, path='./test.graphml', edge_id='eid') ``` Expected output ```xml <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">.    <key attr.name="eid" attr.type="long" for="edge" id="d0"/>   <graph edgedefault="directed"><node id="0"/>     <node id="1"/>     <node id="2"/>     <edge id="1" source="0" target="1">       <data key="d0">1</data>     </edge>     <edge id="2" source="0" target="1">       <data key="d0">2</data>     </edge>     <edge id="3" source="1" target="2">       <data key="d0">3</data>     </edge>     <edge id="4" source="2" target="0">       <data key="d0">4</data>     </edge>   </graph> </graphml> ``` However, one issue I encountered is when I call `read_graphml()` later, the original `key` information (multi-edge uniquess) is missed.   ```python G = nx.read_graphml('./test.graphml') print(G.edges(keys=True, data=True)) #output [('0', '1', 1, {'eid': 1}), ('0', '1', 2, {'eid': 2}), ('1', '2', 3, {'eid': 3}), ('2', '0', 4, {'eid': 4})] ```
comment
This issue has been resolved in #4842 and should be closed. 
comment
It is a tricky issue depending on the input graph when the `source` parameter is `None`. But it doesn't make sense to output all unreachable edges even if the source is arbitrarily assigned. https://github.com/networkx/networkx/blob/b442619bd60651574b733e06af79d8da17c93254/networkx/algorithms/traversal/depth_first_search.py#L46-L49  The example below also returns part of the edges. I think the best way is to set the `source` parameter to get desired results. Open for further discussions. ```python >>> g = nx.DiGraph() >>> g.add_edges_from([(1, 2), (0, 1)]) >>> list(nx.dfs_edges(g, source=1)) [(1, 2)] ```
comment
Hi @rossbar. The [original code](https://github.com/networkx/networkx/blob/9aee8ef9739913ebd1e34b1be97cd91a7d6cc520/networkx/convert.py#L263) in convert.py directly replace **edge_data** with original edge attributes. When the input is multiGraph, it is natural that we lose the multi-edge information.  ``` python # original version # edge_data is not None for u, nbrdict in G.adjacency():     dod[u] = dod.fromkeys(nbrdict, edge_data) ```  I think the naive method to solve this issue is to consider Single-Graph and Multi-Graphs separately. We should keep different edge keys in MultiGraphs, like the modifications below.  Hope to get any feedback or good ideas. Thank you.  ``` python # revised version draft # edge_data is not None for u, nbrdict in G.adjacency():     if 'Multi' in nx.info(G).split("\n", 2)[1]: # multi-graphs         udict = {}         for nbr, edgedict in nbrdict.items():             udict[nbr] = dict.fromkeys(edgedict, edge_data)         dod[u] = udict     else: # single graph         dod[u] = dod.fromkeys(nbrdict, edge_data) ```
