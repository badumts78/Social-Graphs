issue
weird behaviour with node removal/counting#TITLE_END#Hi,  thereÂ seems to be something weird with `g.number_of_nodes` or `g.remove_nodes_from`:  as you can see from the screenshot, I get sometimes that the difference is not = N removed nodes  ``` g = nx.fast_gnp_random_graph(1000, 0.1) nx.is_connected(g)  removes_N = 10 print('init. N. nodes', g.number_of_nodes())  for i in range(int(g.number_of_nodes() / removes_N)):      nn_1 = g.number_of_nodes()      # select nodes to remove     removed_nodes = np.random.choice(g.nodes(), removes_N)      # remove selected nodes     g.remove_nodes_from(removed_nodes)      # double check     nn_2 = g.number_of_nodes()      if nn_1 - nn_2 != len(removed_nodes):         print(nn_1 - nn_2, removed_nodes)         print([my_node for my_node in removed_nodes if my_node in g.nodes()]) ```  <img width="994" alt="Screenshot 2020-05-12 at 13 31 18" src="https://user-images.githubusercontent.com/15370425/81682184-fbbf3f80-9454-11ea-850f-c6508ee99848.png">  (this might be related to #3943 )   Thanks for your help!  ps: on Version: 2.4 / python3.7 
issue
zerodivisionerror by rich_club_coefficient #TITLE_END#Hi,   I just run  `rich_club_coefficient` on a network generated with `erdos_renyi_graph` and I get this error (no idea why)...and I was wondering if this is a bug -- or I did something wrong  Thanks  ![Screenshot 2019-08-14 at 12 46 05](https://user-images.githubusercontent.com/15370425/63019127-d045ff00-be9a-11e9-9b8b-087c871a846f.png) 
issue
Trivial issue with neighbors#TITLE_END#Hi,  thanks for the nice module.  I am having however a basic issue (maybe related to the latest update? - 2.0) with degree and neighbours - or maybe I am doing something trivially wrong - please, see the screenshot  Thanks for your help  (I am on python 3.6 - networkx 2.0)  <img width="1085" alt="screen shot 2017-12-18 at 19 15 19" src="https://user-images.githubusercontent.com/15370425/34121051-0d2f3e12-e428-11e7-8ab1-b2f9c1ee52c9.png">
comment
> I'm assuming you want the longest shortest-path rather than the longest path.... :) > The eccentricity and diameter functions have an argument `sp=` which allows you to provide all-pairs-shortest-path-lengths as a dictionary. So if you need weighted paths, first use `sp=dict(all_pairs_shortest_path_length(G, weight='attrname'))` then send that to the eccentricity function. >  > By the way, eccentricity doesn't provide the source and target vertices of that path. Best way to get that is to loop over the `sp` dict-of-dict-of-lengths looking for the max and storing that length, source and target as you go.  a little update for ppl using updated v. of nx:  * if you want  _weighted_ paths, you have to use now [`all_pairs_dijkstra_path_length` ](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.all_pairs_dijkstra_path_length.html#networkx.algorithms.shortest_paths.weighted.all_pairs_dijkstra_path_length) (or [bellman-ford algo](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.all_pairs_bellman_ford_path_length.html#networkx.algorithms.shortest_paths.weighted.all_pairs_bellman_ford_path_length) ),  as `all_pairs_shortest_path_length` does not accept weights anylonger * `diameter` does not accept anylonger the  `sp` parameter, while `eccentricity` still does -- hence we you have to pre-compute  eccentricities 
