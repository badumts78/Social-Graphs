issue
Closeness Centrality reports inverse maybe un-intuitive values#TITLE_END#Acc to network x: Closeness centrality at a node is 1/average distance to all other nodes.  As defined by Freeman (1979), a nodeâ€™s closeness centrality is the sum of graph-theoretic distances from all other nodes, where the distance from a node to another is defined as the length (in links) of the shortest path from one to the other.  Shouldn't we use Freemans definition? Or is it that we use the 1/ factor to normalize it? 
issue
Betweeness centrality for only one node#TITLE_END#In a rather big graph (20k) I want to compute the betweenness centrality only for one node, but as other algorithms allow to specify a node (v=Node) betweenness centrality does not. Since the computation is expensive it seems like a waste to compute all values when one needs only one. Is there a way to accomplish this?  One way around could be to use the nx.load_centrality, which allows to specify a node, but in my network the command   <pre> node = "CPA_Trendlines" nx.load_centrality(AT_all,v=node)  </pre>   results in an error:  <pre> Traceback (most recent call last):   File "individual_bridging_2.py", line 143, in <module>       File "individual_bridging_2.py", line 109, in main     dFF_bin_pagerank = nx.pagerank(S_FF, weight="weight")        File "/usr/local/lib/python2.7/dist-packages/networkx-1.6-py2.7.egg/networkx/algorithms/centrality/load.py", line 67, in newman_betweenness_centrality     betweenness+=ubetween[v] KeyError: 'CPA_Trendlines' </pre>   Here is how to read in my network:  <pre> AT_all = nx.read_edgelist('data/networks/%s_solr_AT.edgelist' % project, nodetype=str, data=(('weight',float),),create_using=nx.DiGraph())  </pre>  and this is the link to the network to reproduce it: <a href="http://www.filefactory.com/file/4aiqa8lim9x7/n/584_solr_AT_edgelist">584_solr_AT_edgelist</a> 
