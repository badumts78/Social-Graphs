issue
Sparse Spanners using Baswana-Sen#TITLE_END#As discussed in #1609, I implemented the spanner algorithm of Baswana and Sen (see [1]) while looking into graph sparsification. I cleaned up the code for this pull request. Please let me know if you have any comments or suggestions!  I have a couple of questions:  1. The algorithm is randomized. Is there any specific way I have to set up the random number generator or can I assume that it has already been properly seeded? 2. Since the algorithm is randomized, some parts are not always executed (one line, to be specific: the "continue" in Line 151 of spanner.py). This means that the tests sometimes do not cover this line. Is there anything I should do about this? 3. The unit tests are quite extensive and take somewhere between 3-4 seconds to finish on my machine. Should I use smaller graphs in the tests?  [1] S. Baswana, S. Sen. A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs. Random Struct. Algorithms 30(4): 532-563 (2007).
issue
Double import#TITLE_END#I noticed that in `networkx/algorithms/__init__.py`the statement `from networkx.algorithms.triads import *` occurs twice. Is there any reason for this or is this just a blunder?
issue
Raise ValueError when empty list is passed to functions in all.py, fixes #2973#TITLE_END#I raise a ValueError when any of the functions in all.py (i.e., union_all, disjoint_union_all, compose_all, and intersection_all) receives an empty list as an argument.  Fixes #2973.
comment
There is a (relatively) simple algorithm due to Fung, Hariharan, and Harvey (see Theorem 1.3 in [1]) for computing cut sparsifiers in undirected graphs. While this only provides cut sparsifiers and not spectral sparsifiers, it would be a first step towards supporting sparsifiers at all. If this is of any relevance to the project, I would be interested in taking a shot at implementing the algorithm.  [1] https://users.cs.duke.edu/~debmalya/papers/stoc11-sparsification.pdf
comment
I dug further into the problem of computing cut-sparsifiers. I have the basic algorithm mentioned in my previous post implemented and I could continue to implement the more advanced algorithm (Theorem 1.4 in the paper). However, I ran into the following problem: For both algorithms, the constants in the O-notation are pretty high. As a consequence, the algorithms only make sense on quite dense and large graphs. As an example, the more advanced algorithm immediately returns the original graph if m <= 2028 / (0.38 * epsion^2) * n ln(n). Here, n is the number of nodes, m is the number of edges, and epsilon is the approximation factor (the weight of a cut in the sparsifier is (1 +- epsilon) times the weight in the original graph). Only when the number of edges surpasses this threshold can the algorithm actually achieve sparsification.  Any opinions on how to proceed? Are people actually using networkx on graphs big enough to justify the work necessary to implement the algorithm?
comment
I looked a bit at the paper of Koutis and Xu. Their algorithm seems to exhibit a similar problem: Assuming I use Baswana-Sen-spanners for the spanner construction required for the algorithm, we get m > 96 * n * log^3(n) / epsilon^2 as a cutoff before the algorithm removes any edges. So for a 1% error, we need at least tens of millions of nodes.  At this point, I think I will leave this issue unresolved. Maybe someone else is interested in working on it. One useful thing that came out of my efforts is an implementation of Baswana and Sen's algorithm for spanner construction (see [1]) that seems to work well. If this is interesting for the project, I'd be happy to clean up the code and submit a pull request.  [1] http://www.cse.iitd.ernet.in/~ssen/journals/randstruc.pdf
comment
I would also be interested to help out on this issue, but Mohammed was quicker. :) Are there any other issues on this project a new-comer to open source development could tackle?
comment
I will take a shot at it if it's still open after the weekend. :)
comment
I submitted a pull-request (see #3072) for this issue. I also raise a ValueError when any of the other functions in all.py  (i.e., union_all, disjoint_union_all, compose_all, and intersection_all) receives an empty list as an argument.
