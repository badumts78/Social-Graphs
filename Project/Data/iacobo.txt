issue
Implemented Euler Path functions#TITLE_END#Added functions to check if a graph has an Euler Path, whether it is semi Eulerian, and to return an Euler Path if one exists.  Also adds initial test cases for new functions.  Supersedes previous similar (closed) pull requests #1878 and #1488. See comment [here](https://github.com/networkx/networkx/pull/1878#issuecomment-485263242).  To do: a function implementing the [BEST theorem](https://en.wikipedia.org/wiki/BEST_theorem) to return _all_ Euler Paths (for a directed graph).
comment
@dschult This function doesn't appear to be designed to find _all_ eulerian paths (which is [exponential in number of nodes](https://stackoverflow.com/questions/23539313/how-to-find-all-eulerian-paths-in-directed-graph) for an undirected graph), but return one of them, if one such exists.  The issue in the algorithm is two conditionals in the `is_semieulerian()` (line 204) and `eulerian_path()` (line 337) functions:  ```python     if not start:         return False ```  If the start vertex is the integer `0` (as in your examples), this will return `False`. To make the code work, we must change the lines to:  ```python     if start is None or start is False:         return False ```  The tests the author had included only tested examples with alphabetical node values (and they presumably only worked on such examples since the impetus for writing this was a bioinformatics output i.e. an alphabet of ATGC) hence this was missed.  That said the code has additional issues (e.g. checking for size of `check_odd` *before* incrementing it - this misses the edge cases where you have a third 'odd' vertex, but it's the last one in the loop) and furthermore, since the code on which this is based (`eulerian_circuit()`) itself has been heavily refactored in the past year, if we want to include a function to return an arbitrary Eulerian path it might be worth rewriting the whole thing to match the style.  This looks like it could easily be done by:  1. Adding a `has_eulerian_path` / `is_semieulerian()` function 2. Adding a `_find_path_start()` function (if adapting the code in this pull request, take care to reverse the `first`/`second` return values in this function since the updated code reverses directed graphs and deals with out-edges, not in-edges as previously). 3. Make a copy of `eulerian_circuit()` checking for for semi-Eulerian condition instead of Eulerian, and taking `_find_path_start(G)` as `source`.       - If we wanted to we could incorporate this into `eulerian_circuit()` itself adding another argument as a flag for circuit/path (with circuit as default for backwards compatibility), as opposed to effectively writing the function twice.  Something like this should work (note: I haven't yet tested it fully):  ```python from ..utils import arbitrary_element  def is_semieulerian(G):     """Return True iff `G` is semi-Eulerian.     A graph is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.     """     return has_eulerian_path(G) and not is_eulerian(G)  def has_eulerian_path(G):     """Return True iff `G` has an Eulerian path.     An Eulerian path is a path in a graph which uses each edge of a graph     exactly once.          A directed graph has an Eulerian path if and only if:         - at most one vertex has (out-degree) − (in-degree) = 1,          - at most one vertex has (in-degree) − (out-degree) = 1,          - every other vertex has equal in-degree and out-degree,          - and all of its vertices with nonzero degree belong to a          - single connected component of the underlying undirected graph.          An undirected graph has an Eulerian path if and only if:         - exactly zero or two vertices have odd degree,         - and all of its vertices with nonzero degree belong to a         - single connected component.     """     if G.is_directed():         semibalanced_ins = sum(G.in_degree(v) - G.out_degree(v) == 1 for v in G)         semibalanced_outs = sum(G.out_degree(v) - G.in_degree(v) == 1 for v in G)         return (semibalanced_ins <= 1 and                  semibalanced_outs <= 1 and                 sum(G.in_degree(v) != G.out_degree(v) for v in G) <= 2 and                 nx.is_weakly_connected(G))      else:         return (sum(d % 2 == 1 for v, d in G.degree()) in (0,2)                 and nx.is_connected(G))  def _find_path_start(G):     """Return a suitable starting vertex for Eulerian path.     If no path exists, return None.     """     if not has_eulerian_path(G):         return None              if is_eulerian(G):         return arbitrary_element(G)      if G.is_directed():         v1, v2 = [v for v in G if G.in_degree(v) != G.out_degree(v)]         # Determines which is the 'start' node (as opposed to the 'end')         if G.out_degree(v1) > G.in_degree(v1):             return v1         else:             return v2      else:         # In an undirected graph randomly choose one of the possibilities         start = [v for v in G if G.degree(v) % 2 != 0][0]         return start               def eulerian_path(G, source=None, keys=False):     """Return an iterator over the edges of an Eulerian path in `G`.     """     if not has_eulerian_path(G):         raise nx.NetworkXError("Graph has no Eulerian paths.")     if G.is_directed():         G = G.reverse()     else:         G = G.copy()     if source is None:         source = _find_path_start(G)     if G.is_multigraph():         for u, v, k in _multigraph_eulerian_circuit(G, source):             if keys:                 yield u, v, k             else:                 yield u, v     else:         for u, v in _simplegraph_eulerian_circuit(G, source):             yield u, v ```  Note the mathematical definition of *semi Eulerian* (at least as far as I've seen it used in the literature) is slightly different from the code in this pull request.
