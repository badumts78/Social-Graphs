issue
ISMAGS trips AssertionError for specific symmetry patterns#TITLE_END#There is an error in the ISMAGS implementation. For some specific cases it trips an AssertionError. This happens for graphs of this shape, where all nodes and edges are equivalent. ``` 5 - 4 \     / 12 - 13        0 - 3 9 - 8 /     \ 16 - 17 ```  During symmetry detection/analysis, nodes 0 and 3 are coupled and no longer equivalent. At that point {4, 8} and {12, 16} are no longer equivalent, and neither are {5, 9} and {13, 17}. Coupling 4 and refinement results in 5 and 9 getting their own partitions, *but not 13 and 17*. This results in tripping the `assert` on line https://github.com/networkx/networkx/blob/main/networkx/algorithms/isomorphism/ismags.py#L1080.  The good news is that this case cannot result in new symmetries, so it can be safely changed to an `if: return [], cosets`.  This fix is in https://github.com/marrink-lab/vermouth-martinize/commit/d5be20bb17992eaef3b34484d2b3dd7097e1c51c (with testcase), but I don't have the time to turn that into a PR at the moment... 
issue
Implement ISMAGS subgraph isomorphism algorithm#TITLE_END#Hi all!  As discussed some time ago in #3216 I made a Python implementation of the ISMAGS algorithm [1]. I'm not connected to the original developers/authors of the paper in any way. The algorithm takes symmetries in the subgraph into account and only produces symmetry unique isomorphisms. I also needed to find all largest common induced subgraphs exploiting symmetry in the same way, so that's added as well. I realize it's a lot of code to review, so take your time, and please comment on things that need to change :). This code has originally been made for (and merged in) https://github.com/marrink-lab/vermouth-martinize/ but none of us really knows graph theory so I may have walked into some pitfalls...  Fixes #3216   [1] https://doi.org/10.1371/journal.pone.0097896
issue
ISMAGS subgraph isomorphism algorithm#TITLE_END#Hi all,  First off, thanks for the library; I make heavy use of networkx, and it always seems to have the tools I need already implemented.  Recently however, this was not the case ( :'( ). I work with molecules which to a layman can be described as highly symmetric graphs, and I needed to find subgraph isomorphisms. When using the available VF2 algorithm, this caused a combinatorial explosion of equivalent isomorphisms wrecking performance.  As a result I had to implement the ISMAGS (Index-based Subgraph Matching Algorithm with General Symmetries) [1]. This algorithm find all subgraph isomorphisms that are not symmetrically equivalent. I'm still in the progress of polishing and cleaning, but do you think this would make a nice addition to networkx? If so, I'd be more than happy to open a PR.  [1] https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0097896
issue
[Feature request] Graph fingerprinting#TITLE_END#Hi all,  for my work I need to create graph fingerprints.  I'm thinking of ECFP [1] (extended connectivity fingerprint, a Morgan type circular fingerprint) in particular, but I think other variants such as MACCS, LINGO, Path and Tree will also be valuable additions.  [1] https://pubs.acs.org/doi/abs/10.1021/ci100050t https://docs.eyesopen.com/toolkits/python/graphsimtk/fingerprint.html 
issue
Blockmodel with incomplete/partial partitions#TITLE_END#Hi all,  This is part question, part easy improvement suggestion. Currently, if I want to make a blockmodel of my graph I have to assign every node to a partition:  ``` G = nx.path_graph(6) partition = [[0, 1, 2], [3, 4, 5]] M = nx.blockmodel(G, partition) ```  Is it desirable to be able to provide incomplete partitions?  ``` G = nx.path_graph(6) partition = [[0, 1], [4, 5]] M = nx.blockmodel(G, partition) ```  This would generate a disjoint graph, but I don't think this is really an issue (but I'm not well versed in graph theory).  Currently, in version 1.11, if I try this it gives me a `KeyError` which can be easily fixed/circumvented by either a check or a `try`/`except` in `networkx/algorithms/block.py` around lines 100 and 101.  What's your thoughts on this? I'd be happy to make a PR.
comment
Oops :) Sorry about that. I'll leave it up to you whether it's valuable to keep `analyze_symmetry` public. Either way, the docstring as-is is indeed wrong/insufficient.  Maybe: ``` def analyze_symmetry(self, graph, node_partitions, edge_colors):     """         Find a minimal set of permutations and corresponding co-sets that         describe the symmetry of `graph`, given the node and edge equalities     given by `node_partitions` and `edge_colors`, respectively.      Parameters     ----------     graph: networkx.Graph         The graph whose symmetry should be analyzed     node_partitions: list[set]         A list of sets containing node keys. Node keys in the same set are         considered equivalent. Every node keys in `graph` should be in exactly         one of the sets. If all nodes are equivalent, this should be `[set(graph.nodes)]`         See also: :func:`make_partitions`.     edge_colors: dict[collections.abc.Hashable, collections.abc.Hashable]         A dict mapping every edge in `graph` as tuple of node keys (e.g. `(n1, n2)`)         to a "color" (usually an integer). Edges with the same color are considered         equivalent. If all edges are equivalent, this should be `{e: 0 for e in graph.edges}`.         See also: :func:`partition_to_color`.      Returns         -------         set[frozenset]              The found permutations. This is a set of frozensets of pairs of node              keys which can be exchanged without changing :attr:`subgraph`.      dict[collections.abc.Hashable, set[collections.abc.Hashable]]                     The found co-sets. The co-sets is a dictionary of {node key:         set of node keys}. Every key-value pair describes which `values`           can be interchanged without changing nodes less than `key`.            """ ``` ?  It may also be an idea to simplify this a little bit by making it accept edge_partitions instead of edge_colors, but again, I'll leave that up to you. Unfortunately I don't have the time to open a PR for this :( I also found a bug in my ISMAGS implementation (with fix), but I'll open a separate issue (#4915) for that.
