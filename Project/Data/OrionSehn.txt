comment
I understand that the papers say just to remove edges. Without having read through the entirety of this I had over an afternoon had gone ahead and implemented an approach similar to Dan's earlier suggestion: https://github.com/networkx/networkx/pull/7136#discussion_r1435371067  ```python  def _remove_nonterminal_leaves(G, terminals):     terminals_set = set(terminals)     degree_one_nodes = {n for n in G if G.degree(n) == 1}     nonterminal_leaves = degree_one_nodes - terminals_set     while nonterminal_leaves:         possible_nonterminal_leaves = set()         for n in nonterminal_leaves:             possible_nonterminal_leaves = possible_nonterminal_leaves | set(                 G.neighbors(n)             )         G.remove_nodes_from(nonterminal_leaves)         nonterminal_leaves = {             leaf for leaf in possible_nonterminal_leaves if G.degree(leaf) == 1         } - terminals_set ```  This is implemented here: https://github.com/networkx/networkx/pull/7422  This approach is slightly different, because once you remove a single degree node, its only the neighbors that you'd need to check to see if the removal of that single degree node would result in additional zero degree nodes, which would mean you have to check the degrees far fewer times in the case of a leaf being made by trimming a leaf.   The only operations that are run after this function are to get a subgraph of the original with whatever edges are specified by this copy of the graph, and removing the nodes removes the single attached edge of this copy.    Why we can't just remove nodes in that copy of the graph, as we only return the edges one line later for both options. Those additional empty nodes wouldn't exist for a line single line beyond this function.  ![image](https://github.com/networkx/networkx/assets/97123736/1629ca87-cbf7-40ed-98a5-c72ca0b8fc30)   
comment
confirmed I closed this issue last year
comment
> This approach makes sense to me and the test adequately demonstrates the problem with the current implementation (i.e. non-terminal nodes along a path become terminal with subsequent removals). >  > There are potential "gotchas" related to this approach implicitly assuming that leaf nodes have degree one. This may not always be true: two cases I can think of are 1) graphs with self-loop edges (see example) and 2) MultGraphs with multi-edges. >  > ```python > # Desired behavior > >>> G = nx.path_graph(10) > >>> _remove_nonterminal_nodes(G, [4, 5, 6]) > >>> list(G) > [4, 5, 6] > >>> H = nx.path_graph(10) > >>> H.add_edge(9, 9)  # self-loop on one terminal node > >>> _remove_nonterminal_edges(G, [4, 5, 6]) > >>> list(G) > [4, 5, 6, 7, 8, 9] > ``` >  > Since this function is only to be used in the context of the steiner_tree approximations, these may be fine - but it's worth double-checking how steiner_tree handles these cases to make sure the `_remove_nonterminal_leaves` gives consistent results for these cases!  Hey @rossbar, I was able to handle both of these cases that you've brought up! It does end up being a little slower than what I had written in April, but does handle both the self looped case and the multigraph case as expected. I've added a few extra tests to make it clear that this behaves successfully. Hopefully its sensible enough how this works just by looking at it.   Thank you so much for your very thoughtful comments and contributions.   Lemme know if there's other things we should consider.
comment
@rossbar   Thank you for your review, your code is much much more readable. I added an extra few words to clarify the problem this resolves slightly further.   I also fixed a super minor style issue with your submission  Thanks for all your help on this.  Orion 
comment
Happy to help! Glad we could get her sorted!
