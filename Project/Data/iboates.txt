issue
geopandas GeoDataFrame support#TITLE_END#This PR is not expected to be merged but is rather a place to get feedback on implementation of geopandas GeoDataFrames as suggested in https://github.com/networkx/networkx/issues/3932  I have made a humble initial addition which piggybacks off the existing [`from_pandas_edgelist`](https://github.com/networkx/networkx/blob/9b02800087d6a400ce84f9e44a15eee41c27c4dd/networkx/convert_matrix.py#L193) functionality, as well as a few initial tests to verify that it is in fact creating Graph and DiGraph objects  It was not hard to implement this so I am encouraged to continue developing it. In my opinion this could completely usurp the [current shapefile I/O functionality](https://github.com/networkx/networkx/blob/9b02800087d6a400ce84f9e44a15eee41c27c4dd/networkx/readwrite/nx_shp.py). I offer the following advantages to this approach:  1. It allows for NX users to load any geospatial data format (shapefile or one of the many other alternatives) with a well-established, pandas-like library and go directly to a NX graph with little effort. 2. File I/O is handled by geopandas, which leverages other libraries to read and write from/to shapefile and the aforementioned other alternatives, and is therefore no longer NX's concern. As long as you can open it with geopandas, you can make it into a NX graph (if it is a valid network of course) 3. The current implementation is using a very old version of GDAL (1.10.0, two major releases behind the current 3.1.2). I believe it is more prudent to deprecate this functionality and use this nice, well-established and pandas-like library in its place. 4. Geopandas is a fundamentally geospatial library while NX (at least in my humble opinion) is not. GDAL is notoriously difficult to wrangle because it requires system binaries. I think it would be best to focus on graph functionality and leave geospatial implementation details to a library which specializes in them.  I've also been doing some thinking about what exactly needs to be done to make this into a robust functionality. Below are specific functionalities which I think are important to consider:  - [x] Load a GeoDataFrame into a Graph and DiGraph - [x] Export a Graph or DiGraph to a GeoDataFrame - [ ] Enable handling of geometric attributes during edge manipulation - This one may be tricky because the physical geometry of the edge is stored as an attribute. So if you flip the orientation of the edge, I would argue that the [LineString](https://shapely.readthedocs.io/en/latest/manual.html#linestrings) object representing the geometry should be flipped correspondingly, so that future export to GeoDataFrame will reflect the changes - [ ] Handle nodes - This one is also tricky, if you want to have attributes on nodes then you will need to have another GeoDataFrame containing [Point](https://shapely.readthedocs.io/en/latest/manual.html#Point) geometries. The same goes for exporting - [x] Add a `DeprecationWarning` indicating that support for reading directly from shapefiles will end soon - [ ] Swap out the `read_shp` function for a legacy-support wrapper which opens the shapefile as a GeoDataFrame and processes it automatically in the meantime. - [x] Support 3D coordinates - [x] Handle empty GeoDataFrame and Graph/DiGraph objects - [ ] Handle mixed 2D & 3D geometries (maybe a `flatten` parameter (default False) which will flatten 3D geometries to 2D in case the user doesn't care about 3D but it's causing problems) - [ ] Add a few gallery examples  This list is not meant to be exhaustive and I welcome and encourage feedback.
issue
Possible enhancement: Support for Geopandas GeoDataFrames#TITLE_END#I come from a geospatial analysis background and I noticed that there is functionality in networkx to [parse a network from shapefiles](https://github.com/networkx/networkx/blob/9b02800087d6a400ce84f9e44a15eee41c27c4dd/networkx/readwrite/nx_shp.py).  This is certainly very useful, but shapefiles are not the only format for storing geospatial vector data, and in fact they are rather old, being based on technology that is becoming obsolete, and there are [a host of issues with using them](http://switchfromshapefile.org/).  I'm not saying to dump support for them by any means, as they are still very widely proliferated. But there are other libraries that specialize in reading & writing to/from many geospatial formats using GDAL (which is the library responsible for shapefile operations in networkx, and is basically bedrock for all geospatial manipulation libraries).  [Geopandas](https://geopandas.org/) is an extension library for Pandas which adds support for geometry columns and operations by building off of native Pandas types. It also has a very comprehensive input/output system for all the major geospatial file types, and uses shapely to handle geometry, which is also a very robust geometry library for Python.  think that adding support for building networks from GeoPandas GeoDataFrames would be a really good way to unlock interoperability for a very wide range of geospatial data formats by using the GeoDataFrame is a sort of common interface - The [GeoDataFrame.from_file() method](https://geopandas.org/reference.html?highlight=from_file#geopandas.GeoDataFrame.from_file) can open all major geospatial data formats (as defined by fiona, which is another well-used geospatial library for file I/O operations). So if we used the GeoDataFrame as the common interface, you would essentially provide support for all major geospatial formats.  I don't have all the answers here, I just want to start a discussion on this because I think it is an opportunity to add a lot of value to networkx. I have already been using the two (network + geopandas) in unison for some time now and I have found it to already be quite intuitive, even though I have to handle the transformation myself. To get the ball rolling I can share this bit of code which I use to build a networkx graph from a geopandas geodataframe. I know it's probably not optimal, but it is a start:  ``` def gdf_to_graph(gdf, geom_col, keep_node_geoms=False, keep_edge_attrs=False) -> nx.Graph:      # Find all unique start & end points and assign them an id     gdf["start_node_coords"] = gdf[geom_col].apply(lambda i: (round(i.coords[0][0], 5), round(i.coords[0][1], 5)))     gdf["end_node_coords"] = gdf[geom_col].apply(lambda i: (round(i.coords[-1][0], 5), round(i.coords[-1][1], 5)))     node_ids = {}     i = 0     for index, row in gdf.iterrows():         node_1 = row["start_node_coords"]         node_2 = row["end_node_coords"]         if node_1 not in node_ids:             node_ids[node_1] = i             i += 1         if node_2 not in node_ids:             node_ids[node_2] = i             i += 1      # Assign the unique id to each     gdf["source"] = gdf["start_node_coords"].apply(lambda x: node_ids[x])     gdf["target"] = gdf["end_node_coords"].apply(lambda x: node_ids[x])      # Make the graph     if keep_edge_attrs:         graph = nx.from_pandas_edgelist(gdf, edge_attr=gdf.columns.to_list())     else:         graph = nx.from_pandas_edgelist(gdf, edge_attr=[geom_col])      if keep_node_geoms:         node_geoms = {node_ids[k]: Point(k) for k in node_ids}         for n in node_geoms:             graph.nodes[n].update(geometry=node_geoms[n])      return graph ``` 
issue
documentation for "edge_key" param in nx.from_pandas_edgelist() missing#TITLE_END#I just noticed this while working on implementing support for geopandas (I want it to behave as similar to pandas functions). I guess it's for MultiGraphs which I can't really wrap my head around.
issue
WIP: Change EdgeDataView __contains__ feature (2nd attempt)#TITLE_END#I took the advice of last time and this time I think I am close, but I am still having trouble with the MultiEdge class family tests.  From what I can tell, it seems that as soon as you pass an `nbunch` parameter to the `EdgeView` cosntructor (and those of its family), it automatically redirects to an (associated) `EdgeDataView`. For this reason I didn't implement any nbunch check logic because it seems to already be handled in the associated EdgeDataViews.  However now it seems to be failing whenever it runs the `test_contains` function in the context of any `MultiEdge` class. It seems to me that this function is just run in all of its subclasses and can no longer handle the new restriction of edges via the `nbunch`. Could it be that this test was only passing due to the presence of the bug, and its fix now causes the test to fail? As I said before I am no big expert on pytest so I don't want to presume anything so someone else should look at this. But if my guess is correct then I think this test has to be split down into the respective subclasses to take into account the changes to the various `__contains__` methods
issue
WIP: Change EdgeView contains feature#TITLE_END#This PR is a WIP to get feedback  It is addressing issue 3819: https://github.com/networkx/networkx/issues/3819  After mucking around in the `EdgeView` classes, it seems to me that the simplest way to fix the `__contains__` bug is actually to just constrain the `self._adjdict` variable in the `__init__` function by comparing it to the `nbunch` param (if there is one).  I put a big test in `TestEdgeView` because I noticed it gets executed for all the other test classes due to inheritance. I'm not sure if this is the best way to do this and while I have some experience in pytest, I am not really an expert in all its inner workings so I am open to feedback on how to better structure it.  This seems to work for `Graph` and `DiGraph` objects, but fails for `MultiGraph` and `DiMultiGraph` objects, where I am now stuck. I constrain `self._adjdict` just as before, but for some reason, `__contains__` is now always returning False. You can see this by looking at the `inclusion` dict in the new test in the debugger, it marks the edge `(0, 1, 0)` as being False even though it should be included in both the directed and the undirected graph.  Can I get some feedback on this? Am I going in the right direction or does it need a different approach?
issue
nx.to_pandas_edgelist() will not update the "source" and "target" columns if they already exist#TITLE_END#I discovered this during a workflow where I am transforming between pandas dataframes and networkx graphs rather frequently. The old "source" and "target" columns were hanging around from a previous transformation.  I realize that it is probably bad practice to already have "source" and "target" as attributes in a graph, especially when they are wrong, but there is no mention of this behaviour on the [docs page](https://networkx.github.io/documentation/stable/reference/generated/networkx.convert_matrix.to_pandas_edgelist.html) and it seems to me that a more intuitive behaviour would be for it to overwrite the columns in the dataframe with the actual current graph information, and not what may be hanging around in the attributes list.  See below. In this example, I create an undirected graph with a "backwards" edge, then straighten the graph out by transforming it into a tree [(see here)](https://stackoverflow.com/questions/60742779/creating-a-directed-graph-from-an-undirected-graph-with-dfs-tree-but-keep-attri). However, since "source" and "target" already exist (perhaps from a previous conversion from a graph to dataframe, and then back to a graph again), then they are not updated when writing back to a dataframe again.  ``` import networkx as nx  graph = nx.Graph([     (0, 1, {"source": 0, "target": 1}),     (1, 2, {"source": 1, "target": 2}),     (3, 2, {"source": 3, "target": 2}) ]) digraph = nx.DiGraph(graph) digraph.remove_edges_from(digraph.edges - nx.dfs_edges(graph, 0))  df1 = nx.to_pandas_edgelist(digraph)  # Default is to use source="source" and target="target" print(df1.head()) df2 = nx.to_pandas_edgelist(digraph, source="source2", target="target2") print(df2.head()) ```  Output of ´print(df1.head())´ is:  ```    source  target 0       0       1 1       1       2 2       3       2 ```  Output of ´print(df2.head())´ is:  ```    source2  target2  source  target 0        0        1       0       1 1        1        2       1       2 2        2        3       3       2 ```
issue
Fix for #3930 (source & target columns not overwritten when converting to pd.DataFrame)#TITLE_END#`nx.to_pandas_edgelist()` will now check the source and target column names individually and raise a `NetworkXError` if there is a detected conflict.  Two tests also added to verify this. They try to convert a graph with source and target column names that already exist as attributes. They will only assert True if a `NetworkXError` is raised, otherwise they will assert False.
comment
I have been away from this from some time as I was focusing on finishing some personal projects but I see that I have a few mentions. I actually haven't heard of pySAL before but it looks pretty solid, and I see that it is maintained in parallel with Geopandas, so I would trust that it would be the recommended approach. In fact I may go back and look at some of my own code to see if I can replace some of my own hacky implementations with some nice optimized one-liners from PySAL.  The truth is I don't think I'm really an expert on hardcore code optimization so I think that whatever PySAL has implemented is probably going to be more performant than what I came up with already. I'm also just happy that there is a tighter integration between Geopandas and NetworkX because I use the two quite frequently and it's nice to be getting some "official" ways to work with the two in tandem.  The case I was most interested in is making a network from lines, and the example provided @ljwolf seems to do exactly that starting from a gdf made from a shapefile, so it looks great to me.
comment
I am interested in having a try at this. I haven't worked on this library before but I am quite interested in network topology applications. I am also the person who posted the stackoverflow thread which revealed the defect so I feel some attachment and personal interest in resolving it.
comment
It is worth nothing that there is a devil in the details regarding simple (x, y) notation of coordinates in the geographic domain - a common method of storing unprojected coordinate data (like latitude and longitude) is via [lat, lon], which, when mis-intuitively mapped to a cartesian plane, would actually produce (y, x) coordinates. This is unfortunately a problem that rears its ugly head quite frequently in my experience, due to oversights in one library or another. For that reason I would propose restricting any geographic write functions to requiring WKB or WKT, or potentially even just leaving the work to libraries specifically for geographic data manipulation.  There actually is an extension library for networkx intended for handling of geographic/spatial networks by combining it with common spatial libraries: https://github.com/Artelys/geonetworkx
