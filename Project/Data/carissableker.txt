issue
edgelist reader removes deliminators if deliminator is white-space and file has empty fields [BUG]#TITLE_END#This `line.strip` without an argument, means a white-space delimited file (e.g. tab, which is quite common) with  empty edge attribute(s) in the last column(s) results in a crash with error `Edge data [...] and data_keys [...] are not the same length`.      https://github.com/networkx/networkx/blob/729bec23b10e89b5f6d37175e30484f2278107c4/networkx/algorithms/bipartite/edgelist.py#L222  An example file that would crash:  ``` A	B	interaction	2 B	C	interaction	4 C	A	interaction	 ``` The last line ends in `\t\n`, and both are striped instead of just the `\n`. This is inconsistent, as the same data in a different order of columns works fine, e.g.: ``` A	B	2	interaction B	C	4	interaction C	A		interaction ```   # Fix      s = line.rstrip("\n").split(delimiter)  is the safe fix, and is cross OS compatible in Python (https://peps.python.org/pep-0278/)
comment
Hi @dschult   As the bug reporter, I have the following comment:   > If I understand the subtleties here, it looks like this will no longer strip anything from the beginning of a line and will only strip a newline character off of the end of the line.  Yes, this is correct. In my opinion this is the simplest and most predictable behaviour. The aim of this line is to prepare the input by removing the *completely expected* newline and split the line into its components by using the *explicit* user-provided delimitator. Doing anything more than this, e.g. attempting to do undocumented whitespace "cleaning" would be obscured, unpredictable and/or become very complex.   > So, it fixes the problem with a tab delimiter, but breaks an input file that has spaces at the front or end of a line. It looks like all tests pass.  It would not break (crash), it would respect the user input (an attribute/node name with leading or trailing white space).   > I guess to fix the currently broken cases and leave the current behavior for extra whitespace at start and end, we should strip all white space **except** the delimiter. Something like: >  > ```python >     stripchars = None if delimiter is None else string.whitespace.replace(delimiter, "") >     .... >     <other stuff and start loop, etc> >     s = line.strip(stripchars).split(delimiter) > ```  This is not consistent though. The following lines, (for an equivalent undirected edge) would have a different result:  ``` A\tB\s\n ```  and   ``` B\s\tA\n ```  or alternatively:  ``` \sA\tB\n ```  and   ``` B\t\sA\n ```  Of course, it may not be the users intent to have a node name of ` A` or `B `,  but it is what was provided to networkx and I don't think it should be networkx's prerogative to attempt to deduce  what the user means and unilaterally "fix" it, as there lies many dragons.   Compare this behaviour to other software, e.g. Excel or pandas, removing leading/trailing whitespace is usually done on per cell basis (instead of line), and is only done on explicit user direction. The only place where editing of (non newline or delimiter) whitespace in the background may be relevant is perhaps in "fixed width" format.   ## Alternatively If you do require that node names should not have leading or trailing whitespace, this should be removed per item after `split(deliminator)` (and then be documented). E.g.:  ``` s = [x.strip() for x in s] ``` In this case, also the two examples above would be consistent.    
