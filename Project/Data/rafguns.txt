issue
Incorrect formula for collaboration_weighted_projected_graph#TITLE_END#The formula given in `collaboration_weighted_projected_graph` makes little sense. For reference, the one in the paper by Newman is:  `w_{i, j} = \sum_k \frac{\delta_{i}^{k} \delta_{j}^{k}}{n_k - 1}`  where `i` and `j` are nodes from the "bottom" node set (the set of nodes to project onto), and `k` is a node of the "top" node set. The value `n_k` is the degree of node `k` in the bipartite network and `delta_{i}^{k}` is 1 if node `i` is linked to node `k` in the original bipartite graph or 0 otherwise.  It is probably also worth mentioning explicitly that "top" nodes with degree <= 1 are excluded.
issue
Simplify and speed up nx.non_edges#TITLE_END#This simplifies the code in `nx.non_edges` for undirected networks a bit. Performance comparison:  Old version:  ``` In [18]: G =nx.random_regular_graph(5, 2000, seed=1)  In [19]: %timeit list(nx.non_edges(G)) 1 loops, best of 3: 2.52 s per loop ```  New version:  ``` In [10]: G = nx.random_regular_graph(5, 2000, seed=1)  In [11]: %timeit list(nx.non_edges(G)) 1 loops, best of 3: 812 ms per loop ```  Since it doesn't keep a set of 'seen' edges, it probably uses less RAM (though I haven't checked). 
issue
nose test errors on Windows#TITLE_END#The following error occurs a few times in Windows:  ``` ====================================================================== ERROR: test_decorators.TestOpenFileDecorator.test_writer_arg0_fobj ---------------------------------------------------------------------- Traceback (most recent call last):   File "C:\Python27\lib\site-packages\nose\case.py", line 384, in tearDown     try_run(self.inst, ('teardown', 'tearDown'))   File "C:\Python27\lib\site-packages\nose\util.py", line 478, in try_run     return func()   File "c:\bin\git\networkx\networkx\utils\tests\test_decorators.py", line 160, in tearDown     os.remove(self.name) WindowsError: [Error 32] The process cannot access the file because it is being used by another process: 'c:\\users\\rafguns\\appdata\\local\\temp\\tmpgr79rv' ```  It seems to be due to Windows' handling of temporary files. 
issue
Make sure node names with blanks are quoted in Pajek export format#TITLE_END#Currently, nodes with blank spaces in their name are written "as-is" in the Pajek format. Pajek, however, requires that they are quoted. 
comment
Hi, I'm not a networkx maintainer but I'll try to answer your first two questions.  1. This package uses its own graph data structure (`nx.Graph` and derived classes like `nx.DiGraph`). There is documentation on [converting to/from other data structures](https://networkx.github.io/documentation/stable/reference/convert.html). 2. Please check the [documentation of the `optimal_edit_paths` function](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.similarity.optimal_edit_paths.html#networkx.algorithms.similarity.optimal_edit_paths). Arguments `node_subst_cost`, `node_ins_cost` etc. expect functions rather than plain ints.  Sorry, not sure about question 3.
comment
For reading GraphML, you need the function [`read_graphml`](https://networkx.github.io/documentation/stable/reference/readwrite/graphml.html). [GML](https://networkx.github.io/documentation/stable/reference/readwrite/gml.html) is a different file format.
comment
Are you referring to the [Pajek matrix (*.mat) format](http://wiki.cns.iu.edu/pages/viewpage.action?pageId=2200189)? This is indeed not (yet) implemented in networkx, only the *.net format is currently supported.  I assume that the core developers are open to pull requests that implement reading (and writing) this additional format. 
comment
@kemskems How were you planning on implementing Katz score? Currently all link prediction algorithms are implemented like this:  ``` def some_predictor(G, u, v):     # do stuff     return score ```  This works fine for the neighbor-based predictors but Katz score, SimRank and others are most easily implemented as matrix operations that calculate scores for all node pairs in one go (similar to the algorithms in `nx.algorithms.centrality`):  ``` def some_predictor(G):     # do stuff     return dict_of_scores  # e.g. {('a', 'b'): 0.2, ('b', 'c'): 0.5, ...} ```  So perhaps it makes sense to move to an API like this:  ``` def some_predictor(G, u=None, v=None):     # do stuff     return score_or_dict ```  which returns a single score if u and v are nodes or a dict if u and/or v is None (u and/or v might even be lists or iterables of nodes, but maybe things become too complex then). Thoughts? 
