comment
The problem seems to be in prune() inside find_cycles():              try:                 popped_edge = edges.pop()             except IndexError:                 edges = []                 active_nodes = {tail}                 break  {tail} needs to be {start_node}.  What happens is that the outer loop explores nodes 0, 1, 2 before 3, then when it comes to 3 it follows the edges in the order (3, 1), (1, 2) (2, 0), (3, 2). This results in the following prunes: (3, 1) => 1 has been explored => prune, active_nodes = {3} (1, 2) => 2 has been explored => prune, active_nodes = {1} (2, 0) => 0 has been explored => prune, active_nodes = {2} now the dfs goes back up to 3 (3, 2) => 2 is in active_nodes => cycle  Ideally, the algorithm should skip the (1, 2) and (2, 0) steps altogether, since both nodes have been explored already.
