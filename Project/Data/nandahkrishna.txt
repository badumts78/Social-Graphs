issue
Unable to build from source using source archive from PyPI#TITLE_END#<!--- Provide a general summary of the issue in the Title above --> When using the source archive for NetworkX 2.6 from PyPI, building from source fails. This seems to be because the `requirements/` folder is not present in the archive, and is a consequence of changes to the `setup.py` file in commit https://github.com/networkx/networkx/commit/cf5cc90b25fb53aec85c59d8d62fae3d3b05bc86 (due to which requirements are populated from files in the `requirements/` directory).  This was not an issue with stable versions prior to 2.6 (such as 2.5.1) even though the `requirements/` directory was not included in the archive, because the requirements were listed directly in `setup.py`.  (**Note:** I wasn't sure if a Discussion would be better than an Issue for this, but decided to go ahead with a bug report because it seems to me like this is a packaging bug. Apologies in advance if this should have been reported elsewhere.)  ### Current Behavior <!--- Tell us what happens instead of the expected behavior --> As mentioned above, building NetworkX 2.6 from source using the archive from PyPI fails because of the absence of the `requirements/` directory, which is used to populate dependencies in `setup.py`. This is an problem when a user wishes to build from source, such as when using `pip install --no-binary`.  ### Expected Behavior <!--- Tell us what should happen --> I would expect the `requirements/` folder to be present in the source archive, so that the build succeeds.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> ``` ➜ pip install --no-binary :all: networkx==2.6 Collecting networkx==2.6   Downloading networkx-2.6.tar.gz (1.8 MB)      |████████████████████████████████| 1.8 MB 2.2 MB/s     ERROR: Command errored out with exit status 1:      command: /Users/nanda/miniconda3/envs/dev/bin/python3.8 -c 'import sys, setuptools, tokenize; sys.argv[0] = '"'"'/private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-install-t8bvrwpe/networkx/setup.py'"'"'; __file__='"'"'/private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-install-t8bvrwpe/networkx/setup.py'"'"';f=getattr(tokenize, '"'"'open'"'"', open)(__file__);code=f.read().replace('"'"'\r\n'"'"', '"'"'\n'"'"');f.close();exec(compile(code, __file__, '"'"'exec'"'"'))' egg_info --egg-base /private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-pip-egg-info-ndhnqncu          cwd: /private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-install-t8bvrwpe/networkx/     Complete output (7 lines):     Traceback (most recent call last):       File "<string>", line 1, in <module>       File "/private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-install-t8bvrwpe/networkx/setup.py", line 165, in <module>         install_requires = parse_requirements_file("requirements/default.txt")       File "/private/var/folders/10/j4yhfzq10mz95_gmsln3z_hc0000gn/T/pip-install-t8bvrwpe/networkx/setup.py", line 159, in parse_requirements_file         with open(filename) as fid:     FileNotFoundError: [Errno 2] No such file or directory: 'requirements/default.txt'     ---------------------------------------- ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ```  ### Environment <!--- Please provide details about your local environment --> Python version: 3.8.0 NetworkX version: 2.6.0  While these is my local environment, the main reason I'm opening this issue is because of a build failure noticed at [Homebrew](https://brew.sh), when building NetworkX 2.6 from source for another dependent package. At Homebrew, packages must be built from source and wheel files or other precompiled binaries cannot be used.  ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> The relevant Homebrew pull request is Homebrew/homebrew-core#80829, and the logs can be viewed [here](https://github.com/Homebrew/homebrew-core/commit/ad5fc3dff1c0a6929b81cb14fb66fda5c29e3e7c/checks/3022390612/logs).
issue
Fix for betweenness_subset#TITLE_END#Aims to fix #3481 by removing unnecessary rescale factor.
issue
Correct docstring errors in traversal#TITLE_END#See PR #3484 and issue #3483  This PR fixes errors in docstrings for BFS and DFS.
issue
Added group closeness and group degree centralities#TITLE_END#Closeness centrality measure implemented for groups. Improvement of module created in PR #3421. References: http://www.analytictech.com/borgatti/group_centrality.htm http://wwwconference.org/proceedings/www2014/companion/p689.pdf Please do tell me if there is anything I should correct.
issue
No multigraphs for betweenness#TITLE_END#Aims to fix issue #3432 by adding `@not_implemented_for('multigraph')` in `betweenness_centrality`. If the generalised shortest path functions should be used, or if the custom Dijkstra code should be modified rather than not implementing `betweenness_centrality` for multigraph, let me know. Thanks!
issue
Set seed in random_degree_sequence_graph docstring test#TITLE_END#Aims to fix issue #3450 by setting random seed value in the docstring test.  The seed has been sent to an `int` value of 42. Let me know if it should be changed to a random state or if any other change is required.
issue
Fixed typo in betweenness centrality subset test#TITLE_END#Small typo, "etweenness" changed to "betweenness".
issue
Adding module for group centrality measures#TITLE_END#Added group.py, a new module, to networkx.algorithms.centrality for group centrality computation functions. Added function for group betweenness centrality. Please do review the code and suggest any changes/improvements. Thanks. (Future work: Adding functions for group closeness and group degree centralities) Issue: #3388 
issue
Add function for group betweenness centrality#TITLE_END#Recently I worked on a program to calculate the betweenness centrality of a group of nodes in a graph, rather than the individual betweenness of each node. I was wondering if I could add a function to do the same, as I believe it's a useful centrality measure. Would this be fine? <img width="333" alt="GBC" src="https://user-images.githubusercontent.com/33784207/55827819-b4b39c00-5b28-11e9-96ad-ad5326373cf9.png"> 
comment
Are PRs welcome for this issue? I see it's been opened a long time back, and if possible I'd like to work on it.
comment
I'd like to try this, I understand it's going to be quite large. I did find resources to convert from nose to pytest. Do tell me if you think I can go ahead. Thanks.
comment
I believe I can offer an explanation here, hope you find it helpful. 1. The block comment, I think, is right in saying that it is the reciprocal of the average shortest path distance. There are `n-1` reachable nodes from `u` meaning we have `n-1` shortest paths from `u` to these nodes. The average length over all these shortest paths would be the sum of their lengths, divided by `n-1`. Taking this quantity's reciprocal, we get the formula for closeness centrality. So I believe the definition is correct. 2. The block comment also describes that in the case of a directed graph, the inward closeness value is calculated. To use the single source path functions, we reverse the graph so that all inward edges become outward edges. This helps us get the value for inward closeness centrality. For getting the outward closeness, one simply has to pass `G.reverse()` as input to negate the effect of the function's own call of reverse. 3. This seems to be the documentation of NetworkX 1.10, which is not the latest version. The latest stable version is NetworkX 2.3 and 2.4 is in development. I believe their documentation is consistent with the descriptions in the block comments in the function. You could check here (2.3): https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality
comment
It's probably true that the terminology may not be entirely right. I think @dschult may be able to offer a better explanation in these points than I can.   However, I do not still understand point 2. In NetworkX, we decide that **closeness is calculated based on incoming paths** to the node in directed graphs. This means that we require using every other point as a source and the destination is `u`. But by **reversing**, all **incoming paths become outgoing paths**. This **allows us to use `u` as a source in single source shortest paths, to get all paths to other nodes**. This is **equivalent to getting all paths to `u` from other nodes, in a non-reversed graph**.   Note: Here's the note from the function which clearly mentions that we use inward paths for closeness. If you require the use of outward paths, you can just pass G.reverse() as a parameter rather than G so that you negate the function's call of reverse. "Notice that the closeness distance function computes the incoming distance to u for directed graphs. To use outward distance, act on G.reverse()."  While I have not used the other software, I believe they might use outward closeness as opposed to inward closeness used here. Once again, I may be wrong. If you could offer a slightly more detailed explanation, I'd be grateful. Thanks!
comment
@luanamarinho no issues at all! Happy to be part of a constructive debate and I understand everyone has different use cases. Glad you find NetworkX to be useful, it's definitely a community effort that enriches packages like these and your doubts are definitely understandable. I will get back to you on this particular point when I've got it cleared up myself. Thanks!
comment
Hello, hope you don't mind if I just add something here. In `betweenness_centrality`, the default is `normalized=True`. So, would it be better if we changed `betweenness_centrality_subset` to also have `normalized=True` by default (it's `False` right now)? This would ensure that the values are the same for the case you mentioned, which is also given in the docstring.   Since normalization would ensure that the results agree, I think it might be fine if we remove the scale factor of 0.5, so the query may be addressed for more general cases, as indicated by the StackOverflow question.   I hope I'm making sense here, please do point out if I have any errors in my understanding.
comment
Just some outputs: ``` >>> G = nx.path_graph(5) >>> nx.betweenness_centrality(G, normalized=False) {0: 0.0, 1: 3.0, 2: 4.0, 3: 3.0, 4: 0.0} >>> nx.betweenness_centrality(G) # normalized is True by default {0: 0.0, 1: 0.5, 2: 0.6666666666666666, 3: 0.5, 4: 0.0} >>> nx.betweenness_centrality_subset(G, G.nodes, G.nodes, normalized=True) {0: 0.0, 1: 0.5, 2: 0.6666666666666666, 3: 0.5, 4: 0.0} >>> nx.betweenness_centrality_subset(G, G.nodes, G.nodes) # normalized False by default {0: 0.0, 1: 3.0, 2: 4.0, 3: 3.0, 4: 0.0} ``` The proposed betweenness subset function would give `{0: 0.0, 1: 6.0, 2: 8.0, 3: 6.0, 4: 0.0}` when not normalized, and `{0: 0.0, 1: 0.5, 2: 0.6666666666666666, 3: 0.5, 4: 0.0}` when normalized.  The docstring (in betweenness_centrality as well as betweenness_centrality_subset): ``` normalized : bool, optional       If True the betweenness values are normalized by `2/((n-1)(n-2))`       for graphs, and `1/((n-1)(n-2))` for directed graphs where `n`       is the number of nodes in G. ```
comment
Thanks @dschult for explaining. I too think there is no error in the "normalized" code, it ensures that values of `betweenness_centrality` and `betweenness_centrality_subset` are the same no matter the test case.   Seeing as `normalized=True` is default for `betweenness_centrality`, I think it would be better for subset betweenness to also be normalized by default. Makes things uniform, I guess.  The definition of subset betweenness considers paths **from sources** and **to targets**, so in the **literal sense**, the element of **direction** seems to be present. I'm not sure, but it might be fair to assume that calls to subset betweenness mostly don't have repetition of source nodes in targets - this means we could count paths in 1 direction as one full path and **undirected paths as 2 directed paths**. The value of centrality being higher than the total number of paths in the graph in some cases may not be a huge concern. So it might be alright if we remove the 0.5, and normalizing by default would help in uniformity across functions.  Do let me know what you think would be the best way forward. Thanks.
comment
I hope my suggestions were helpful!
comment
The checks pass, I think it looks good. Maybe @dschult could offer more valuable inputs.
comment
Could you also check the other functions in `depth_first_search.py` and maybe even `breadth_first_search.py`? I believe a couple of other functions have the same `return edges` in their docstrings - makes me wonder if it is an error or some terminology I'm unaware of.  I think the return value/type needn't be mentioned in the description of `source` (see `dfs_tree` in the same file). That could be moved to the dedicated `Returns` segment of the doc. However it would be great to mention that the algorithm iterates only over edges in the same component as `source` (if it does so).
comment
I'm afraid NetworkX 1.11 is an older version, current version is 2.3 and development is 2.4, and this issue doesn't exist in the newer versions. Do check [here](https://github.com/networkx/networkx/blob/master/requirements/extras.txt) to see the new requirements file for extras (which includes `matplotlib`, `pygraphviz`, etc).   I'd suggest updating NetworkX to the latest version, `pip install networkx[all]` should help install all the requirements. Hope this was helpful!
comment
No problem at all, issues are always welcome. Do create a separate environment for this though, to avoid conflicting package versions.
comment
Can be closed. Forgot to mention 'closes' in the PR.
