issue
Adding triadic analysis from sociology#TITLE_END#I'm proposing to augment NetworkX with functionality for triadic analysis from sociology. I welcome comments and suggestions about how to organize this as a potential PR. This is for a course project, but I would love to actually contribute my code to NetworkX.  ##### Introduction to sociological triads Sociology has long dealt with the concept of triadic interactions. As conceptualized by late 20th century sociologist Georg Simmel, a dyad (or interaction between two parties) is simple - it can be positive or negative, strong or weak. However, studying triadic interactions unearths a significant degree of complexity. A simple example is Simmel's idea of triadic closure - that a strong positive relation between A and B, and a strong positive relation between B and C, imply that there should be a strong positive relation between A and C. Consider a set of three friends, or three members of a family, or three allies in global politics - the rule is strangely pervasive.  This has led to several notions and theories of behavior based of these triads, constituting a type of analysis that is now known as structural interactionism. A huge body of work analyses various mechanisms and patterns that can be identified from simple triadic analysis.  ##### Python for triadic analysis NetworkX has limited provisions for triadic analysis. The only functionality I could find was `triadic_census()`, which simply counts the number of triads in a given directed graph (see [here](https://networkx.github.io/documentation/networkx-2.2/reference/algorithms/triads.html)).  Triadic analysis will likely get very expensive for large networks. However, the goal is first to have a proof of concept that it can be done in conjunction with NetworkX.  ##### Proposal I propose to extend and adapt NetworkX code to simple sociological triadic analysis. I can begin by adding the following functions on a graph `G` (to be expanded):  - `G.get_triadic_closures()`  - list of closed triads within the graph  - `G.get_focal_closures(attr_name)` - list the triads which are closed around a node attribute `attr_name`  - `G.get_stable_triads(stability_func)` - count triads that fulfill a given criterion of stability (a function that takes the graph, 3 nodes, and a criterion on them, eg: focal closure). The idea is to count unstable triads. These could be expected to stabilize either by formation or deletion of existing edges  The following are more crudely thought-out functions for sociological analysis that can be implemented using NetworkX:  - `G.predict_edge_deletion()`  - `G.predict_edge_formation()`  - `G.simulate_triadic_mechanism()` 
issue
Adding triadic analysis functions#TITLE_END#Re: #3727 **Methods added:** in `networkx/algorithms/triads.py`: - `all_triplets()` - `all_triads()` - `triad_type()` - `triads_by_type()`  **Tests added in `networkx/algorithms/tests/test_triads.py` for all the above**  **Notes** - `triad_type()` implements a (perhaps inefficient) algorithm to identify the triadic type of a triad (an order-3 DiGraph) (good resource on this [here](http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf)). - `all_triplets` and `all_triads` are generator functions. As the number of possible triads in a graph grows like O(n^3), I was wondering if I should print a warning for larger than some number of nodes (say 100) in the DiGraph.  **TODO** Empty functions that I will soon write are: - `random_triad()` - `triadic_closures()` - `focal_closures()` - `balanced_triads()`  @ericmjl @dschult @jarrodmillman @MridulS happy to hear your feedback and suggestions. 
issue
set_node_attributes error#TITLE_END#```Traceback (most recent call last):   File "~/anaconda3/lib/python3.6/site-packages/networkx/classes/function.py", line 647, in set_node_attributes     for n, v in values.items(): AttributeError: 'str' object has no attribute 'items'  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File "<stdin>", line 1, in <module>   File "~/anaconda3/lib/python3.6/site-packages/networkx/classes/function.py", line 654, in set_node_attributes     G.nodes[n][name] = values TypeError: unhashable type: 'dict' ``` What's up with this?
issue
Fixes local efficiency bug reported in #2710#TITLE_END#Local efficiency should be computed on the subgraphs induced by *neighbors* of each node (ref: **Efficient Behavior of Small-World Networks**, Latora et al) - however, the node itself should not be included in this subgraph. Hence, `center = False`.  Thanks to @dschult and Vlado S.
comment
I'm interested in contributing and this does seem like it might have a simple fix. However, it looks @regstrtn has already tried a fix that has failed the Travis CI build. Any way I can help?
comment
@dschult if this might be a good first issue for someone reasonably experienced with nx and github, but who has never contributed before - I'd appreciate your mentorship.
comment
I have investigated this and I think it looks fairly straightforward. Thanks @dschult for referencing #2233 and @vlado-s for your comprehensive testing of the nature of the problem. In fact, the solution is simply the change @vlado-s proposed.  1. The subgraph used to compute local_efficiency should **not** include the node for which it is being computed. Vlado's quoting of Latora et al confirms this.  2. The error in #2233 was a result of incorrect use of `nx.Graph.subgraph()`. It seems that the previous implementation was always calling `subgraph()` on just 1 node of the Graph - leading to a subgraph of just that node, and no edges. This is because `subgraph()` needs to be called on a *subset* of nodes.  The new implementation using `nx.ego_graph()` fixes this. However, the center node needs to be excluded from the computation.  Besides, errors due to no path between nodes seem to have been taken care of in the new implementation of `efficiency()` and `global_efficiency()`.  3. Vlado has cited the exact lines that are relevant. Should this be explicitly referenced in the PR?  4. I can make the change. As you said, it is exceedingly straightforward.  
