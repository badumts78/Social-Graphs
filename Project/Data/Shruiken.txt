issue
network_simplex of networkx#TITLE_END#When i call network_simplex on my graph G, it produces an error stating, that int objects are not iterable. I explored the problem and via debugging and found that in the  add_edges_from(self, ebunch, attr_dict=None, **attr) function there is somehow one of my nodes of G in ebunch: problem: error in line 787 of graph.py: Type Error: 'int' object is not iterable first iteration: e = (u'L00010', 't', {'capacity':0.0, 'lower':0.0, 'weight':0})                    dd = {'capacity':0.0, 'lower':0.0, 'weight':0} secont iteration: e = (u'L00010', 'demand', 0)                        dd = 0 => error  my code: (note that the data is imported from sql and i first used ford fulkerson before indtroducing demands. that worked just fine.) # Graph erstellen  ``` G = nx.DiGraph() G.add_node("s") G.add_node("t")  #Klassen Knoten hinzufuegen und mit s verbinden cursor.execute("SELECT * FROM Klasse") rows = cursor.fetchall() for row in rows:     newNode = row.idKlasse     G.add_node(newNode)     cursor.execute("SELECT * FROM gefordertTreffen WHERE idKlasse=(?)",newNode)     secRows = cursor.fetchall()     dividen = 0     for secRow in secRows:         dividen = dividen + float(secRow.Anzahl)/tageszahl     cap = math.ceil(dividen)     low = math.floor(dividen)     G.add_edge("s", newNode, capacity = cap, lower = low, weight = 0)  #Lehrer Knoten hinzufuegen und mit t verbinden cursor.execute("SELECT * FROM Lehrer") rows = cursor.fetchall() for row in rows:     newNode = row.idLehrer     G.add_node(newNode)     cursor.execute("SELECT * FROM gefordertTreffen WHERE idLehrer=(?)",newNode)     secRows = cursor.fetchall()     dividen = 0     for secRow in secRows:         dividen = dividen + float(secRow.Anzahl)/tageszahl     cap = math.ceil(dividen)     low = math.floor(dividen)     G.add_edge(newNode, "t", capacity = cap, lower = low, weight = 0)  #Klassen und Lehrer Knoten verbinden cursor.execute("SELECT * FROM gefordertTreffen") rows = cursor.fetchall() for row in rows:     kNode = row.idKlasse     lNode = row.idLehrer     dividen = float(row.Anzahl)/tageszahl     low = math.floor(dividen)     cap = math.ceil(dividen)     print("dividen: {}, lower = {}, capacity = {}".format(dividen, low, cap))     G.add_edge(kNode, lNode, capacity = cap, lower = low, weight = 0)  #Bedarf hinzufuegen (negativer Bedarf = schicken, postiiver Bedarf = empfangen) for nod in G.nodes():     li = 0     for u,v in G.in_edges_iter(nod):         li = li + G[u][v]["lower"]     for u,v in G.out_edges_iter(nod):         li = li - G[u][v]["lower"]     print("({}) demand: {}".format(nod, li))     G[nod]["demand"] = int(li)  #Bedarf zu s und t verschieben x = 0 y = 0 for nod in G.nodes():     if G[nod]["demand"] > 0:         x = x + G[nod]["demand"]     if G[nod]["demand"] < 0:         y = y - G[nod]["demand"]     G[nod]["demand"] = 0 if y == x:     G["s"]["demand"] = -x     G["t"]["demand"] = x     print("Bedarf verschoben.")  print(G.nodes()) print(G.edges(data=True))  #Flussproblem wird geloest print("FLuss") #F = nx.ford_fulkerson_flow(G,"s","t") F = nx.network_simplex(G) ```  i hope someone can help me solve this problem ^^ 
