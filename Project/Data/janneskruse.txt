issue
Core dumps when calling Graph.subgraph() to fast/often in parallel#TITLE_END#Hi,  first of all thank you a lot for developing networkx! Im at the moment using it via osmnx for analysis of service areas/functional density in neighbourhoods and it's a huge help :)  Just a bug I encountered when working on that: I'm doing the analysis with Ubers H3 hexagons of resolution 9 which is approx. 300.000 points for the region I am analyzing. For every point I am trying to create a subgraph of a certain buffer distance and then running dijkstra's on it as this is faster than running it for the graph of the whole region. This can be an emberassingly parallel problem, so I am using dask_geopandas to apply the function in parallel using our universities HPC cluster.  **What I encountered is that my core dumps when trying to create all the subgraphs (g = g.subgraph(intersecting_nodes)) in parallel if I run the code as is. If I add ox.config(log_console=True) it works however. So I assume that the logging adds a time delay which avoids the underlying conflict**  This is my code: ```{python} def calcFunctionDensity (hexpoint, functiondict, g, walking_dist):     """     This function calculates the density of a certain tag list in a given walking distance.     It takes a hexagon centroid geodf, a dictionary of tags, a walking distance and a network type as input.     It returns the hexagon centroid geodf with new columns of "density_{functionname}" that contain the density of the tag in the given walking distance.          parameters:     hexpoint: the hexagon centroid from every row of the geodataframe     functiondict: dictionary of functions     g: the osmnx graph object     walking_dist: the walking distance in meters     """      #print("Start Current Time =", datetime.now().strftime("%D-%H:%M:%S"))     buffer=gpd.GeoDataFrame(geometry=[hexpoint.geometry.buffer(walking_dist+100)])     buffer.crs="EPSG:25832"     buffer.to_crs("EPSG:4326", inplace=True)     mask=(buffer.geometry[0])     hexpointcopy=hexpoint.copy()     hexpoint=gpd.GeoDataFrame(geometry=[hexpoint.geometry])     hexpoint.crs="EPSG:25832"     hexpoint.to_crs("EPSG:4326", inplace=True)     #print("buffer created")          # creating subgraph     intersecting_nodes = nodes[nodes.intersects(mask)].index     warnings.filterwarnings('ignore', category=DeprecationWarning)     g = g.subgraph(intersecting_nodes)     #print("subgraph created")          # use the hexagon as origin     warnings.filterwarnings('ignore', category=DeprecationWarning)     origin= ox.nearest_nodes(g, hexpoint.geometry.x, hexpoint.geometry.y)     hexpoint=hexpointcopy      # square kilometers of walking dist radius     square=walking_dist*walking_dist*3.14159/1000000 #r²*pi/1.000.000 m²          # shortest path from origin to all nodes     warnings.filterwarnings('ignore', category=DeprecationWarning)     shortest=nx.single_source_dijkstra_path_length(g, origin[0], cutoff=None, weight='length')          for n,i in functiondict:         functionname=n         osm_query=i         #get only osm_query inside mask         osm_query =osm_query[osm_query.intersects(mask)] #osm_query =gpd.sjoin(buffer, osm_query ,how='right', predicate='intersects')          osm_query=osm_query[["geometry", "name"]]	#only keep geometry and name                  #if not empty         if len(osm_query)!=0:             #print(f"not empty {functionname}")                      # convert every geometry inside osm_query to a point if it is not already a point             osm_query["geometry"]=osm_query["geometry"].apply(lambda x: x.representative_point() if x.geom_type!="Point" else x)             # get list of nodes for my geodataframe of points             warnings.filterwarnings('ignore', category=DeprecationWarning)             osm_query['nodeid'] = osm_query.apply(lambda row: ox.nearest_nodes(g, row.geometry.x, row.geometry.y), axis=1)              # # filter path for osm_query['nodeid'] ids and max length             max_length = walking_dist             filtered={k: v for k, v in shortest.items() if k in osm_query['nodeid'].values and (v <= max_length)}             shortest_nodes = osm_query[osm_query['nodeid'].isin(filtered.keys())]              hexpoint[f"density_{functionname}"]=len(shortest_nodes)/square             hexpoint[f"count_{functionname}"]=len(shortest_nodes)         else:             hexpoint[f"density_{functionname}"]=0             hexpoint[f"count_{functionname}"]=0              #print(hexpoint)     #print("End Current Time =", datetime.now().strftime("%D-%H:%M:%S"))     print(hexpoint.name)      return hexpoint     # # create subset of hexjoin # buf=hexjoin.loc['891fa0a0623ffff'].geometry.buffer(800) #create buffer around sample (burtscheid) # hexjoin_sub=hexjoin[hexjoin.intersects(buf)]# select all of hexjoin that are insde buf  #define patitions part=mp.cpu_count()  #create a template for the output outputdf=gpd.GeoDataFrame(columns=hexjoin.columns) outputdf["geometry"]=outputdf["geometry"].astype("geometry") for n,i in functiondict:     outputdf[f"density_{n}"]=0.00     outputdf[f"count_{n}"]=0 outputdf=dgpd.from_geopandas(outputdf, npartitions=part)   # calculate shortest path per row hexjoin_dgpd=0 hexjoin_dgpd=dgpd.from_geopandas(hexjoin, npartitions=part) hexjoin_dgpd=hexjoin_dgpd.apply(calcFunctionDensity, functiondict=functiondict, g=graph, walking_dist=walking_distance, axis=1, meta=outputdf)    hexjoin_dgpd=hexjoin_dgpd.compute() ```   This is the corresponding error before the core dumps: ``` /home/jv168059/miniconda3/envs/modulbaukasten/lib/python3.11/site-packages/pyproj/transformer.py:820: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)   return self._transformer._transform_point( /home/jv168059/miniconda3/envs/modulbaukasten/lib/python3.11/site-packages/pandas/core/dtypes/cast.py:1641: DeprecationWarning: np.find_common_type is deprecated.  Please use `np.result_type` or `np.promote_types`. See https://numpy.org/devdocs/release/1.25.0-notes.html and the docs for more information.  (Deprecated NumPy 1.25)   return np.find_common_type(types, []) /home/jv168059/miniconda3/envs/modulbaukasten/lib/python3.11/site-packages/pandas/core/dtypes/cast.py:1641: DeprecationWarning: np.find_common_type is deprecated.  Please use `np.result_type` or `np.promote_types`. See https://numpy.org/devdocs/release/1.25.0-notes.html and the docs for more information.  (Deprecated NumPy 1.25)   return np.find_common_type(types, []) /home/jv168059/miniconda3/envs/modulbaukasten/lib/python3.11/site-packages/pandas/core/dtypes/cast.py:1641: DeprecationWarning: np.find_common_type is deprecated.  Please use `np.result_type` or `np.promote_types`. See https://numpy.org/devdocs/release/1.25.0-notes.html and the docs for more information.  (Deprecated NumPy 1.25)   return np.find_common_type(types, []) double free or corruption (fasttop) /var/spool/slurm/job43691003/slurm_script: line 22: 178016 Aborted                 (core dumped) python3 -u osmShortestPath.py ```
