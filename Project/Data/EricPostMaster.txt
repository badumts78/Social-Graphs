issue
Fix for issue 6300 - Add common_neighbors support for directed graphs#TITLE_END#Removed DiGraph restrictions on `nx.common_neighbors`. Tested it on its own as well as `nx.jaccard_coefficient` because I originally discovered the lack of DiGraph support while trying to compute Jaccard coefficients. I'm stoked to have this fixed!  Didn't really have to make any code changes, just removed the DiGraph restriction decorators, updated the docstrings, and removed the NotImplemented tests for DiGraphs on those two functions.  RE: [Issue 6300](https://github.com/networkx/networkx/issues/6300) 
issue
Update Contributor Guide to clarify pytest setup#TITLE_END#The conda virtual environment setup instructions say to enter `PYTHONPATH=. pytest networkx`, but it doesn't work in Anaconda Prompt. In Anaconda Prompt, you only need to enter `pytest networkx`. I got stuck on it, and the only way I solved it was by finding a discussion thread from earlier this year where someone happened to post (off topic) that they were stuck on it, and someone else responded with the answer. üòÖ
issue
Update installation test instructions#TITLE_END#Small text update to resolve [Issue 6302](https://github.com/networkx/networkx/issues/6302). 
issue
Add auto-margin scaling in draw_networkx_nodes function (fix for issue 3443)#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Pull request addressing [issue 3443](https://github.com/networkx/networkx/issues/3443)  - [x] Run Black - [x] Passed tests
comment
Jumping in because this seems like an interesting problem, if not a bit sticky...  @rossbar, I looked into how matplotlib treats markersize. I was hoping that we could just use `ax.relim()` to recompute the data limits, taking marker size into account. Unfortunately, the `draw_networkx_nodes` function returns a `matplotlib.collections.PathCollection` object, and `collections` objects are not currently supported by the `ax.relim()` method. So, it seems like matplotlib doesn't take marker size into account when drawing the plot.  So far, the best thing I've been able to come up with is changing the `clip_on` parameter to False in the `node_collection` section of the `draw_networkx_nodes` function, but that just gets the markers to extend past the border of the figure (image below).  ```python node_collection = ax.scatter(         xy[:, 0],         xy[:, 1],         s=node_size,         c=node_color,         marker=node_shape,         cmap=cmap,         vmin=vmin,         vmax=vmax,         alpha=alpha,         linewidths=linewidths,         edgecolors=edgecolors,         label=label,         clip_on=False,     ) ```    I had a couple of ideas, both of which may be sub-optimal, so I'd love some feedback:  - Turn off the border of the figure by default. If there's no visible border and the markers are not cut off, then the only place they might get cut off is if the plot is big enough to go beyond the size of the entire figure (see image below).  ![image](https://user-images.githubusercontent.com/58200144/115965872-29cc5100-a4f9-11eb-83be-877f554303cf.png)  - Adjust `ax.margins()` at the end of the `draw_networkx_nodes` function to account for some percentage of the node size, like maybe half or something. I'm still a bit confused as to how to do that because `ax.margins()` is measured in inches, but `node_size` is in points. Google says points to inches is a 72:1 ratio     - Potential drawback to this: It might create some goofy scale problems. If an array of node sizes was passed, we'd have to build in something to use the average, largest, smallest, etc.     - A related possibility would be to take the size of the node and then add it to the axis lengths.  @Gopal-Dahale, have you been working on this at all?
comment
Okay, one more quick thing I just tried... I added this to the end of the `draw_networkx_nodes` function to set `ax.margins()` based on the provided `node_size` parameter.  ```python     # Currently only works if a single node size is passed     if node_size >= 500:         ax.margins((node_size/100)/72,(node_size/100)/72)     else:         #small markers get a bit more slack         ax.margins((node_size/50)/72,(node_size/50)/72) ```  ### Results: #### `node_size=1100` ![image](https://user-images.githubusercontent.com/58200144/115966669-add40800-a4fc-11eb-8964-35d4f19b4d70.png)  #### `node_size=800` ![image](https://user-images.githubusercontent.com/58200144/115966607-6a799980-a4fc-11eb-8381-b97265885b6e.png)  #### `node_size=500` ![image](https://user-images.githubusercontent.com/58200144/115966638-93019380-a4fc-11eb-9947-1bacc9b2789e.png)  #### `node_size=300` - `else` statement has kicked in ![image](https://user-images.githubusercontent.com/58200144/115966649-9bf26500-a4fc-11eb-8a1b-abd271ab3ae7.png)  Not sure if it's necessary, but if we can get the coordinates of each of the points, we could identify the node sizes of the furthest node vertically and the furthest node horizontally and then set the margins based on them. Could be done using the `pos` parameter, but I'm not sure how to connect that back to the corresponding node size.
comment
@Gopal-Dahale - I wouldn't mind the help if you want to take a look at it as well! Matplotlib can really give me fits, so I'd love to have an extra pair of eyes. üëÄ üòÑ If not, that's fine too - I just wanted to make sure you knew I wasn't trying to keep it for myself!
comment
I've continued researching a bit today and haven't been able to turn up anything in Matplotlib that takes marker size into account when drawing the plot. (maddening!) The closest thing I found is a [bubble chart example](https://matplotlib.org/stable/gallery/misc/packed_bubbles.html#sphx-glr-gallery-misc-packed-bubbles-py), but I think the bubbles are treated differently because they are areas rather than markers.  @rossbar, I thought more about edge cases that might cause re-scaling issues, particularly if one of your edge nodes happens to be relatively enormous and squishes everything to the middle of the plot. The simplest solution I've come up with so far is a simple `auto_margins` parameter for the function that, when `True`, uses the code below to re-calculate margins. Otherwise, it just goes with the NX defaults. The default could be set to whichever you think is more commonly needed.  Thanks, @dschult, for the `zip()` suggestion. I used that to create x- and y-axis margins based on the largest nodes closest to the edges of the plot. I forked the NX repo and created my own [branch with the changes](https://github.com/EricPostMaster/networkx/blob/branch_sims/networkx/drawing/nx_pylab.py) to `nx_pylab`, but this is the main piece I added to the function:  ```python     if auto_margins:         node_coords_sizes = list(zip(pos.items(), node_size_list))          x_min = sorted(node_coords_sizes, key=lambda a:a[0][1][0], reverse=False)[0]         x_max = sorted(node_coords_sizes, key=lambda a:a[0][1][0], reverse=True)[0]         x_node_size = max([x_min, x_max], key=itemgetter(1))[1]          if x_node_size >= 500:             x_margin = (x_node_size/100)/72         else:             x_margin = (x_node_size/50)/72          y_min = sorted(node_coords_sizes, key=lambda a:a[0][1][1], reverse=False)[0]         y_max = sorted(node_coords_sizes, key=lambda a:a[0][1][1], reverse=True)[0]         y_node_size = max([y_min, y_max], key=itemgetter(1))[1]          if y_node_size >= 500:             y_margin = (y_node_size/100)/72         else:             y_margin = (y_node_size/50)/72          ax.margins(x_margin, y_margin) ```  It takes the nodes that are furthest to the right (`x_max`) and left (`x_min`), selects the largest of the two (`x_node_size`), and then calculates the new horizontal margin (`x_margin`). Then it does the same thing with the highest and lowest points and calculates the new vertical margin. Lastly, `ax.margins()` is assigned with those two values.  I'd love feedback on how to get this to the point where it could be merged. Specifically, there's probably a straightforward way to DRY this out, but I'm just not seeing it yet.
comment
@stefanv, PatchCollections are new to me. The S/O page you linked only shows points of one size - do you know if they can plot points of varying sizes? Also, do you know if changing the `ax.scatter` here might impact how the related edge/label functions might display?
comment
Cool, I'll get on it. I probably won't get to it tonight, but should hopefully be able to in the next 24 hours üëç
comment
Done! Funny how fast "the next 24 hours" turns into 72 hours üòÖ
