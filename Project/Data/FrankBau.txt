issue
Complexity of Gupta Suzumura implementation in simple_cycles#TITLE_END#### Current Behavior  I execute ``` G = nx.parse_adjlist(['A D E', 'B D E', 'C A B', 'D A B', 'E C'], create_using=nx.DiGraph) print(list(simple_cycles(G, length_bound=5))) ``` and get the correct list of cycles like (order may vary): `[['A', 'D'], ['A', 'D', 'B', 'E', 'C'], ['A', 'E', 'C'], ['A', 'E', 'C', 'B', 'D'], ['E', 'C', 'B'], ['D', 'B']]`  I try to check the complexity of the implementation by extracting the underlying core function `_bounded_cycle_search` from `cycles.py`: ``` print(list(_bounded_cycle_search(G, ['A'], 5))) ``` and again get the correct cycles starting in 'A': `[['A', 'D'], ['A', 'D', 'B', 'E', 'C'], ['A', 'E', 'C'], ['A', 'E', 'C', 'B', 'D']]`  But, when I add the following line to `_bounded_cycle_search`: ```                     if lock.get(u, length_bound) < length_bound - bl + 1:                         lock[u] = length_bound - bl + 1 +                        print(f'relax lock[{u}] = {lock[u]}')                         relax_stack.extend((bl + 1, w) for w in B[u].difference(path)) ``` I get unreasonably high values for some locks: ``` relax lock[E] = 5 relax lock[B] = 5 relax lock[D] = 5 relax lock[B] = 5 relax lock[C] = 5 relax lock[E] = 5 relax lock[A] = 5 ```  ### Expected Behavior  When I follow the original paper or use a 1:1 recursive implementation like the one by @boothby  in https://github.com/networkx/networkx/pull/6461#issuecomment-1461154174 the locks are tighter: ``` ['A', 'D'] ['A', 'D', 'B', 'E', 'C'] relax Lock[C] = 5 relax Lock[E] = 4 relax Lock[B] = 3 relax Lock[D] = 5 ['A', 'E', 'C'] relax Lock[C] = 5 relax Lock[E] = 4 relax Lock[A] = 4 ['D', 'B'] relax Lock[B] = 5 relax Lock[C] = 4 relax Lock[E] = 3 relax Lock[D] = 4 ['E', 'C', 'B'] relax Lock[B] = 5 relax Lock[C] = 4 relax Lock[E] = 3 ``` see the backtracking with increasing `blen` (==decreasing locks) after finding `['A', 'D', 'B', 'E', 'C']` for example.  So, one cannot be sure that the complexity analysis given in the paper (which depends on clever lock settings) really holds for the current non-recursive implementation.  ### Steps to Reproduce  The above DiGraph was found by exaustive search of small strongly connected DiGraphs.  ### Environment  Win11  Python version: 3.12.10 NetworkX version: 3.4.2   ### Additional context  Note that the recursive implementation misses cycle `['A', 'E', 'C', 'B', 'D']` (!) which might be another issue with the algorithm. 
