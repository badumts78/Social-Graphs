issue
Change function calls to address pandas linting#TITLE_END#% `ruff check --select=NPY,PD --statistics` ``` 18	PD901 	[ ] pandas-df-variable-name  3	NPY002	[ ] numpy-legacy-random  2	PD002 	[*] pandas-use-of-inplace-argument  1	PD011 	[ ] pandas-use-of-dot-values [*] fixable with `ruff check --fix` ``` % `ruff check --select=PD002 --fix --unsafe-fixes ` # These are ___unsafe-fixes___ so careful review please! ``` Found 2 errors (2 fixed, 0 remaining). ``` As a followup, someone with more NumPy and Pandas expertise than I should try to close the remaining issues. * https://docs.astral.sh/ruff/rules/#numpy-specific-rules-npy
issue
ruff rules PERF to improve performance#TITLE_END#% `ruff check --select=PERF --statistics` ``` 17	PERF401	[ ] manual-list-comprehension 16	PERF102	[*] incorrect-dict-iterator  4	PERF403	[ ] manual-dict-comprehension  1	PERF402	[ ] manual-list-copy [*] fixable with `ruff check --fix` ``` `Benchmark PR / benchmark (pull_request)` Skipped --  ðŸ˜¢  This might be interesting to run on these changes.  Please read the ___Why is this bad?___ section of each ruff rule to understand how these transformations improve performance.  % [`ruff rule PERF401`](https://docs.astral.sh/ruff/rules/manual-list-comprehension) # manual-list-comprehension (PERF401)  Derived from the **Perflint** linter.  Fix is sometimes available.  ## What it does Checks for `for` loops that can be replaced by a list comprehension.  ## Why is this bad? When creating a transformed list from an existing list using a for-loop, prefer a list comprehension. List comprehensions are more readable and more performant.  Using the below as an example, the list comprehension is ~10% faster on Python 3.11, and ~25% faster on Python 3.10.  Note that, as with all `perflint` rules, this is only intended as a micro-optimization, and will have a negligible impact on performance in most cases.  ## Example ```python original = list(range(10000)) filtered = [] for i in original:     if i % 2:         filtered.append(i) ```  Use instead: ```python original = list(range(10000)) filtered = [x for x in original if x % 2] ```  If you're appending to an existing list, use the `extend` method instead: ```python original = list(range(10000)) filtered.extend(x for x in original if x % 2) ```  Take care that if the original for-loop uses an assignment expression as a conditional, such as `if match:=re.match("\d+","123")`, then the corresponding comprehension must wrap the assignment expression in parentheses to avoid a syntax error. 
