issue
Correct louvain formula#TITLE_END#Closes #5175   After playing around with the modularity formula I figured we weren't accounting for the modularity cost when we remove a node from its original community.  The following example can prove the correctness of the new formula:  Initially we have a partition and we move node 2 from the 0th community into the 1st community. We use NetworkX's `modularity` function to measure the actual gain.  ```Python >>> import networkx as nx >>> from networkx.algorithms.community import louvain_communities, quality >>> G = nx.karate_club_graph() >>> partition = louvain_communities(G, weight="weight", seed=123) >>> print(partition) [{1, 2, 3, 7, 12, 13}, {0, 4, 5, 6, 10, 11, 16, 17, 19, 21}, {23, 24, 25, 27, 28, 31}, {32, 33, 8, 9, 14, 15, 18, 20, 22, 26, 29, 30}] >>> before = quality.modularity(G, partition, weight="weight") >>> partition[0].remove(2) >>> partition[1].add(2) >>> print(partition) [{1, 3, 7, 12, 13}, {0, 2, 4, 5, 6, 10, 11, 16, 17, 19, 21}, {23, 24, 25, 27, 28, 31}, {32, 33, 8, 9, 14, 15, 18, 20, 22, 26, 29, 30}] >>> after = quality.modularity(G, partition, weight="weight") >>> print(after - before) -0.0553494124922696 ``` The below snippet computes both the remove and insert parameters to calculate the gain. ``` Python3 Stot = 0 RStot = 0 for n in partition[1]:     if n == 2:         continue     Stot += G.degree(n, weight="weight") for n in partition[0]:     RStot += G.degree(n, weight="weight")  r_wt = 0 wt = 0 for u, w in G[2].items():     if u in partition[0]:         r_wt += w["weight"]     if u in partition[1]:         wt += w["weight"]  m = G.size(weight="weight") ki = G.degree(2, weight="weight") ```  Finally: ```Python3 >>> gain = (wt) / (m) - (Stot * ki) / (2 * m ** 2) # Original formula didn't take into consideration the removal of node from initial community >>> remove_cost = -r_wt / m + (RStot * ki) / (2 * m ** 2) >>> print(gain) # Incorrect Result -0.011131725417439706 >>> print(remove_cost) -0.04421768707482993 >>> print(remove_cost + gain) # Actual modularity gain from whole movement process -0.05534941249226964 ```  PS. I have added a test for the issue's case which doesn't loop forever with the new formula. Feel free to propose any better test cases that I might miss.
issue
Add exception for unconnected graph#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Closes #5286.  This PR checks if the Graph is weakly connected to avoid the recursion error described in #5286  Alternatively the issue could be solved by checking for cycles like this: ```Python3 try:     nx.find_cycles(G, source=root)     raise TypeError("G contains cycles") except nx.NetworkXNoCycle:     pass ``` but since it doesn't really make sense to create a tree from a graph that isn't connected I feel the `is_weakly_connected` choice is better.
issue
`json_graph.tree_data` can cause maximum recursion depth error.#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  ### Current Behavior <!--- Tell us what happens instead of the expected behavior --> Currently the algorithm compares the `n_nodes` with `n_edges` to check if `G` is a tree. https://github.com/networkx/networkx/blob/0cc70051fa0a979b1f1eab4af5b6587a6ebf8334/networkx/readwrite/json_graph/tree.py#L74-L75  This check can be bypassed with specific inputs and cause a recursion error.  ### Expected Behavior <!--- Tell us what should happen --> The code should check whether there are cycles with `root` as the source and raise an exception. Another possible fix would be to check if the graph is not weakly connected.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> ```Python3 >>> import networkx as nx >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)]) >>> G.add_node(4) >>> data = nx.json_graph.tree_data(G, 1) RecursionError: maximum recursion depth exceeded ```  ### Environment <!--- Please provide details about your local environment --> Python version: 3.8.10 NetworkX version: 2.7rc1.dev0 
issue
Add option for arrowsize to be a list#TITLE_END#This PR fixes #3272   Sample code: ```Python >>> import networkx as nx >>> import matplotlib.pyplot as plt >>> G = nx.DiGraph([(0, 1), (0, 2), (1, 3)]) >>> arrowsize=[10, 20, 30] >>> nx.draw(G, arrowsize=arrowsize) >>> plt.show() ``` Produces: ![image](https://user-images.githubusercontent.com/33282622/138859013-0e4fb354-c766-4097-88c8-1f33429d5714.png) 
issue
Add examples and minor documentaion refactor for operators/binary.py#TITLE_END#After going through the binary operators I thought it would be better to have examples that illustrate the differences between the functions.  Note: In `union` function the `name` parameter is not used so I removed it. We could also add something like `R.graph["name"] = name` at the end but it is unnecessary imo.
issue
Deprecate union name param#TITLE_END#As discussed on #5099 I created a separate PR to deprecate the unused `name` parameter from `union` function 
issue
Louvain Community Detection Algorithm#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> This is the PR regarding the implementation of Louvain Community Detection Algorithm.  Work remaining: - [x] Write more extensive documentation - [x] Add more tests - [x] Add resolution parameter - [x] Add support for directed graphs (if doable) - [x] Improve performance for large graphs - [x] Improve `_gen_graph` function either by improving `nx.quotient_graph` or by manually writing code to generate the new graph based on the communities - [x] Add `weights` label inside the `quotient_graph` 
issue
Minor Improvements on Networkx/algorithms/community/quality.py#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Removed some unnecessary imports and fixed some minor docstring issues
issue
Optimize multipartite_layout#TITLE_END#Fixes #4061   Since the logic for drawing the graph in both `vertical` and `horizontal` alignment is the same we can use one loop and just flip the positions.  Results are the same as before. 
comment
First of all, in the undirected case the reason we divide by `2*m` in the second fraction is because in the full formula the first term is divided by `2*m` and the second by `4*m^2` and since we only care whether the modularity gain is positive or negative we can simplify the formula to reduce unnecessary calculations (I have seen other implementations do that).  Your change makes sense in the case @dschult is describing because sometimes it isn't very clear whether we need `m` or `2*m` (here `m` is calculated using NetworkX's built in `graph.size`). I believe the same formula though is being used in the C++ version of the paper's authors you cited which can be found [here](https://github.com/nicolasdugue/DirectedLouvain). You can observe [here](https://github.com/nicolasdugue/DirectedLouvain/blob/23d511c1182a71b30335d2193797ecbc2f9dfb18/src/community_friend_static.cpp#L48-L54) and [here](https://github.com/nicolasdugue/DirectedLouvain/blob/23d511c1182a71b30335d2193797ecbc2f9dfb18/src/graph.cpp#L125-L128) that it seems we use the same `m` version (although I am not a main C++ coder so I could very well be missing something in the code)  Besides that, @rossbar I am not 100% if we want to have the same results in the directed and the undirected case (I admit your example has made me even a little in favour of this PR). In the cited paper they even go ahead and compare the two formulas for the directed and undirected case (which is a different case because they convert the directed graph to an undirected by ignoring the edge direction).  Lastly, the best way to verify the formula is working is to use `nx.algorithms.community.quality.modularity` function to measure the difference and the formula used for the modularity gain. They should be the same (I remember I had tested that for the undirected case and probably for the directed as well but it doesn't harm to redo the check one more time)  P.S. One really helpful explanation of the modularity formula is in [this](https://qr.ae/pvF8oG) quora answer if someone wants to dig a little deeper.  
comment
As it turns out the formula had a lot more issues that were fixed in #5713 so this PR is redundant. l would like to thank you for opening this PR since it sparked more interest to revisit the formula and find all the underlying issues!!
comment
So it seems that we also need to check the neighbor communities of a node in a random order to fix the issue.  When I do that on the example graph provided by @ginandsherry I get a result.
comment
The order in which the nodes are considered definitely affects the outcome as stated by the authors of the algorithm [here](https://arxiv.org/pdf/0803.0476.pdf)  > One should also note that the output of the algorithm depends on the order in which the nodes are considered. Preliminary results on several test cases seem to indicate that the ordering of the nodes does not have a significant influence on the modularity that is obtained. However the ordering can influence the computation time. The problem of choosing an order is thus worth studying since it could give good heuristics to enhance the computation time.  
comment
Here is the original implementation in C++ for the Directed Louvain https://github.com/nicolasdugue/DirectedLouvain  This is the function that computes the modularity gain on each step https://github.com/nicolasdugue/DirectedLouvain/blob/00398d5659ee49973171f67db4f6dacb4230bfbf/include/community.h#L121-L134  It looks similar to the one we have in NetworkX and they don't shuffle the nodes after every pass. Maybe I am missing something in the formula, but this would be a good place to investigate before implementing a shuffling after every pass which could reduce the algorihtm's performance
comment
Thank you for your time reporting this. The issue seems similar to #5175 so I am going to close this. Feel free to reopen it if you think it's different!
comment
I can reproduce this error and from what I see the `eccentricities` option is not listed in the doc string as well.  Also if `compute` is not one of the five values `"diameter", "radius", "periphery", "center", "eccentricities"` it will throw an `UnboundLocalError` on the next line since `ruled_out` variable won't be initialized. https://github.com/networkx/networkx/blob/6a0b4faf09ec9d3d40ad93e2ec9b431d6bab5dc4/networkx/algorithms/distance_measures.py#L155
comment
Nice catch, thank you! You are right regarding the tests, depending on the python version you might get some slightly different results so you should change it to `assert mod1 < mod2`.
comment
Hello, I think this bug is a duplilcate of  #4966 and it was solved by #4965 but is not yet included in the latest stable NetworkX release.
comment
I would like to work on implementing Louvain Community Detection algorithm for the coming GSoC. Am I supposed to build on top of this PR?
comment
Hello I am a newcomer and would like to contribute. Can you explain a bit more about the issue? Basically you want to make one function to handle both bipartite_layout and multipartite_layout or optimize their respective if statements?
