issue
I have a question about `nx.optimal_edit_paths(G1, G2)`.#TITLE_END#  I have been conducting a experiment for computing graph similarity.   I have a question about `nx.optimal_edit_paths(G1, G2)`. In the [documentation of it](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.similarity.optimal_edit_paths.html), it is written that this function **Returns all minimum-cost edit paths transforming G1 to G2**.   I use the function in my code and I run it. my code is below.  Even though `G1` and `G2` are exactly same graph and their graph_edit_cost is 0,  there a a lot of optimal_edit_paths.   ```python N = 3 G1 = nx.complete_graph(N) G2 = nx.complete_graph(N)  edit_path, graph_edit_cost = nx.optimal_edit_paths(G1, G2) print(f"graph edit cost: {graph_edit_cost}") for p in edit_path:     node_edit, edge_edit = p     print(f"node_edit: {node_edit}")     print(f"edge_edit: {edge_edit}")     print("--"*30) ```  the output is below.  As I said it before, graph_edit_cost is zero because `G1` and `G2` are exactly same graphs.  but there are lots of optimal path when paths was derived by `nx.optimal_edit_paths(G1, G2)`.  I don't know why this happend. It doesn't look like 'optimal' because they don't have same edit cost.   ``` graph edit cost: 0.0 node_edit: [(0, 0), (1, 1), (2, 2)] edge_edit: [((0, 1), (0, 1)), ((0, 2), (0, 2)), ((1, 2), (1, 2))] ------------------------------------------------------------ node_edit: [(0, 0), (2, 1), (1, 2)] edge_edit: [((0, 2), (0, 1)), ((0, 1), (0, 2)), ((1, 2), (1, 2))] ------------------------------------------------------------ node_edit: [(1, 0), (0, 1), (2, 2)] edge_edit: [((0, 1), (0, 1)), ((0, 2), (1, 2)), ((1, 2), (0, 2))] ------------------------------------------------------------ node_edit: [(1, 0), (2, 1), (0, 2)] edge_edit: [((1, 2), (0, 1)), ((0, 1), (0, 2)), ((0, 2), (1, 2))] ------------------------------------------------------------ node_edit: [(2, 0), (0, 1), (1, 2)] edge_edit: [((0, 2), (0, 1)), ((0, 1), (1, 2)), ((1, 2), (0, 2))] ------------------------------------------------------------ node_edit: [(2, 0), (1, 1), (0, 2)] edge_edit: [((1, 2), (0, 1)), ((0, 1), (1, 2)), ((0, 2), (0, 2))] ------------------------------------------------------------ ```  And also, if the function is correct, How can I transform `G1` to `G2` base on that operations(node_edit, edge_edit)? I don't know how those operations have to be applied to `G2` to make `G2`.    I always appreciate your help in this library.  becasue of that, I've learned a lot about network science.   If you feel my text is rude or not polite, it is because of my lack of english.  sorry about that. 
issue
In `nx.closeness_centrality(G, distance='distance')` even though `distance` doesn't exist in the edge attribute dictionary, it doesn't raise any error or warning.#TITLE_END#When I calculate the centrality of nodes in network, I use both weighted centrality and unweighted centrality. "Unweighted centrality" means that "all edges have same weight and distance". and "Weighted centrality" means their weights are different.   The way to calculate them is easy like below.   ```python # for unweighted centrality  nx.closeness_centrality(G) # for weighted centrality  nx.closeness_centrality(G, distance='distance').items(): ```  However, there is a small problem(or warning).  In below simple code, 'distance' is not in edge attribute dictionary. But, I passed it `nx.closeness_centrality(G, distance='distance')` as argument.  Even though `distance` doesn't exist in the edge attribute dictionary, it doesn't raise any error or warning. I don't know the weighted centrality wasn't calculated in the correct way.   ```python import networkx as nx  G = nx.Graph() G.add_edges_from([     (0, 1, {'weight': 0.5}), (1, 2, {'weight': 0.2}), (2, 0, {'weight': 0.3}),])  print("== CLOSENESS CENTRALITY") for k, v in nx.closeness_centrality(G).items():     print(k, v) print("== WEIGHTED CLOSENESS CENTRALITY") # actually, key 'distance' doesn't exist in the edge attribute distionary.  for k, v in nx.closeness_centrality(G, distance='distance').items():     print(k, v) print("=="*20) ```  The output is below. When the argument, 'distance' doesn't exist in edge attribute dictionary, it runs like Unweighted centrality. But, it doesn't make me know. I just think why two centrality are exactly and same, how it could be, for long time. This error makes me waste my effort.  ``` == CLOSENESS CENTRALITY 0 1.0 1 1.0 2 1.0 == WEIGHTED CLOSENESS CENTRALITY 0 1.0 1 1.0 2 1.0 ```  I think this is not an error but, it could make people confused.  Therefore, when the argument name of `distance` doesn't exist in any edge attribute name, it would be better to raise warning message for users.   If you feel that I am rude, it is because of my lack of english. Sorry. I don't want to hurt you.  I always thanks for your help. I have used `networkx` a lot for my research. With your help, I've learned a lot.      
issue
add new function "rescale_layout_dict" again#TITLE_END#There are some comment to integer it. and I fixed it all.  - You should include the new function in the all variable defined at the top (to have it imported to the networkx namespace. ==> **complete**  - You should add "See Also" sections to both rescale function's doc_string to refer to each other ==> **complete**  - You should update the documentation page doc/reference/drawing.rst by adding the name of the new function to the list of layout functions ==> **complete**  - You should add a few simple tests to networkx/drawing/tests/test_layout.py to make sure this function runs and gives reasonable answers. ==> **complete, make simple test for checking empty graph**  - The first line defining pos_v unpacks the position tuple only to repack it as a tuple again. Could do: `pos_v = np.array(pos.values())` or just remove the line and in the next line replace pos_v with `np.array(pos.values())`. ==> **little changed it. However, `pos_v = np.array(pos.values())` will raise error "`AttributeError: 'dict_values' object has no attribute 'shape'`" in rescale_layout, so I should changed it to` pos_v = np.array(list(pos.values()))` with converting list**   Thanks for your help. If there were more issues or feedback to reflect it, Please let me know.
issue
nx.rescale_layout input problem. #TITLE_END#I am using `networkx.drawing.layout.rescale_layout`.  However, in this function, input is fixed to `np.array`. In fact, other layouts (`nx.spring_layout`, `nx.spectral_layout`, etc.) return a dictionary (key: node label, value: pos tuple (x, y)).  So, for `networkx.drawing.layout.rescale_layout`, I think it would be useful to change the input to dictionary (key: node label, value: pos tuple (x, y)).  To change to the code:  I think this case is more versatile and I would like to ask you what you think.  ```python def rescale_layout(pos, scale=1):     pos_v = np.array([[v[0], v[1]] for v in pos.values()])     lim = 0  # max coordinate for all axes     for i in range(pos_v.shape[1]):         pos_v[:, i] -= pos_v[:, i].mean()         lim = max(abs(pos_v[:, i]).max(), lim)     # rescale to (-scale, scale) in all directions, preserves aspect     if lim > 0:         for i in range(pos_v.shape[1]):             pos_v[:, i] *= scale / lim     return {k: tuple(v) for k, v in zip(pos.keys(), pos_v)} ```
issue
I think `nx.vote_rank` make wrong result.#TITLE_END#As the `vote_rank` algorithm was written in the origianl paper [Identifying a set of influential spreaders in complex networks](https://www.nature.com/articles/srep27823), **the voting ability of already elected nodes have to be zero**.   But, in `networkx.vote_rank`, the voting ability of already elected node could be negative value.  To check if the voting ability could be negative value, I copied the code of `nx.vote_rank` from [networkx documentation](https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/centrality/voterank_alg.html#voterank), and add simple code that print node having negative value.   ```python def voterank(G, number_of_nodes=None, max_iter=10000):     voterank = []     if len(G) == 0:         return voterank     if number_of_nodes is None or number_of_nodes > len(G):         number_of_nodes = len(G)     avgDegree = sum(deg for _, deg in G.degree()) / float(len(G))     # step 1 - initiate all nodes to (0,1) (score, voting ability)     for _, v in G.nodes(data=True):         v['voterank'] = [0, 1]     # Repeat steps 1b to 4 until num_seeds are elected.     for _ in range(max_iter):         # step 1b - reset rank         for _, v in G.nodes(data=True):             v['voterank'][0] = 0         ####################################         ####################################         # this code was added by me to check if voting ability is negative         for n in G:             node_voting_ability = G.nodes[n]['voterank'][1]             if node_voting_ability < 0.0:                 print(n, node_voting_ability)         ####################################         ####################################         # step 2 - vote         for n, nbr in G.edges():             G.nodes[n]['voterank'][0] += G.nodes[nbr]['voterank'][1]             G.nodes[nbr]['voterank'][0] += G.nodes[n]['voterank'][1]         for n in voterank:             G.nodes[n]['voterank'][0] = 0         # step 3 - select top node         n, value = max(G.nodes(data=True), key=lambda x: x[1]['voterank'][0])         if value['voterank'][0] == 0:             return voterank         voterank.append(n)         if len(voterank) >= number_of_nodes:             return voterank         # weaken the selected node         G.nodes[n]['voterank'] = [0, 0]         # step 4 - update voterank properties         for nbr in G.neighbors(n):             G.nodes[nbr]['voterank'][1] -= 1 / avgDegree     return voterank  N = 10 G = nx.scale_free_graph(n=N, seed=0) # Digraph => Graph G = nx.Graph(G) # remove self-loop G.remove_edges_from([(u, v) for u, v in G.edges() if u==v]) assert nx.is_connected(G) voterank(G) ```   the output of code execution is below. Some nodes have definitely negative value. And also, nodes that have negative voting ability are already elected nodes.  Therefore, the result of `nx.vote_rank` could be little different with the origianl vote rank algorithm.   ``` 1 -0.3333333333333333 1 -0.3333333333333333 1 -0.6666666666666666 2 -0.3333333333333333 7 -0.3333333333333333 ```  If I am wrong, please let me know.   I always thanks for your support and `networkx`.  
issue
Is nx.communicability the sum of **Closed walks**?#TITLE_END#It might be a very minor issue.   In the documentation about [networkx - Communicability](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.communicability_alg.communicability.html#networkx.algorithms.communicability_alg.communicability), it was written like below.   > The communicability between pairs of nodes in `G` is the sum of **closed walks** of different lengths starting at node `u` and ending at node `v`.  I've learned that **Closed walks** means "A walk if the starting vertex is the same as the ending vertex" otherwise the walk is Open. However, `nx.communicability`computes also the communicability between different nodes so, I think it would be better **closed walks** is changed to just **walks**.   If I'm wrong, please tell me.  I always thanks for your help.  
issue
Question: why `nx.subgraph_view` is amazingly faster than `G.subgraph().edge_subgraph()`? #TITLE_END#Last night, i just wonder the way to extract sub-Graph from original graph using NetworkX. There are two ways to extract it.   **The first one** is `nx.subgraph_view(G, filter_node, filter_edge)`,  the type of parameter `filter_node`, and `filter_edge` are just function.   **The second one** is `G.subgraph(nodes).edge_subgraph(edges)`. Using chaining method, filtering nodes and filtering edges. the type of parameter `nodes` and `edge` is just `list` of string(node_name, or edge tuple)  I conduct a simplex experiment to check which one is faster.  **In conclusion, `nx.subgraph_view(G, filter_node, filter_edge)` is about 3000 times fater than `G.subgraph(nodes).edge_subgraph(edges)`**  I can't understand why it happend even if I read the documentation of Networkx. If there are anyone to know why this happened, please tell me.   Thanks for your help in advance.  If you didn't understand my questions or feel impolite that, it is cause by my lack of english.  Sorry about that.   the ouput of experiment and code for experiment are below.   ``` == Graph Generation Done nx.subgraph_view(G)         :     0.000141 G.subgraph().edge_subgraph():     0.485764 ======================================== ```  ```python import networkx as nx import numpy as np import time  # GENERATE Graph size N = 1000  # 3000 p = 0.6 G = nx.fast_gnp_random_graph(N, p)  # UPDATE weight-dict for nodes and edges node_weight_dict = {n: v for n, v in zip(G.nodes(), np.random.uniform(0, 1, len(G.nodes())))} edge_weight_dict = {e: v for e, v in zip(G.edges(), np.random.uniform(0, 1, len(G.edges())))} for n in (n for n in G.nodes()):     G.nodes[n]['weight'] = node_weight_dict[n] for e, v in edge_weight_dict.items():     G.edges[e]['weight'] = edge_weight_dict[e] print("== Graph Generation Done") #print("==" * 20)  ######################################## # USE nx.subgraph_view(G, filter_node, filter_edge) ######################################## start_time = time.time() nx_subG = nx.subgraph_view(G=G,                            filter_node=lambda n_name: True                            if G.nodes[n_name]['weight'] > 0.5 else False,                            filter_edge=lambda n1_name, n2_name: True                            if G.edges[                                (n1_name, n2_name)]['weight'] > 0.5 else False) #print(G.nodes(data=True)) print(f"nx.subgraph_view(G)         : {time.time() - start_time:12.6f}") #print(f"FROZEN: {nx.is_frozen(nx_subG)}") ######################################## # G.subgraph().edge_subgraph() ######################################## start_time = time.time() # make node subg NODE_subG = G.subgraph(     nodes=(n for n, n_attr in G.nodes(data=True) if n_attr['weight'] > 0.5)) # make edge subg subG = NODE_subG.edge_subgraph(     edges=((e1, e2) for e1, e2, e_attr in NODE_subG.edges(data=True)            if e_attr['weight'] > 0.5)) print(f"G.subgraph().edge_subgraph(): {time.time() - start_time:12.6f}") #print(f"FROZEN: {nx.is_frozen(subG)}") print("=="*20)  assert len(nx_subG.nodes()) == len(subG.nodes()) assert len(nx_subG.edges()) == len(subG.edges()) # Checking isomophism by is_isomorphic is better and exact but it takes much time. # print(nx.is_isomorphic(subG, nx_subG)) ``` 
issue
add a new function "rescale_layout_dict" again. #TITLE_END#There are some comment to integer it. and I fixed it all.   1. You should include the new function in the __all__ variable defined at the top (to have it imported to the networkx namespace. ==> **complete** 2. You should add "See Also" sections to both rescale function's doc_string to refer to each other ==> **complete** 3. You should update the documentation page doc/reference/drawing.rst by adding the name of the new function to the list of layout functions ==> **complete** 4. You should add a few simple tests to networkx/drawing/tests/test_layout.py to make sure this function runs and gives reasonable answers. ==> **complete, make simple test for checking empty graph**  5. The first line defining pos_v unpacks the position tuple only to repack it as a tuple again. Could do: pos_v = np.array(pos.values()) or just remove the line and in the next line replace pos_v with np.array(pos.values()). ==> **little changed it. However, `pos_v = np.array(pos.values())` will raise error "AttributeError: 'dict_values' object has no attribute 'shape'" in `rescale_layout`, so I should changed it to `pos_v = np.array(list(pos.values()))` with converting list**  Thanks for your help.  If there were more issues or feedback to reflect it, Please let me know.
issue
add new function rescale_layout_dict#TITLE_END#the issue was uploaded in [#3129](https://github.com/networkx/networkx/issues/3129)  in function `networkx.drawing.layout.rescale_layout`, input is fixed to `np.array`. In fact, other layouts (`nx.spring_layout`, `nx.spectral_layout`, etc.) return a dictionary (key: node label, value: pos tuple (x, y)).  So, I think it would be useful to add new function(the input is dictionary(key: node label, value: pos tuple (x, y)).  
