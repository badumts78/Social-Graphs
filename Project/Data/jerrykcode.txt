comment
Hello everyone, I'm new to NetworkX and really appreciate these amazing implementations!  I think that for the all-targets case, there might be a simpler appraoch to optimize: we can record the path for each node only when it is popped from the priority queue (fringe). At that point, the shortest distance to the node has been determined, so we only need to copy the path once per node.  This avoids copying the path during every edge relaxation, and also eliminates the need to reconstruct paths at the end. In my opinion, this approach should be efficient for both dense and sparse graphs.  The code could look like this: ```python     pred_dict = pred     if pred is None and paths is not None:         pred_dict = {}          G_succ = G._adj  # For speed-up (and works for both directed and undirected graphs)      dist = {}  # dictionary of final distances     seen = {}     # fringe is heapq with 3-tuples (distance,c,node)     # use the count c to avoid comparing nodes (may not be able to)     c = count()     fringe = []     for source in sources:         seen[source] = 0         heappush(fringe, (0, next(c), source))     while fringe:         (d, _, v) = heappop(fringe)         if v in dist:             continue  # already searched this node.         dist[v] = d         if paths is not None and target is None: # need paths for all nodes             if v in sources:                 paths[v] = [v] # in case the caller did not set paths[source] to source             else:                 # copy only once for each node                 paths[v] = paths[pred_dict[v][0]] + [v]         if v == target:             break         for u, e in G_succ[v].items():             cost = weight(v, u, e)             if cost is None:                 continue             vu_dist = dist[v] + cost             if cutoff is not None:                 if vu_dist > cutoff:                     continue             if u in dist:                 u_dist = dist[u]                 if vu_dist < u_dist:                     raise ValueError("Contradictory paths found:", "negative weights?")                 elif pred is not None and vu_dist == u_dist:                     pred[u].append(v)             elif u not in seen or vu_dist < seen[u]:                 seen[u] = vu_dist                 heappush(fringe, (vu_dist, next(c), u))                 if paths is not None:                     if target is not None:                         paths[u] = paths[v] + [u]                     #else No need to update paths here                 if pred is not None:                     pred[u] = [v]                 elif pred_dict is not None:                     pred_dict[u] = [v]             elif vu_dist == seen[u]:                 if pred is not None:                     pred[u].append(v)      # No need to reconstruct paths if target is None   ```  The core change is just these lines:  ```python if v in sources:     paths[v] = [v] # in case the caller did not set pred[source] to source else:     # copy only once for each node     paths[v] = paths[pred_dict[v][0]] + [v] ``` and removes the copy at each edge relaxation.
