issue
WIP: Add guide to setting up a development environment#TITLE_END#This PR adds a guide to setting up a development environment for newbies.  **Motivation:**  - I recently contributed #2522 to NetworkX (my first open source contribution)  - Learning how to set up the development environment took longer than adding the commits  - This guide should make it easier for relative novices to contribute  The guide uses Anaconda's virtual environments to create a clean environment and then installs a git cloned copy of NetworkX along with its required packages.
issue
Add random_state keyword argument to random_layout and spring_layout#TITLE_END#This PR adds functionality that allows reproducible node layouts to be generated by `random_layout` and `spring_layout` via the `seed` keyword argument.  ---  Re-running code that employs stochastic layout algorithms to generate figures positions nodes differently each time:  ``` import networkx as nx, matplotlib.pyplot as plt  G = nx.erdos_renyi_graph(10, 0.4, seed=1)  fig, axes = plt.subplots(3, 3) axes = axes.flatten()  for ax in axes:     pos = nx.spring_layout(G)     nx.draw_networkx(G, pos, ax=ax, node_size=150, font_color='w')     ax.axis('off') ```  ![random](https://user-images.githubusercontent.com/10820071/33148790-22c976f6-cfc5-11e7-9791-5f55e5dfe5e1.png)   This PR adds the `state` keyword argument to the `random_layout` and `spring_layout` functions to set the seed of `numpy.random.seed`. Setting `seed` allows reproducible node layouts to be generated:  ``` fig, axes = plt.subplots(3, 3) axes = axes.flatten()  for ax in axes:     pos = nx.spring_layout(G, random_seed=1)     nx.draw_networkx(G, pos, ax=ax, node_size=150, font_color='w')     ax.axis('off') ``` ![seeded](https://user-images.githubusercontent.com/10820071/33148794-273c20b2-cfc5-11e7-8864-74c329908770.png)  This feature will be very useful when generating figures for presentations/papers.
issue
Implement __eq__ dunder method in graph classes to check for isomorphism#TITLE_END#Implementing the `__eq__` dunder method would permit graph isomorphism checking using the builtin equality operator, e.g.`G1 == G2`:  ```python import networkx as nx  class DerivedGraph(nx.Graph):     def __init__(self):         super().__init__()              def __eq__(self, other):         return nx.is_isomorphic(self, other) ``` Test case: ```python G1 = DerivedGraph() G1.add_path([0, 1, 2])  G2 = DerivedGraph() G2.add_path([2, 1, 0])  assert G1 == G2, "Graphs are not isomorphic" ``` Thoughts? Happy to do this myself if I get the go ahead.
issue
Add {to, from}_numpy_array functions, resolves #2479#TITLE_END#* to_numpy_array returns the graph adjacency matrix as a NumPy array  * from_numpy_array returns a graph from NumPy array  * Adapted tests for to_numpy_matrix and from_numpy_matrix, which all pass  Resolves #2479 
issue
Add {to, from}_numpy_array functions#TITLE_END#Should we add a `to_numpy_array` function to generate an `np.array` from a graph and a `from_numpy_array` function for the reverse? These would be similar to the existing `{to, from}_numpy_matrix` functions.  **Motivation:** * Times have changed since #895. * `np.matrix` is as good as deprecated, especially after the introduction of the `@` operator for matrix multiplication of arrays in Python 3.5. * `np.matrix` doesn't always produce the same results as `np.array` and can lead to confusion.
comment
The commute time (CT) between nodes *i* and *j* in some graph *G* is defined as:  CT*ij* = H*ij* + H*ji*  where H is the hitting time you outline above. The expected CTs between all pairs of nodes in *G* can be obtained without directly calculating the random walks. The pseudoinverse of the Laplacian matrix results is a kernel, whose entries correspond to the pairwise dot products of node vectors in a Euclidean space where nodes are exactly separated by their expected CTs. This kernel can be obtained by:  ```python import networkx as nx, numpy as np  G = nx.erdos_renyi_graph(20, 0.3) L = nx.laplacian_matrix(G, nodelist=sorted(G.nodes)).toarray() CTK = np.linalg.pinv(L) ``` For more information I recommend reading papers by Francois Fouss where he derives and explains the properties of this kernel:  http://www.sciencedirect.com/science/article/pii/S0893608012000822 http://ieeexplore.ieee.org/document/4053117/
comment
Did you name a Python script `networkx.py`?  ``` $ echo "from networkx.algorithms import approximation" > networkx.py; python networkx.py  ModuleNotFoundError: No module named 'networkx.algorithms'; 'networkx' is not a package ```
