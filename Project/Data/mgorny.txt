issue
Use type checks in `generators/lattice.py` for Py3.14 compat#TITLE_END#Replace the `TypeError` catching in `networkx/generators/lattice.py` with explicit type checks to make the code more reliable and fix it for Python 3.14.  Catching the exception immediately does not work in the second instance, because the code is constructing a generator, and apparently Python 3.14 does not evaluate the `p in periodic` expression until the generator is actually iterated over.  Given that the function expects either an iterable or a `bool`, explicitly checking for `bool` should both be more readable and more reliable.  The alternative would be to replace the generator with a list comprehension that would be evaluated immediately.  However, the explicit type check seems to be a cleaner solution to the problem.
issue
Test failures with Python 3.14.0b2#TITLE_END#### Current Behavior  The test suite fails when run against Python 3.14.0b2:  ``` ======================================================= short test summary info ======================================================= FAILED networkx/algorithms/tests/test_chordal.py::TestMCS::test_complete_to_chordal_graph - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/tests/test_euler.py::TestIsEulerian::test_is_eulerian - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/connectivity/tests/test_kcutsets.py::test_example_1 - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/tests/test_euler.py::TestIsSemiEulerian::test_is_semieulerian - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/approximation/tests/test_kcomponents.py::test_torrents_and_ferraro_graph - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/tests/test_euler.py::TestHasEulerianPath::test_has_eulerian_path_cyclic - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/approximation/tests/test_kcomponents.py::test_example_1 - TypeError: 'bool' object is not iterable FAILED networkx/algorithms/approximation/tests/test_kcomponents.py::test_example_1_detail_3_and_4 - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_classic.py::TestGeneratorClassic::test_ladder_graph - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_geometric.py::TestNavigableSmallWorldGraph::test_navigable_small_world - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_line.py::TestGeneratorInverseLine::test_line_inverse_line_hypercube - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_lattice.py::TestGridGraph::test_grid_graph - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_lattice.py::TestGridGraph::test_node_input - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_lattice.py::TestHypercubeGraph::test_special_cases - TypeError: 'bool' object is not iterable FAILED networkx/generators/tests/test_lattice.py::TestHypercubeGraph::test_degree_distribution - TypeError: 'bool' object is not iterable ===================================== 15 failed, 5432 passed, 335 skipped, 24 warnings in 24.93s ====================================== ```  They all seem to fail over the same problem:  ```pytb _____________________________________________ TestHypercubeGraph.test_degree_distribution _____________________________________________ [gw9] linux -- Python 3.14.0 /tmp/networkx/.venv/bin/python3  self = <networkx.generators.tests.test_lattice.TestHypercubeGraph object at 0x7f025a7d1090>      def test_degree_distribution(self):         for n in range(1, 10): >           G = nx.hypercube_graph(n)                 ^^^^^^^^^^^^^^^^^^^^^  networkx/generators/tests/test_lattice.py:148:  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <class 'networkx.utils.decorators.argmap'> compilation 541:3: in argmap_hypercube_graph_538     ??? networkx/utils/backends.py:535: in _call_if_no_backends_installed     return self.orig_func(*args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ networkx/generators/lattice.py:169: in hypercube_graph     G = grid_graph(dim)         ^^^^^^^^^^^^^^^ <class 'networkx.utils.decorators.argmap'> compilation 533:3: in argmap_grid_graph_530     ??? networkx/utils/backends.py:535: in _call_if_no_backends_installed     return self.orig_func(*args, **kwargs)            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ networkx/generators/lattice.py:137: in grid_graph     G = next(func)(dim[0])         ^^^^^^^^^^ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  .0 = False  >   func = (cycle_graph if p else path_graph for p in periodic)                                                       ^^^^^^^^ E   TypeError: 'bool' object is not iterable  networkx/generators/lattice.py:133: TypeError ```  â€¦which is weird because it seems that it should handle `TypeError`. I'm going to investigate further, but to be honest I find the try/except approach unreliable.  ### Expected Behavior  Tests passing :-).  ### Steps to Reproduce  ``` uv venv -p 3.14 uv pip install -e .[test] .venv/bin/pytest ```  ### Environment  Gentoo Linux amd64 Python version: 3.14.0b2 NetworkX version: d1c41f886add2ab86c1ce4c1d788d3c286721351  ### Additional context  We're doing early (well, not so "early" anymore) testing for Python 3.14 compatibility. 
issue
networkx/algorithms/tree/tests/test_mst.py::test_random_spanning_tree_{additive,multiplicative}_small not skipped when scipy is not installed#TITLE_END#### Current Behavior The two following tests fail if scipy is not installed:  ``` FAILED networkx/algorithms/tree/tests/test_mst.py::test_random_spanning_tree_multiplicative_small - ModuleNotFoundError: No module n... FAILED networkx/algorithms/tree/tests/test_mst.py::test_random_spanning_tree_additive_small - ModuleNotFoundError: No module named '... ```  <details><summary>Full traceback</summary>  ```pytb ============================================================== FAILURES =============================================================== ___________________________________________ test_random_spanning_tree_multiplicative_small ____________________________________________      def test_random_spanning_tree_multiplicative_small():         """         Using a fixed seed, sample one tree for repeatability.         """         from math import exp              pytest.importorskip("numpy")              gamma = {             (0, 1): -0.6383,             (0, 2): -0.6827,             (0, 5): 0,             (1, 2): -1.0781,             (1, 4): 0,             (2, 3): 0,             (5, 3): -0.2820,             (5, 4): -0.3327,             (4, 3): -0.9927,         }              # The undirected support of gamma         G = nx.Graph()         for u, v in gamma:             G.add_edge(u, v, lambda_key=exp(gamma[(u, v)]))              solution_edges = [(2, 3), (3, 4), (0, 5), (5, 4), (4, 1)]         solution = nx.Graph()         solution.add_edges_from(solution_edges)      >       sampled_tree = nx.random_spanning_tree(G, "lambda_key", seed=42)  G          = <networkx.classes.graph.Graph object at 0x7fda89729810> exp        = <built-in function exp> gamma      = {(0, 1): -0.6383,  (0, 2): -0.6827,  (0, 5): 0,  (1, 2): -1.0781,  (1, 4): 0,  (2, 3): 0,  (4, 3): -0.9927,  (5, 3): -0.282,  (5, 4): -0.3327} solution   = <networkx.classes.graph.Graph object at 0x7fda8972a450> solution_edges = [(2, 3), (3, 4), (0, 5), (5, 4), (4, 1)] u          = 4 v          = 3  networkx/algorithms/tree/tests/test_mst.py:401:  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ networkx/utils/decorators.py:845: in func     return argmap._lazy_compile(__wrapper)(*args, **kwargs)         _argmap__wrapper = <function random_spanning_tree at 0x7fda925323e0>         args       = (<networkx.classes.graph.Graph object at 0x7fda89729810>, 'lambda_key')         kwargs     = {'seed': 42} <class 'networkx.utils.decorators.argmap'> compilation 1150:4: in argmap_random_spanning_tree_1147     ???         G          = <networkx.classes.graph.Graph object at 0x7fda89729810>         multiplicative = True         seed       = <random.Random object at 0x56240bcc6bd0>         weight     = 'lambda_key' networkx/algorithms/tree/mst.py:904: in random_spanning_tree     G_total_tree_weight = spanning_tree_total_weight(prepared_G, weight)         G          = <networkx.classes.graph.Graph object at 0x7fda89729810>         U          = set()         V          = {(0, 1), (1, 2), (4, 3), (5, 4), (1, 4), (2, 3), (0, 2), (0, 5), (5, 3)}         e_weight   = 0.34024137050198705         find_node  = <function random_spanning_tree.<locals>.find_node at 0x7fda8623ec00>         multiplicative = True         node_map   = {}         prepare_graph = <function random_spanning_tree.<locals>.prepare_graph at 0x7fda8623e3e0>         prepared_G = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>         seed       = <random.Random object at 0x56240bcc6bd0>         shuffled_edges = [(1, 2), (5, 3), (5, 4), (1, 4), (4, 3), (0, 5), (2, 3), (0, 1), (0, 2)]         spanning_tree_total_weight = <function random_spanning_tree.<locals>.spanning_tree_total_weight at 0x7fda8623f600>         st_cached_value = 0         u          = 1         v          = 2         weight     = 'lambda_key' networkx/algorithms/tree/mst.py:871: in spanning_tree_total_weight     return nx.total_spanning_tree_weight(G, weight)         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>         multiplicative = True         weight     = 'lambda_key' networkx/linalg/laplacianmatrix.py:177: in total_spanning_tree_weight     G_laplacian = nx.laplacian_matrix(G, weight=weight).toarray()         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>         np         = <module 'numpy' from '/usr/lib/python3.11/site-packages/numpy/__init__.py'>         weight     = 'lambda_key' networkx/utils/decorators.py:845: in func     return argmap._lazy_compile(__wrapper)(*args, **kwargs)         _argmap__wrapper = <function laplacian_matrix at 0x7fda9251f9c0>         args       = (<networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>,)         kwargs     = {'weight': 'lambda_key'} <class 'networkx.utils.decorators.argmap'> compilation 1154:4: in argmap_laplacian_matrix_1151     ???         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>         nodelist   = None         weight     = 'lambda_key' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  G = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90>, nodelist = None, weight = 'lambda_key'      @not_implemented_for("directed")     def laplacian_matrix(G, nodelist=None, weight="weight"):         """Returns the Laplacian matrix of G.              The graph Laplacian is the matrix L = D - A, where         A is the adjacency matrix and D is the diagonal matrix of node degrees.              Parameters         ----------         G : graph            A NetworkX graph              nodelist : list, optional            The rows and columns are ordered according to the nodes in nodelist.            If nodelist is None, then the ordering is produced by G.nodes().              weight : string or None, optional (default='weight')            The edge data key used to compute each value in the matrix.            If None, then each edge has weight 1.              Returns         -------         L : SciPy sparse matrix           The Laplacian matrix of G.              Notes         -----         For MultiGraph, the edges weights are summed.              See Also         --------         to_numpy_array         normalized_laplacian_matrix         laplacian_spectrum         """ >       import scipy as sp E       ModuleNotFoundError: No module named 'scipy'  G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda8972be90> nodelist   = None weight     = 'lambda_key'  networkx/linalg/laplacianmatrix.py:50: ModuleNotFoundError ______________________________________________ test_random_spanning_tree_additive_small _______________________________________________      def test_random_spanning_tree_additive_small():         """         Sample a single spanning tree from the additive method.         """         pytest.importorskip("numpy")              edges = {             (0, 1): 1,             (0, 2): 1,             (0, 5): 3,             (1, 2): 2,             (1, 4): 3,             (2, 3): 3,             (5, 3): 4,             (5, 4): 5,             (4, 3): 4,         }              # Build the graph         G = nx.Graph()         for u, v in edges:             G.add_edge(u, v, weight=edges[(u, v)])              solution_edges = [(0, 2), (1, 2), (2, 3), (3, 4), (3, 5)]         solution = nx.Graph()         solution.add_edges_from(solution_edges)      >       sampled_tree = nx.random_spanning_tree(             G, weight="weight", multiplicative=False, seed=37         )  G          = <networkx.classes.graph.Graph object at 0x7fda86170710> edges      = {(0, 1): 1,  (0, 2): 1,  (0, 5): 3,  (1, 2): 2,  (1, 4): 3,  (2, 3): 3,  (4, 3): 4,  (5, 3): 4,  (5, 4): 5} solution   = <networkx.classes.graph.Graph object at 0x7fda86172d10> solution_edges = [(0, 2), (1, 2), (2, 3), (3, 4), (3, 5)] u          = 4 v          = 3  networkx/algorithms/tree/tests/test_mst.py:525:  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <class 'networkx.utils.decorators.argmap'> compilation 1150:4: in argmap_random_spanning_tree_1147     ???         G          = <networkx.classes.graph.Graph object at 0x7fda86170710>         multiplicative = False         seed       = <random.Random object at 0x56240a29fb20>         weight     = 'weight' networkx/algorithms/tree/mst.py:904: in random_spanning_tree     G_total_tree_weight = spanning_tree_total_weight(prepared_G, weight)         G          = <networkx.classes.graph.Graph object at 0x7fda86170710>         U          = set()         V          = {(0, 1), (1, 2), (4, 3), (5, 4), (1, 4), (2, 3), (0, 2), (0, 5), (5, 3)}         e_weight   = 3         find_node  = <function random_spanning_tree.<locals>.find_node at 0x7fda8623d8a0>         multiplicative = False         node_map   = {}         prepare_graph = <function random_spanning_tree.<locals>.prepare_graph at 0x7fda8623d3a0>         prepared_G = <networkx.classes.multigraph.MultiGraph object at 0x7fda86171610>         seed       = <random.Random object at 0x56240a29fb20>         shuffled_edges = [(1, 4), (4, 3), (5, 3), (5, 4), (1, 2), (0, 5), (2, 3), (0, 1), (0, 2)]         spanning_tree_total_weight = <function random_spanning_tree.<locals>.spanning_tree_total_weight at 0x7fda8623df80>         st_cached_value = 0         u          = 1         v          = 4         weight     = 'weight' networkx/algorithms/tree/mst.py:890: in spanning_tree_total_weight     total += w * nx.total_spanning_tree_weight(         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda86171610>         multiplicative = False         total      = 0         u          = 0         v          = 1         w          = 1         weight     = 'weight' networkx/linalg/laplacianmatrix.py:177: in total_spanning_tree_weight     G_laplacian = nx.laplacian_matrix(G, weight=weight).toarray()         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda86172810>         np         = <module 'numpy' from '/usr/lib/python3.11/site-packages/numpy/__init__.py'>         weight     = None <class 'networkx.utils.decorators.argmap'> compilation 1154:4: in argmap_laplacian_matrix_1151     ???         G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda86172810>         nodelist   = None         weight     = None _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  G = <networkx.classes.multigraph.MultiGraph object at 0x7fda86172810>, nodelist = None, weight = None      @not_implemented_for("directed")     def laplacian_matrix(G, nodelist=None, weight="weight"):         """Returns the Laplacian matrix of G.              The graph Laplacian is the matrix L = D - A, where         A is the adjacency matrix and D is the diagonal matrix of node degrees.              Parameters         ----------         G : graph            A NetworkX graph              nodelist : list, optional            The rows and columns are ordered according to the nodes in nodelist.            If nodelist is None, then the ordering is produced by G.nodes().              weight : string or None, optional (default='weight')            The edge data key used to compute each value in the matrix.            If None, then each edge has weight 1.              Returns         -------         L : SciPy sparse matrix           The Laplacian matrix of G.              Notes         -----         For MultiGraph, the edges weights are summed.              See Also         --------         to_numpy_array         normalized_laplacian_matrix         laplacian_spectrum         """ >       import scipy as sp E       ModuleNotFoundError: No module named 'scipy'  G          = <networkx.classes.multigraph.MultiGraph object at 0x7fda86172810> nodelist   = None weight     = None  networkx/linalg/laplacianmatrix.py:50: ModuleNotFoundError ```  </details>  ### Expected Behavior Since other relevant tests are skipped when `scipy` is not installed, I think these two could skip as well ;-).  ### Steps to Reproduce ``` # do not install scipy ;-) pytest networkx/algorithms/tree/tests/test_mst.py ```  ### Environment <!--- Please provide details about your local environment --> Python version: 3.11.0b3 NetworkX version: 2.8.3
comment
Thanks!
comment
> Thanks for catching this!  Not exactly my choice ;-).
