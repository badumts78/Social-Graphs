issue
LR planarity checking#TITLE_END#We implemented a planarity check based on the paper "The Left-Right Planarity Test"[1]  The code is able to certify the correctness of the result by giving a combinatorial embedding as a planarity certificate and Kuratowski subgraph as a counterexample. Our unit tests also verify that the certificates are correct.  We've encountered the following issues and would like your feedback regarding these: - Recursion depth will be exceeded on larger graphs (10000 nodes).   - Fix would be to use a DFS visitor, but it needs to be more complex than the one already present in networkx   - We have worked on a fix, but it would make the code much harder to read.   - Workaround is the standard recursion depth adjustment. - Runtime complexity of the planarity check is superlinear. Reasons:   - Sorting of a neighbor list by using the default sort method: A custom sort method could improve the complexity. Effectively, this is O(|V|) in the average case due to the planarity condition |E| <= 3*|V|-6. Worst case is O(|V| log |V|) for a graph with dominating vertices.   - Insertion in a neighbor list: Requires a better data structure with constant time insert.  - Is the chosen path `networkx/algorithms/planarity.py` fine or should we add a new category and use e.g. `networkx/algorithms/planarity/checking.py`.  If you have any issues you'd like us to improve, please tell us.  -- [1]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208
issue
Treewidth and tree decomposition heuristics (#2935)#TITLE_END#See #2935 for details.   We implemented two heuristics for an upper bound on the treewidth: a minimum degree based heuristic and a minimum fill-in heuristic. They are described in section 4.3 in this paper: https://dspace.library.uu.nl/bitstream/handle/1874/22171/2005-018.pdf  The implementation is finished and we would like to get your feedback. We will complete the documentation in the next few days.  Some points we are unsure about: - Internally we used a custom graph structure (dict-of-sets) because this turned out to be much faster on our benchmark. We can change this to the default nx.Graph. - To enable different heuristics, we pass the heuristic as a class. E.g. the min-degree has internal state (keeps a heap), thus it couldn't simply be a function. We could change the heuristics so they don't need state, but the min-degree-heuristic would be slower.    - Currently the heuristic classes are iterators, but that might make it unclear that internal state can change. For clarity we could use explicit functions.   # Performance results  <table>   <tr>     <td>heuristic</td>     <td>node search</td>     <td>graph structure</td>     <td>graph size</td>     <td>runtime</td>   </tr>   <tr>     <td>min-degree</td>     <td>heap</td>     <td>custom</td>     <td><= 10000</td>     <td>113.7s</td>   </tr>   <tr>     <td>min-degree</td>     <td>linear</td>     <td>custom</td>     <td><= 10000</td>     <td>162.3s</td>   </tr>   <tr>     <td>min-degree</td>     <td>heap</td>     <td>nx.Graph</td>     <td><= 10000</td>     <td>305.9s</td>   </tr>   <tr>     <td>min-degree</td>     <td>linear</td>     <td>nx.Graph</td>     <td><= 10000</td>     <td>401.9s</td>   </tr>   <tr>     <td>min-fill-in</td>     <td>-</td>     <td>custom</td>     <td><= 1000</td>     <td>24.3s</td>   </tr>   <tr>     <td>min-fill-in</td>     <td>-</td>     <td>nx.Graph</td>     <td><= 1000</td>     <td>399.2s</td>   </tr> </table>   
