comment
Just a random student passing by  (because I was wondering why  `for u, v, d in G.edges(data=True)` raised an error with the typechecker :'( ).   I read the whole discussion. I was under the impression you wanted to use  ```python from __future__ import annotations ```  A bit lower I read things such as   > In Python 3.9, this will become even easier to read: >  > ```python > def build_graph(graph_builder: None | Graph | GraphFactory) -> Graph: > ```  .  I think you are misunderstanding something. If you’re importing `from __future__ import annotations`, you can actually use that syntax in python 3.7 : when using the future import, the annotations don’t need to be valid syntax  This is because the future import enables [PEP 563 – Postponed Evaluation of Annotations](https://peps.python.org/pep-0563/), which means at execution time, all annotations are wrapped in strings, thus that line becomes   ```python  def build_graph(graph_builder: "None | Graph | GraphFactory") -> Graph: ``` which is valid python syntax in 3.7.   EDIT: Also, with new syntax, GraphFactory could be rewritten as `() -> Graph` which is more readable imo than `Callable[[], Graph]`
comment
   > I had read the discussion on PEP 677, but I thought it was rejected? Is there a different PEP that describes this syntax?  Oh no my bad, I was persuaded this had been accepted because the version of pyright i’m using still supported it, forget about that
comment
Just my two cents here:   > But I think the reluctance is also deeper than that. For many years a selling point and design choice for python packages has been "duck-typing", where you don't check types. You try to make it quack and if it does, then you treat it like a duck. If Python code starts to look like C or Java code then we might as well be programming in C or Java -- which are often faster anyway because they are compiled. So there is a long history of phrases like "use hasattr, not isinstance". And the goal of writing code to accept any reasonable input is a reasonable goal.  I think you understand that, but for the sake of completeness: the type system in python (or other modern typed languages, like typescript) is a completely different concept from the "types" in C or Java. - In C the types are an indication *to the compiler*. writing `int a` means "use the machine instructions for dealing with integers when manipulating `a`. Thus    -  They are mandatory    -  They are meant to help the compiler, not the programmer    -  They are not really useful as documentation (sure `char*` could be a string… it could also be an array of 1-bytes integer, or simply a pointer to one value)    - Changing them has effect on the execution of the code - Java is slightly different, because on top of the above, it added OOP. Thus, types also became a means of abstraction - But in Python, static types have a totally different purpose: they’re inherently made to help the programmer, not the (nonexistant) compiler    - They have value as documentation    - They are meant to be a way to prove simple correctness properties of your program (*in fact, computer proof assistants are exactly the same as very advanced type-checkers.*)    - They are not mandatory (even if you use them, you don’t have to typecheck everything.  Plus, in my opinion, typechecking is totally compatible with duck-typing, as long as you do it right: for example - `typing.Sequence` means "something that quacks like a list" - `typing.Mapping` means "somethings that quacks like a dict" - and more generally, the [Protocol (pep 544)](https://peps.python.org/pep-0544/) system is meant to address this   > The code I have seen with inline annotations requires a novice to learn a huge amount -- or else just try to ignore all the annotations at first. I'm hopeful that Python can find a way to ease the learning curve required to read code with annotations. But it also seems straight-forward, practical and much less dangerous than it used to be to keep the typing in stubs files. So the code is still accessible, and the tools can check the types. I expect in the not-to-distant future, tools will be able to merge stub files with the code. Also in the other direction, tools will be able to split annotated code to de-annotated code and stub files. I expect that it will become much easier to see the code in the form that you want to see it.  Honestly I have a mixed view about this. Simple typing make it easier to understand what’s happening.  For example, this: ```python def adjacency_spectrum(G: Graph, weight: str | None) -> np.ndarray:    ... ``` Is undeniably easier to read than its non-typed counterpart  Advanced features such as generics, typevars,  sometimes `@overload` or such can be hard at first though. Think something like (I haven’t seen the actual definition in the codebase)  ```python  @overload def edges(..., data: Literal[False] = False) -> Tuple[Edgetype, Edgetype]:    ...  @overload def edges(..., data: Literal[True])> Tuple[Edgetype, Edgetype, dict]:    ... ``` Could be hard to read for the untrained eye (though it can also be clearer for the trained eye). There might be a compromise to be had by not using structures like the ones above (the types will be less refined)  All in all, I’d say - if you’re a beginner, simple types annotations will help you u - If you know more about type annotations, they always help make the code readable   >       * taking inline type annotations and putting that information into doc_strings.  Note that I believe sphinx already reads type annotations when building the doc. That means if annotations are inline, you see them in the code, and you see them in the doc 
