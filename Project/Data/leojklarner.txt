issue
Minor changes to speed up asynchronous label propagation for community detection.#TITLE_END#The innermost loop of the asynchronous label propagation algorithm counts the frequencies of labels among a node's neighbours.  The current implementation initialises a collections.Counter object, loops through all neighbouring nodes, and adds each of them to the counter:  ``` label_freq = Counter() for v in G[node]:         label_freq.update({labels[v]: G.edges[node, v][weight] if weight else 1}) ```  In cases where the counts are not weighted, it is much more efficient to directly update the counter with a list of labels:  ``` label_freq = Counter() label_freq.update([labels[v] for v in G[node]]) ```  A dummy script shows that the direct update from a list is more than 10x faster than the loop.  ``` import random from collections import Counter random_list = [random.randrange(100) for _ in range(1000)] simple_map = {v: v+1 for v in random_list} ``` ``` %%timeit counter1 = Counter() counter1.update([simple_map[v] for v in random_list]) ``` 69.9 µs ± 994 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) ``` %%timeit counter2 = Counter() for v in random_list:     counter2.update({simple_map[v]:1}) ``` 826 µs ± 23.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)  I also modified the skip-condition for nodes with zero neighbours to just use the clearer and more efficient boolean value of the adjacency list and re-ordered/adjusted the comments to better reflect what's happening in the code.  
