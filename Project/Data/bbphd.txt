issue
Approximate dominating set not even minimal?#TITLE_END#EDIT: THERE IS A BUG AND THE ALGORITHM IS NOT THE ONE ADVERTISED.  SEE LAST 2 POSTS BY ME BELOW.  EDIT 2: Algorithm may be OK, just needs bug fix.  See my final post below. I imagine this must be a bug in networkx.algorithms.approximation.min_weighted_dominating_set. The result it gives is 0,1,2 and that set is still dominating even if the 0 and 1 are removed.  ``` >>> import networkx as nx >>> from networkx.algorithms import * >>>  >>> G=nx.path_graph(5) >>> H=nx.power(G,2) >>> print nx.nodes(H) [0, 1, 2, 3, 4] >>> print nx.edges(H) [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4), (3, 4)] >>> s = min_weighted_dominating_set(H) >>> print s set([0, 1, 2]) ```  (I am using the development version so I can use power) 
comment
That is the correct reference, but it's just a paragraph that is rather hard to read and no useful commentary.  To actually read something easy to follow look at section 3.5 in http://arxiv.org/abs/1305.3584  On 6/8/15, jfinkels notifications@github.com wrote:  > Also, your reference seems to be [this paper][1], is that correct? If so, > can you indicate the place in the paper that has the postprocessing > algorithm you suggest, so that we can find it easily? >  > [1]: http://dx.doi.org/10.1016/S0377-2217(96)00161-0 >  > --- >  > Reply to this email directly or view it on GitHub: > https://github.com/networkx/networkx/issues/1572#issuecomment-110200619 
comment
First of all, there's a copyright claim in there I had not noticed. Is that valid?  If it is I don't know that we can modify this and should revert or rewrite or get permission? The claim in the code that the greedy algorithm runs in O(|E|) seems wrong.  It seems to me that on a large path graph it will be like O(|V|^2), and in general probably O(|E|+|V|^2). I think in practice the post-processing will be of the same order, usually much faster, but to be safe probably should only update redundancy on nodes where it might change.  But let's resolve the copyright...  On 6/8/15, Bill Bruno wbruno@gmail.com wrote:  > That is the correct reference, but it's just a paragraph that is > rather hard to read and no useful commentary.  To actually read > something easy to follow look at section 3.5 in > http://arxiv.org/abs/1305.3584 >  > On 6/8/15, jfinkels notifications@github.com wrote: >  > > Also, your reference seems to be [this paper][1], is that correct? If so, > > can you indicate the place in the paper that has the postprocessing > > algorithm you suggest, so that we can find it easily? > >  > > [1]: http://dx.doi.org/10.1016/S0377-2217(96)00161-0 > >  > > --- > >  > > Reply to this email directly or view it on GitHub: > > https://github.com/networkx/networkx/issues/1572#issuecomment-110200619 
comment
OK good.  Tomorrow I'll add one if statement and hopefully do some timing experiments?  On 6/9/15, jfinkels notifications@github.com wrote:  > Are you referring to the copyright notice at the head of the > `approximate/dominating_set.py` file? The original author licensed his work > under [the BSD license][1], so as long one abides by the requirements of > that license (and NetworkX does), that's not a problem. (The "All rights > reserved" is dubious; only _some_ rights are reserved when a work is > distributed under a BSD license. This is something the Creative Commons > organization calls ["Some rights reserved"][2].) >  > This is why free and open source software is good: it subverts the > "permissions culture" surrounding creative works (in the United States) in > order to "[promote the progress of science and useful arts][3]", the > original intent of copyright! >  > [1]: https://github.com/networkx/networkx/blob/master/LICENSE.txt > [2]: > https://wiki.creativecommons.org/Frequently_Asked_Questions#What_does_.22Some_Rights_Reserved.22_mean.3F > [3]: https://en.wikipedia.org/wiki/Copyright_Clause >  > --- >  > Reply to this email directly or view it on GitHub: > https://github.com/networkx/networkx/issues/1572#issuecomment-110450718 
comment
Unfortunately I did not see your message while I was working on fixing another little bug that was in the old function.  I found a test case that illustrates it well, (in particular with post_process=False). Here's a link to my revised code on gist, which has the example at the bottom, and also has efficiency improvements.  Unfortunately I broke the code, but you  can copy the test case if you want.  I'll try to fix it and/or look at what you did... https://gist.github.com/bbphd/72543f4d37ac965dd7e4  On Tue, Jun 9, 2015 at 10:58 PM, jfinkels notifications@github.com wrote:  > I'm not sure which if statement you're thinking of, but please do take a > look at the code I modified from your original suggestion at pull request > #1573 https://github.com/networkx/networkx/pull/1573 and make any new > suggestions there. Alternately, if you think my code is way off, make a new > pull request with your own changes. >  > — > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1572#issuecomment-110588679. 
comment
I am not qualified to judge coding quality but yours looks nicer than mine to my untrained eye.  However, there are two lines where you define redundancy that end with "for u in G".  In both cases it should be "for u in dom_set"  which will make it faster but ultimately give the same result.  I do think the comment claiming running time of O(E) is wrong, don't you?  On Tue, Jun 9, 2015 at 10:58 PM, jfinkels notifications@github.com wrote:  > I'm not sure which if statement you're thinking of, but please do take a > look at the code I modified from your original suggestion at pull request > #1573 https://github.com/networkx/networkx/pull/1573 and make any new > suggestions there. Alternately, if you think my code is way off, make a new > pull request with your own changes. >  > — > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1572#issuecomment-110588679. 
comment
OK I got my version to run right again. Turns out one of the test cases needs to be modified so that it works reliably right with the corrected code (and depends only on the graph, not the labels). https://gist.github.com/bbphd/72543f4d37ac965dd7e4  On Wed, Jun 10, 2015 at 3:27 PM, Bill Bruno wbruno@gmail.com wrote:  > I am not qualified to judge coding quality but yours looks nicer than mine > to my untrained eye.  However, there are two lines where you define > redundancy that end with "for u in G".  In both cases it should be "for u > in dom_set"  which will make it faster but ultimately give the same result. >  > I do think the comment claiming running time of O(E) is wrong, don't you? >  > On Tue, Jun 9, 2015 at 10:58 PM, jfinkels notifications@github.com > wrote: >  > > I'm not sure which if statement you're thinking of, but please do take a > > look at the code I modified from your original suggestion at pull request > > #1573 https://github.com/networkx/networkx/pull/1573 and make any new > > suggestions there. Alternately, if you think my code is way off, make a new > > pull request with your own changes. > >  > > — > > Reply to this email directly or view it on GitHub > > https://github.com/networkx/networkx/issues/1572#issuecomment-110588679 > > . 
comment
There was one bug I forgot to fix when I updated the revision of jfinkels.  The cost function should only consider the nodes not yet covered.  Subtracting dom_set doesn't do it; you also have to subtract all of their neighborhoods.  Or, just intersect with vertices.  See my Gist; same one as my last post.  On 6/11/15, Bill Bruno wbruno@gmail.com wrote:  > OK I got my version to run right again. > Turns out one of the test cases needs to be modified so that it works > reliably right with the corrected code (and depends only on the graph, not > the labels). > https://gist.github.com/bbphd/72543f4d37ac965dd7e4 >  > On Wed, Jun 10, 2015 at 3:27 PM, Bill Bruno wbruno@gmail.com wrote: >  > > I am not qualified to judge coding quality but yours looks nicer than > > mine > > to my untrained eye.  However, there are two lines where you define > > redundancy that end with "for u in G".  In both cases it should be "for u > > in dom_set"  which will make it faster but ultimately give the same > > result. > >  > > I do think the comment claiming running time of O(E) is wrong, don't you? > >  > > On Tue, Jun 9, 2015 at 10:58 PM, jfinkels notifications@github.com > > wrote: > >  > > > I'm not sure which if statement you're thinking of, but please do take a > > > look at the code I modified from your original suggestion at pull > > > request > > > #1573 https://github.com/networkx/networkx/pull/1573 and make any new > > > suggestions there. Alternately, if you think my code is way off, make a > > > new > > > pull request with your own changes. > > >  > > > — > > > Reply to this email directly or view it on GitHub > > > https://github.com/networkx/networkx/issues/1572#issuecomment-110588679 > > > . 
comment
I have now implemented the post processing improvement described in a paper by Tal Grossman and Avishai Wool.  It can be disabled with an argument.  I found a small test case where it improves the result over the basic greedy algorithm, which does not (in this case) even give a minimal set. -Bill  _Edited to remove large code block, now at https://gist.github.com/jfinkels/9ea6ef5cb50789328c42._ 
comment
Thanks!  I'll try that in the future.  I should have added some commentary on what the post-processing does: Any node in the dominating set is redundant if its neighborhood (including itself) is a subset of the union of the neighborhoods of the other elements of the dominating set.  The depth of redundancy is the smallest number of extra times any element in a node's neighborhood is covered.  The most deeply redundant node is removed first--(highest cost first in case of ties).  This continues until the answer is minimal (i.e., all nodes have zero redundancy). 
