issue
Standardized Bellman-Ford function calls#TITLE_END#I found that the bellman_ford function call and return parameters are different in design from Dijkstra's and the BFS in unweighted network. So I have standardized these functions to match said function calls and return parameters.  To do so, I have added all the _path() and _path_length() and single_source_ and all_pairs functions accordingly to that "standard". These all now call a private function _bellman_ford() that performs the actual magic. Furthermore, I added multiple predecessor values when multiple shortest paths exist, just like the Dijkstra function does. Finally, I deprecated (not yet removed in case somebody uses it) the function bellman_ford() with a warning and replaced it with bellman_ford_predecessor_and_distance(), since that is what it actually does.  I already updated all dependent functions, existing tests and doctests. However, before merging additional work regarding unit tests on  the new functions, updating of the documentation and maybe a change of the shortest-path function also checking for negative weights needs to occur. I am willing to do that, but would first like to get your first impression before finishing that part. 
issue
Edited Doc Makefile#TITLE_END#Probably the smallest pull-request ever. I edited the Makefile in the doc-directory to remove the contents of the folder source/static/examples instead of the folder itself when `make clean` is called, as was already the case with the other generated folders. I also use other types of file synchronization tools and it is difficult to exclude non-existent folders, or the exclusion gets deleted together with the deleted folder, hence it gets included again at the next make. 
issue
Changed function dijkstra_path_length() to finish once target path length has been found#TITLE_END#I found that the function dijkstra_path_length() run the function single_source_dijkstra_path_length() that does a one-to-all path length computation. Given that this function knows the target upfront, a one-to-once-found is more computationally efficient. 
