issue
Bugfix for generic_multiedge_match (Issue #2114)#TITLE_END#generic_multiedge_match can be used to compare multiedges with multiple attributes. For this, one can give it a list of attributes, list of default values and a list of operators to be used for comparison of pairs of single attributes. There was a bug which caused the operators to instead compare tuples of attributes. I fixed this. As discussed in https://github.com/networkx/networkx/issues/2114, I then also simplified the method to only one case, independent of the number of attributes that ought to be compared. 
issue
Bug in generic_multiedge_match#TITLE_END#I ran into trouble when trying to check MultiDiGraphs for isomorphisms. The edges and nodes have  numerical and categorical attributes, so I used generic matches like this:  ``` import nx.algorithms.isomorphism.matchhelpers as mh em = mh.generic_multiedge_match(['id', 'flowMin', 'flowMax'], ['', 0, 0], [eq, close, close]) nm = mh.generic_node_match(['id', 'flowMin', 'flowMax'], ['', 0, 0], [eq, close, close]) return networkx.is_isomorphic(G1, G2, node_match=nm, edge_match=em) ```  Now, at some point I got an error, because `close` tried to compare tuples of the form (id, flowMin, flowMax). The responsible code comes from `networkx.isomorphisms.matchhelpers.generic_multiedge_match`:  ``` def generic_multiedge_match(attr, default, op):     """Returns a comparison function for a generic attribute.      The value(s) of the attr(s) are compared using the specified     operators. If all the attributes are equal, then the constructed     function returns True. Potentially, the constructed edge_match     function can be slow since it must verify that no isomorphism     exists between the multiedges before it returns False.      Parameters     ----------     attr : string | list         The edge attribute to compare, or a list of node attributes         to compare.     default : value | list         The default value for the edge attribute, or a list of         default values for the dgeattributes.     op : callable | list         The operator to use when comparing attribute values, or a list         of operators to use when comparing values for each attribute.      Returns     -------     match : function         The customized, generic `edge_match` function.      Examples     --------     >>> from operator import eq     >>> from networkx.algorithms.isomorphism.matchhelpers import close     >>> from networkx.algorithms.isomorphism import generic_node_match     >>> nm = generic_node_match('weight', 1.0, close)     >>> nm = generic_node_match('color', 'red', eq)     >>> nm = generic_node_match(['weight', 'color'],     ...                         [1.0, 'red'],     ...                         [close, eq])     ...      """      # This is slow, but generic.     # We must test every possible isomorphism between the edges.     if nx.utils.is_string_like(attr):         def match(datasets1, datasets2):             values1 = [data.get(attr, default) for data in datasets1.values()]             values2 = [data.get(attr, default) for data in datasets2.values()]             for vals2 in permutations(values2):                 for xi, yi in zip(values1, vals2):                     if not op(xi, yi):                         # This is not an isomorphism, go to next permutation.                         break                 else:                     # Then we found an isomorphism.                     return True             else:                 # Then there are no isomorphisms between the multiedges.                 return False     else:         attrs = list(zip(attr, default)) # Python 3         def match(datasets1, datasets2):             values1 = []             for data1 in datasets1.values():                 x = tuple( data1.get(attr, d) for attr, d in attrs )                 values1.append(x)             values2 = []             for data2 in datasets2.values():                 x = tuple( data2.get(attr, d) for attr, d in attrs )                 values2.append(x)             for vals2 in permutations(values2):                 for xi, yi, operator in zip(values1, vals2, op):    <---------------                     if not operator(xi, yi):                         return False             else:                 return True     return match ```  I put an arrow on the line that's crucial. As far as I understand, values1 and vals 2 are lists of tuples of edge attributes (in my case lists of tuples of the form (id, flowMin, flowMax)). op is a list of comparison operators (in my case [eq, close, close]). Therefore, this breaks. To my understanding, it should be something like this instead (starting from where I put the arrow):  ``` # PLEASE SEE EDIT BELOW for tuple1, tuple2 in zip(values1, vals2):     for elem1, elem2, operator in zip(tuple1, tuple2, op):         if not operator(elem1, elem2):             return False ```  EDIT: Now, that I think about it from a "Why should it work?" and not "Why does it fail?" perspective: The suggested code above 'solves' the problem of incorrect comparison, but it does not produce the desired behavior of the function, because it would return False after having checked only one of all the possible isomorphisms between the multiedges. Therefore, the loops starting from the line right above the arrow should be as follows:  ```             for vals2 in permutations(values2):                 for xi, yi in zip(values1, vals2):                     if not all(map(lambda x,y,z: z(x,y), xi, yi, op)):                         # This is not an isomorphism, go to next permutation.                         break                 else:                     # Then we found an isomorphism.                     return True             else:                 # Then there are no isomorphisms between the multiedges.                 return False ``` 
issue
Bug in categorical_node_match?#TITLE_END#I just came across a failing unit test for 'networkx.algorithms.isomorphism.match_helpers.categorical_node_match':  ``` from nose.tools import assert_true from networkx.algorithms import isomorphism as iso   def test_categorical_node_match():     nm = iso.categorical_node_match(['x', 'y', 'z'], [None]*3)     assert_true(nm(dict(x=1, y=2, z=3), dict(x=1, y=2, z=3)))     assert_true(not nm(dict(x=1, y=2, z=2), dict(x=1, y=2, z=1))) ```  It's the second one that fails.  Looking into the function, I found this:  ``` categorical_doc = """ Returns a comparison function for a categorical node attribute.  The value(s) of the attr(s) must be hashable and comparable via the == operator since they are placed into a set([]) object.  If the sets from G1 and G2 are the same, then the constructed function returns True.  Parameters ---------- attr : string | list     The categorical node attribute to compare, or a list of categorical     node attributes to compare. default : value | list     The default value for the categorical node attribute, or a list of     default values for the categorical node attributes.  Returns ------- match : function     The customized, categorical `node_match` function.  Examples -------- >>> import networkx.algorithms.isomorphism as iso >>> nm = iso.categorical_node_match('size', 1) >>> nm = iso.categorical_node_match(['color', 'size'], ['red', 2])  """  def categorical_node_match(attr, default):     if nx.utils.is_string_like(attr):         def match(data1, data2):             return data1.get(attr, default) == data2.get(attr, default)     else:         attrs = list(zip(attr, default)) # Python 3          def match(data1, data2):             return all(data1.get(attr, d) == data2.get(attr, d) for attr, d in attrs)     return match ```  So, basically `categorical_node_match` compares the set of values for the nodes. Therefore it evaluates to `True` for nodes with different attribute dicts, because set of values of these attribute dicts is the same. I don't see why the function would do this (and by the docs, this is intended behavior?!).  
