issue
incorrect results in unionfind compared to other implementations.#TITLE_END#I am seeing an issue where I need to reinsert all of my original keys, during an algorithm that continuously calls `union`. The identical code, using other implementations of UnionFind, work, but using the networkx union find leads to incorrect results.   This is a solution to a coursera problem, using the input file at: https://d18ky98rnyall9.cloudfront.net/_fe8d0202cd20a808db6a4d5d06be62f4_clustering1.txt?Expires=1567641600&Signature=OBpjnbzYQtcwHrFL97bXYvUeS2RD4BVkpNbmPCqJcwF2KPoY2WM5KLg5YofiG8OJ-A64qT8Jo02-6YkH7r5xcaXJghbCgbxecB31m3PzjvMeO5pzsiUbtUmsWLcFXeJqbpYsmraPucoXbM~PpWKi6CLdHEaQVRfB-LeYlDHWX-s_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A  The solution shrinks a network until there are only 4 clusters, then it finds the smallest edge between the clusters.  Here is my working solution runnable using that file (only the code in fix and cluster is relevant here). The problem is the calls to `fix` which should only be needed outside of the loop (once to initialize, since the package doesn't have an explicit insert), and should not be needed inside the loop. I have verified this using another UF implementation using the exact same code (See comment below).  My guess of what's happening is that `union` is butchering the keyspace somehow, but reinserting the original keys that were unioned fixes the bug for some reason.   ``` from networkx.utils import UnionFind   def find_minimal(uf, edges):     # now we have to search for the lowest cost edge that connects them     m = 9999999999999     for i in range(1, 501):         for j in range(1, 501):             if i != j and uf[i] != uf[j]:                 for eindex in start_at[i]:                     if edges[eindex][1] == i and edges[eindex][2] == j and edges[eindex][3] < m:                         m = edges[eindex][3]                         print(m)   def fix(uf):     for k in range(1, 501):         uf[k]   def cluster(edges, start_at):     uf = UnionFind()      sortede = sorted(edges, key=lambda x: x[3])      fix(uf)      for _, u, v, w in sortede:          # moving this outside of the block makes this not work?????????         fix(uf) #!!!!!!!          if len(list(uf.to_sets())) == 4:             break         elif uf[u] != uf[v]:             uf.union(u, v)      find_minimal(uf, edges)   if __name__ == "__main__":     edges = []     start_at = {}     with open("course_3_p2q1.txt", "r") as f:         for lindex, line in enumerate(f):             i = line.split()             start = int(i[0])             end = int(i[1])             edges.append((lindex, start, end, int(i[2])))             if start not in start_at:                 start_at[start] = []             if end not in start_at:                 start_at[end] = []             # we need these later when we need to quickly scan through edjes that connect clusters             start_at[start].append(lindex)             start_at[end].append(lindex)      cluster(edges, start_at) ```  If I don't reinsert all keys on every iteration; that is, if I remove the `fix(uf)` INSIDE the for loop, I get the complete wrong answer, and at the end, uf.parents is different than the above working solution.  My guess is that the merging algorithm is blowing away some kind of historical membership.  Any ideas?
