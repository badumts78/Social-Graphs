issue
Feature request: 'to_pandas_adjacency' option on 'nodelist' behaviour#TITLE_END#When using the 'to_pandas_adjacency' conversion method, if a node listed in the 'nodelist' parameter is not present in the graph being converted, an error is thrown.  ![image](https://user-images.githubusercontent.com/49003263/128536065-6171b0d8-86c2-471d-81a1-aef1d8ea6760.png)  This change was introduced to the latest release.  The prior behaviour (v 2.5.1) allowed a nodelist that had nodes that were not in the graph.  For example:  if a graph had only 4 of say 16 nodes in the 'nodelist', the resulting adjacency matrix would still be 16x16.  The use-case for that behaviour is if you are comparing a series of graphs that are constructed from a subset of a set of common nodes.  It is possible to get the desired behaviour by processing after the fact in pandas, but would it be possible to make the behaviour selectable so that the user could choose either behaviour?  
issue
write_graphml - key error on non-existent key type#TITLE_END#### Current Behavior I'm trying to export a large graph (144k nodes, 435k edges) to the GRAPHML format.  I tried exporting a subset initially and that went well.  Next I tried to export the whole graph. The export fails with the error below.  The challenge is that I don't understand what that error refers to; there are no nodes or edges with a 'key' that is a dict.  All the nodes and edges that have attributes assigned had them created using `G.nodes[].update()` or `G.edges[],update()`.  ![image](https://user-images.githubusercontent.com/49003263/132545353-6589bf4d-a899-43c2-997f-4ba5c11c08f8.png)  ### Expected Behavior <!--- Tell us what should happen --> The entire graph exports to the GEXF format without problems (though I can't use that format).   That suggested to me that the graph was correctly constructed and so I expected the export to GRAPHML to also work.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug --> I can reproduce the error with the following.  Note that as in my graph the _**keys**_ are all 'int' or 'str'.  Some _**values**_ are 'dict' but none of the keys are.  ``` test_G = nx.Graph() test_G.add_node(50509)  attributes = {'label': '55509', 'type': 'document',               1: {'amount': 42.8, 'currency': 'EUR','description': 'blueprint'},               2: {'amount': 104.12, 'currency': 'EUR', 'description': 'blueprint'},               3: {'amount': 116.0, 'currency': 'EUR', 'description': 'blueprint '}              }  test_G.nodes[50509].update(attributes) print(test_G.nodes(data=True)) nx.write_graphml(test_G,'error_G.graphml') ```  ### Environment <!--- Please provide details about your local environment --> OS: macOS (Catalina) Python version: 3.8 NetworkX version: 2.6.2  ### Additional Context It looks like the structure of the attributes is causing the problem ie. 'dict' as values but I thought that was an acceptable construct. 
issue
Does 'is_triad' method ignore self-loops?#TITLE_END#I am new to networkx and am using 2.5 on MacOS 10.15.6.  I have successfully implemented a directed graph and decided to experiment with the triad algorithm.  I first tried 'triadic_census' and that was successful.  I then tried 'triads_by_type' and that failed with the error: ``` 'G is not a triad (order-3 DiGraph)' ``` I looked at the source and implemented a portion of it separately (below).  The output shows that 'census' is correctly identifying existing triads.  If I execute 'all_triads' as is done in the 'triads_by_type' method, a proper triad object seems to be returned and looking at the 'nodes' attribute seems to validate that.  But if I then apply the 'is_triad' method to the triad, it returns False.  If 'all_triads' is returning valid triads, how can they fail to test 'True' for that type?  I know I have many nodes with self-loops but since they are (seem to be?) ignored by census I thought they would also be ignored by the remainder of the triad methods.  Any guidance would be appreciated.  ``` for index, eng in enumerate(eng_graphs.keys()):     if index > 0:         break     net = eng_graphs[eng]     display(nx.algorithms.triads.triadic_census(net))     all_tri = nx.algorithms.triads.all_triads(net)     for idx,triad in enumerate(all_tri):         if idx > 0:             break         display(dir(triad), triad.nodes)         name = nx.algorithms.is_triad(triad) ``` Output: ``` From 'census' - {'003': 939,  '012': 286,  '102': 146,  '021D': 4,  '021U': 111,  '021C': 31,  '111D': 86,  '111U': 34,  '030T': 16,  '030C': 1,  '201': 64,  '120D': 4,  '120U': 7,  '120C': 13,  '210': 22,  '300': 7}  From 'all_triads' - ['__class__',  '__contains__',  '__delattr__',  '__dict__',  '__dir__',  '__doc__',  '__eq__',  '__format__',  '__ge__',  '__getattribute__',  '__getitem__',  '__gt__',  '__hash__',  '__init__',  '__init_subclass__',  '__iter__',  '__le__',  '__len__',  '__lt__',  '__module__',  '__ne__',  '__new__',  '__reduce__',  '__reduce_ex__',  '__repr__',  '__setattr__',  '__sizeof__',  '__str__',  '__subclasshook__',  '__weakref__',  '_adj',  '_node',  '_pred',  '_succ',  'add_edge',  'add_edges_from',  'add_node',  'add_nodes_from',  'add_weighted_edges_from',  'adj',  'adjacency',  'adjlist_inner_dict_factory',  'adjlist_outer_dict_factory',  'clear',  'clear_edges',  'copy',  'degree',  'edge_attr_dict_factory',  'edge_subgraph',  'edges',  'get_edge_data',  'graph',  'graph_attr_dict_factory',  'has_edge',  'has_node',  'has_predecessor',  'has_successor',  'in_degree',  'in_edges',  'is_directed',  'is_multigraph',  'name',  'nbunch_iter',  'neighbors',  'node_attr_dict_factory',  'node_dict_factory',  'nodes',  'number_of_edges',  'number_of_nodes',  'order',  'out_degree',  'out_edges',  'pred',  'predecessors',  'remove_edge',  'remove_edges_from',  'remove_node',  'remove_nodes_from',  'reverse',  'size',  'subgraph',  'succ',  'successors',  'to_directed',  'to_directed_class',  'to_undirected',  'to_undirected_class',  'update']  View of 'node' from preceding 'triad' object: NodeView(('23002', '13002', 'unk'))  Value returned when preceding object is evaluated by 'is_triad': False ```
