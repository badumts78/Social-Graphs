issue
Some docstring fixes for draw_networkx_edge_labels() in nx_pylab.py + one typo#TITLE_END#This PR fix some issues with the Parameters section of the docstring for ``draw_networkx_edge_labels()``. Summary of the changes:  - ``clip_on`` was included as docstring parameter, but this isn't actually an argument accepted by the function - entry removed. - Conversely, ``rotate`` is an acceptable argument, but there was no docstring entry - entry added. - ``ax`` parameter was included twice - one entry removed. - Erroneous default for ``font_size`` - fixed. - Order of docstring parameters changed to match the function arguments order. This improves the readability of the docs.  PR also includes a fix for a typo on line 252.  Some of the other docstrings in nx_pylab.py would benefit from re-aligning the order of the parameters, making explicitly clear which parameters are optional, etc., but I wanted to check that these changes are ok first before venturing any further.
comment
@ShirsenduP: super work on this issue - thank you   I think the root cause here is the same as [this Q](https://stackoverflow.com/questions/50871343/connectionstyle-arc3-fancyarrowpatch-and-path-curve3-two-quadratic-bezier-cu) on stackoverflow.  The edges when created in `networkx.draw_networkx_edges()` use matplotlib `FancyArrowPatch`, which is using the display space coordinates. Your code calculates the quadratic bezier curve control point in the data coordinates. This is OK when the aspect ratio is 1 as the control points will coincide, but they will be different otherwise.  Two solutions come to mind: - Either take control of drawing the edges away from matplotlib and `FancyArrowPatch`, and bring it within networkx by creating matplotlib `Path` objects directly (as per the stackoverflow Q). This way we set the control points coordinates directly in the data coordinates space. - Or work out what the control point of the `FancyArrowPatch` is in the data coordinates then use this to set the position of the edge labels.  Of the two ideas, the second definitely feels preferable as it is easier to ensure consistency with the output images with previous networkx versions.  I'm looking into this topic because of an [issue](https://github.com/alexmalins/radioactivedecay/issues/46) raised on one of my projects, which will require labels for curved edges of a `MultiDiGraph` to solve. I'm also running up against a slight issue that  the curve radius `rad` needs to be specified differently for different edges. This can be solved though by looping through the edges and plotting them one by one with `networkx.draw_networkx_edges(...edgelist=...)`, as per the answer [here](https://stackoverflow.com/questions/60067022/multidigraph-edges-from-networkx-draw-with-connectionstyle).  Anyway, now I'll start looking into getting the control points for the bezier `FancyArrowPatch` edges and converting them to the data coordinates. 
comment
Looked at this again and it is more complicated than just setting the text location once after finding the `FancyArrowPatch` control point. The control point location changes depending on the aspect ratio set up by the GUI when the figure is rendered, and also upon some user operations in interactive mode.  The text will need to be aware of both the start and end points of `FancyArrowPatch`, i.e. the node locations. This is so the text location can be updated depending on the aspect ratio set by the GUI and by users interactions in interactive mode, as the `FancyArrowPatch`'s are.  My gut feeling is this might be possible by inheriting from `FancyArrowPatch` and binding a `matplotlib.text.Text` instance for the label somehow. Then the label position and updates upon rerendering can be accomplished with minimal duplication of existing matplotlib code.  The easiest solution however is just to take @ShirsenduP's solution and set `ax.set_aspect("equal")`. This works in my testing and stays working until the user or other code instigates a change in the aspect ratio.  
