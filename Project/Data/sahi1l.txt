issue
Allow generators to start with a seed network#TITLE_END#For example, instead of always starting Barabasi-Albert networks with the same base network, add a new parameter initial that takes a graph, and the preferential attachment proceeds from there.  This would allow the study of the growth of the Barabasi-Albert network, capturing its behavior after every few steps, instead of always starting from scratch.  Here is some sample code for B-A: ``` def barabasi_albert_graph(n, m, seed=None, initial=None):     """Returns a random graph according to the Barabási–Albert preferential     attachment model.     A graph of $n$ nodes is grown by attaching new nodes each with $m$     edges that are preferentially attached to existing nodes with high degree.     Parameters     ----------     n : int         Number of nodes     m : int         Number of edges to attach from a new node to existing nodes     seed : integer, random_state, or None (default)         Indicator of random number generation state.         See :ref:`Randomness<randomness>`.     initial : Graph or None         If Graph, starts with that Graph as the initial graph         If None, starts with m nodes and zero edges     Returns     -------     G : Graph     Raises     ------     NetworkXError         If `m` does not satisfy ``1 <= m < n``.     References     ----------     .. [1] A. L. Barabási and R. Albert "Emergence of scaling in        random networks", Science 286, pp 509-512, 1999.     """      if m < 1 or m >= n:         raise nx.NetworkXError("Barabási–Albert network must have m >= 1"                                " and m < n, m = %d, n = %d" % (m, n))          if initial == None:         # Add m initial nodes (m0 in barabasi-speak)         G = empty_graph(m)         # Target nodes for new edges         targets = list(range(m))         # List of existing nodes, with nodes repeated once for each adjacent edge         repeated_nodes = []         # Start adding the other n-m nodes. The first node is m.         source = m     else:         G = initial         targets = list(G.nodes())         repeated_nodes = [i for n,d in G.degree() for i in [n]*d]         source = len(G.nodes())     while source < n:         # Add edges to m nodes from the source.         G.add_edges_from(zip([source] * m, targets))         # Add one node to the list for each new edge just created.         repeated_nodes.extend(targets)         # And the new node "source" has m edges to add to the list.         repeated_nodes.extend([source] * m)         # Now choose m unique nodes from the existing nodes         # Pick uniformly from repeated_nodes (preferential attachment)         targets = _random_subset(repeated_nodes, m, seed)         source += 1     return G ``` (I don't have the time to create a fork and pull request right this moment.)
