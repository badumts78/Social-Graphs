comment
Thus a type distinction for DiGraph with a neighborhood aggregation step using `DiGraph.successor` and `DiGraph.predecessor` would be needed, I think. Also, we would need to account for the separation of successor and predecessor labels in each aggregation step. Thus we aggregate them in a tuple to differentiate between successor node labels and predecessor node labels as @dschult suggests.   ``` def _neighborhood_aggregate(G, node, node_labels, edge_attr=None):     """     Compute new labels for a given node by aggregating     the labels of each node's neighbors.     """     label_list = []     for nbr in G.neighbors(node):         prefix = "" if edge_attr is None else str(G[node][nbr][edge_attr])         label_list.append(prefix + node_labels[nbr])     return node_labels[node] + "".join(sorted(label_list))  ```   would then be changed to differentiate between Graph and DiGraph and in the case of a DiGraph be in line like:   ``` def _digraph_neighborhood_aggregate(G, node, node_labels, edge_attr=None):     """     Compute new labels for a given node in a DiGraph by aggregating     the labels of each successor and predecessor node separately.     """     succ_list = []     for succ in G.successor(node):         prefix = "" if edge_attr is None else str(G[node][succ][edge_attr])         succ_list.append(prefix + node_labels[succ_list])      pred_list = []     for pred in G.predecessors(node):         prefix = "" if edge_attr is None else str(G[node][pred][edge_attr])         pred_list.append(prefix + node_labels[pred])      return node_labels[node] + ("".join(sorted(succ_list), "".join(sorted(pred_list))  ```   An alternative to using the tuple could be to add a "succ" / "pred" prefix via the `prefix` that is used for the edge attribute   ``` def _digraph_neighborhood_aggregate(G, node, node_labels, edge_attr=None):     """     Compute new labels for a given node in a DiGraph by aggregating     the labels of each successor and predecessor node separately.     """     label_list = []     for succ in G.successor(node):         prefix =  "_succ_" + "" if edge_attr is None else str(G[node][succ][edge_attr])         label_list.append(prefix + node_labels[succ_list])      pred_list = []     for pred in G.predecessors(node):         prefix = "_pred_" + "" if edge_attr is None else str(G[node][pred][edge_attr])         label_list.append(prefix + node_labels[pred])      return node_labels[node] + "".join(sorted(label_list)  ```      
comment
I tried to find an example, and at least for the case of **labeled** DiGraphs, it appears that without using both successor and predecessor nodes in the aggregation, we will not discover hash-mismatches for certain non-isomorphic graphs that are "quite simple" after a sufficient number (#Nodes) of aggregations.   I created two trees, that are not isomorphic given their node labels. Using the current implementation we get the same hash value.   Using an adapted `init_function` as previously discussed, but not changing the neighborhood aggregation step, we still get the same graph hash:   ``` def _init_node_labels_with_succ_and_pred(G, edge_attr, node_attr):     if node_attr:         return {             u: str(dd[node_attr]) + str((               "".join(sorted(G.nodes[succ][node_attr] for succ in G.successors(u))),  			  "".join(sorted(G.nodes[pred][node_attr] for pred in G.predecessors(u)))              )) for u, dd in G.nodes(data=True)}  <!--- ignoring other cases --->  ```  Only using the adapted aggregation that both uses successors and predecessors, do we get a mismatch in hash.   ``` def _digraph_neighborhood_aggregate(G, node, node_labels, edge_attr=None):     """     Compute new labels for a given node in a DiGraph by aggregating     the labels of each successor and predecessor node separately.     """     label_list = []     for succ in G.successors(node):         prefix =  "_succ_" + "" if edge_attr is None else str(G[node][succ][edge_attr])         label_list.append(prefix + node_labels[succ_list])      pred_list = []     for pred in G.predecessors(node):         prefix = "_pred_" + "" if edge_attr is None else str(G[node][pred][edge_attr])         label_list.append(prefix + node_labels[pred])      return node_labels[node] + "".join(sorted(label_list)  ```  ![Image](https://github.com/user-attachments/assets/b3e87df5-d3ed-4009-badf-fa6346ced6b6)  My logic here is that the `blue` nodes in both trees will get a splitting color after 1 iteration using the adapted aggregation function, but not on initialization. Thus using only the adapted initialization function they would remain with the same color. This is because the "information" of the mismatching leaf-node colors (`orange` and `grey`) only reaches the blue nodes with "delay" induced by the `green` nodes. As we can add further layers of `green` nodes we can increase the number of iterations that are needed to pass the information up to the `blue` nodes, as is shown here:   ![Image](https://github.com/user-attachments/assets/600e17ae-73b4-41da-b53a-c00f79afa2e7)      
comment
Have either of you started working on this, else I would implement and create PRs for the three long-term fixes. 
