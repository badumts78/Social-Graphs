issue
Adding dominator Tree #TITLE_END#Networkx has [immediate_dominators](https://networkx.github.io/documentation/development/reference/generated/networkx.algorithms.dominance.immediate_dominators.html) and [dominance_frontiers](https://networkx.github.io/documentation/latest/reference/generated/networkx.algorithms.dominance.dominance_frontiers.html#networkx.algorithms.dominance.dominance_frontiers). I was thinking of adding a simple **dominator_tree** function. I was wondering if would there be any interest in adding this to networkx?  I would be happy to make a pr for that. 
issue
Adding Depth Limited search #TITLE_END#While Looking through networkx i couldn't find [Dls](https://en.wikipedia.org/wiki/Depth-limited_search) Algorithm. I was wondering if would there be any interest in adding this to networkx?  I would be very wiling to make a pr for dls_edges (a function which returns the edges traversed as per Depth Limited search). This function could eventually be used to add  [iterative deepening depth-first search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search)?   I am thinking of first adding a variant of the function below to algorithms/traversal/depth_first_search  ``` python def dls_edges(G,depth,node,goal=None,visited=set(),stack=[]):     if depth>=1:         if node in visited:           return         print node           visited.add(node)         if goal!=None:            if node==goal:              return          for child in G[node]:          if child not in visited :                  stack.append((node,child))          dls_edges(G,depth-1,child,goal)        return stack     ```  And after that adding few tests to test_dfs.py. I am new to open source and it would be great if someone could guide me through this. 
issue
Adding Depth Limited Search#TITLE_END#Adding Depth Limited search as per issue #1912  @dschult @jfinkels please take a look. 
issue
Improving Documentation as per issue #1859#TITLE_END#Improved documentation for issue [#1859](https://github.com/networkx/networkx/issues/1859) The minimum_edge_cut returns an empty set in case of weekly connected directed graph, which is theoretically correct but can be **confusing**  to a user, hence this addition to documentation explains this corner case.It also explain the case when disconnected graph is passed as input. 
issue
minimum_st_node_cut incorrect  if source and target are connected #TITLE_END#Fixes [ #1812](https://github.com/networkx/networkx/issues/1812) @dschult please take a look. 
issue
minimum_st_node_cut breaks if source and target are connected#TITLE_END#Fixes [ #1812](https://github.com/networkx/networkx/issues/1812) For the function minimum_node_cut  When source and sink are specified for minimum_node_cut we use the function   **minimum_st_node_cut** which returns a set of nodes of minimum cardinality that disconnect source  from target in a graph.  For a given graph this is an example  of this function ![correct case](https://cloud.githubusercontent.com/assets/11155207/12075146/b29237ae-b19b-11e5-9b1c-9669e5245e13.png) Here the _blue vertices represent the output of the function minimum_node_cut._ It can easily be observed that removing vertices 8,2,11 would disconnect 1,7. Hence the output is correct.  Now the **bug arises when the source and sink are adjacent** For example  ![bug case](https://cloud.githubusercontent.com/assets/11155207/12075153/0d159f4a-b19c-11e5-9d34-9694e3b10bec.png) Here the function wrongly outputs 2,8 as vertices which is incorrect. This happens because the algorithm  in following steps 1. Build Auxiliary Graph 2. Build residual network  3. Get Cut Edges using Edmonds Karp  4. Get cut nodes This helps you get the minimum number of nodes between source to sink which could disconnect the source and sink but these vertices include the source and the sink themselves which cannot be excluded for obvious reasons. So in this case  we see that removing vertices 2,8 would remove all connections between 1,3 but an edge(1,3) still remains to connect them.   The solution to this bug is to output an empty set in case the source is connected to the sink or the sink is connected to source.  For Example:-  ![correction](https://cloud.githubusercontent.com/assets/11155207/12075182/5a4af566-b19d-11e5-9fde-1b6a3a53e9a0.png)  On applying the fix the following output is obtained. Indicating that it is impossible to delete a vertex that would disconnect 1,3. @MridulS  Please suggest some ideas so that this fix could be added. The Travis build is failing here,because the doctests and other tests included in nosetests are not in conformity with these changes.  
issue
Exclude self-loops from maximal matching#TITLE_END#1. Fixes [#1736](https://github.com/networkx/networkx/issues/1736) 2. Added test  Self Loops should not be included in maximal matching because it **contradictions** the definition  mentioned in documentation which is:-  A [matching](https://networkx.github.io/documentation/latest/reference/generated/networkx.algorithms.matching.maximal_matching.html) is a subset of edges in which **no node occurs more than once**.The cardinality of a matching is the number of matched edges. 
