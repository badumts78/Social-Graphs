issue
modules imports guidelines#TITLE_END#in documentation I found rules for imports. ``` import numpy as np import scipy as sp import matplotlib as mpl import matplotlib.pyplot as plt import networkx as nx ```  in networkx library many submodules use a mixed style of imports like this:  networkx/convert_matrix.py  ``` import warnings as _warnings import itertools import networkx as nx from networkx.convert import _prep_create_using from networkx.utils import not_implemented_for ```  with mostly absolute imports would it not be reasonable to change the rules and start refactoring imports? for example above ```  from itertools import chain from warnings import warn from .classes import DiGraph, selfloop_edges from .convert import _prep_create_using, to_networkx_graph from .exception import NetworkXError from .relabel import relabel_nodes from .utils import not_implemented_for ```  with relative import style users can simultaneously use several versions of the library by simply renaming it. like this  ``` from networkx import smth from networkx_old import smth as smth_old ```  
issue
edges and nodes addition fixes#TITLE_END#Graphs add_edge, add_edges_from, add_node, add_nodes_from methods speedup. Graphs init cleaning.  this is second PR after #3205.  also I want to add all fixes regarding this looking through the whole project.
issue
add_nodes_from fixed for custom hashable node_attr_dict.#TITLE_END#node_attr_dict may be hashable dict-like object and this example give unexpected result:  ``` class hashable_dict(dict):     # bad class, but enough to check add_nodes_from method     def __hash__(self):         return hash(tuple(self.items()))  class CustomGraph(nx.Graph):     node_attr_dict_factory = hashable_dict  G = CustomGraph() G.add_node(1, w=1)  H = nx.Graph() H.add_nodes_from(G.nodes(data=True)) H.nodes[1]  # raise KeyError H.nodes  # NodeView(((1, {'w': 1}),)) ```  
issue
implemented node_attr_dict_factory and graph_attr_dict_factory.#TITLE_END#this is a first commit for implementing this issue #3204. if this approach will be satisfying, I will make changes to all types of graphs in this PR.
issue
Fixed bug on custom attrs usage: unavailable iteritems method for dict.#TITLE_END#also set and dict creation changed.  tests added
issue
subgraph isomorphism error#TITLE_END#then I try matching disconnected (on nodes 2,3) graph **g** and **h** where nodes 2,3 connected, GraphMatcher don't found subgraph. but for **c**, where nodes 2,3 not connected between themselves its work.  from networkx.algorithms import isomorphism as gis  `g=nx.Graph()` `h=nx.Graph()` `c=nx.Graph()`  `g.add_edges_from([(1,2,{1:1}), (3,4,{1:3})])` `h.add_edges_from([(1,2,{1:1}), (2,3, {1:2}), (3,4,{1:3})])` `c.add_edges_from([(1,2,{1:1}), (2,5, {1:2}), (5,3,{1:2}), (3,4,{1:3})])`  `gis.GraphMatcher(c,g, edge_match=gis.categorical_edge_match([1], [None])).subgraph_is_isomorphic()` return True  `gis.GraphMatcher(h,g, edge_match=gis.categorical_edge_match([1], [None])).subgraph_is_isomorphic()` return False 
issue
fix comparison error in categorical_node|edge_match.#TITLE_END#a and b - nodes they has attr: x, y, z  if a attr = {x:1, y: 1, z: 2} and b attr = {x:1, y: 2, z: 2} match return True. It's wrong. 
issue
compose#TITLE_END#compose func merge edges data e.g. R=compose(G,H) G.edge = 2: {3: {'p_b': 1} H.edge = 2: {3: {'s_b': 2}  R.edge = 2: {3: {'p_b': 1, 's_b': 2}  , but not for nodes G.node = 3: {'p_b': 1} H.node = 3: {'s_b': 2}  R.node = 3: {'s_b': 2} # 'p_b' missed 
issue
merge data of G and H instead replace#TITLE_END#compose func merge edges data e.g. R=compose(G,H) G.edge = 2: {3: {'p_b': 1} H.edge = 2: {3: {'s_b': 2}  R.edge = 2: {3: {'p_b': 1, 's_b': 2}  , but not for nodes G.node = 3: {'p_b': 1} H.node = 3: {'s_b': 2}  R.node = 3: {'s_b': 2} # 'p_b' missed 
