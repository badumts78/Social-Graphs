issue
Bidirectional search for graphs#TITLE_END## Bidirectional Search - Benchmark  Hi,  we added three little algorithms that perform a bidirectional search for paths in a graph (simple, directed, multi-). The benefits are, that the results are generated in order, starting form the shortest paths and then with increased length (in contrast to the original search algorithms). And our approach seems also to be much faster. We therefore provided a small Benchmark below the examples, that show that our algorithm can also be applied for large graphs (15000 nodes) without using much more memory.  We hope, that our little file can be included without replacing the originals ;) ## 0. Code  ``` python     import networkx as nx      import inspect     print inspect.getsource(nx.bidirectional.all_simple_paths) ```  ``` def all_simple_paths(G, source, target, cutoff=None):     """Generate all simple paths in graph G from source to target.      A simple path is a path with no repeated nodes.      The result paths are returned ordered by there length, starting     from the shortest paths.      Parameters     ----------     G : NetworkX graph      source : node        Starting node for path      target : node        Ending node for path      cutoff : integer, optional         Depth to stop the search. Only paths of length <= cutoff are returned.      Returns     -------     path_generator: generator        A generator that produces lists of simple paths, ordered by their        length starting from the shortes path. If there are no paths between        the source and target within the given cutoff the generator        produces no output.      Examples     --------     >>> import networkx as nx     >>>     >>> G = nx.complete_graph(4)     >>> for path in all_simple_paths(G, source=0, target=3):     ...     print(path)     ...     [0, 3]     [0, 1, 3]     [0, 2, 3]     [0, 2, 1, 3]     [0, 1, 2, 3]     >>> paths = nx.bidirectional.all_simple_paths(G, source=0, target=3, cutoff=2)     >>> print(list(paths))     [[0, 3], [0, 1, 3], [0, 2, 3]]      Notes     -----     This algorithm constructs sequentially two trees, one from the source     in direction to the target and one from the target in direction to the     source. The leaves of both growing trees are continuously compared, if     there are matching leaves in both trees, a new path is identified.      This algorithm actually reduces the search space by half, which results     in a faster identification of simple paths than in the original     "all_simple_paths" algorithm. But it requires more memory, which can     have a negative effect on the speed in fully connected graphs.                              source                                  /\                             /\ \                            / /\ \                           /   /\ \                          /\  /\  /\                         /  \/   /  \                        /    \  /\   \                       /_____/_/__\___\_________  meeting points                      /\     \    /   /\                     /XX\    /  \/   /XX\                    /XXXX\   \/  \  /XXXX\                   /XXXXXX\  /    \/XXXXXX\                  /XXXXXXXX\ \/   /XXXXXXXX\                 /XXXXXXXXXX\ \  /XXXXXXXXXX\                /XXXXXXXXXXXX\ \/XXXXXXXXXXXX\               /XXXXXXXXXXXXXX\/XXXXXXXXXXXXXX\                            target     Authors     -------     Andr√© Dietrich and Sebastian Zug     {dietrich, zug}@ivs.cs.uni-magdeburg.de      See Also     --------     nx.all_simple_paths, nx.all_shortest_paths, nx.shortest_path,     nx.bidirectional.all_shortest_paths, nx.bidirectional.has_path     """      if source not in G:         raise nx.NetworkXError('source node %s not in graph'%source)     if target not in G:         raise nx.NetworkXError('target node %s not in graph'%target)     if cutoff is None:         cutoff = len(G)-1     if G.is_multigraph():         return _all_simple_paths_multigraph(G, source, target, cutoff=cutoff)     else:         return _all_simple_paths_graph(G, source, target, cutoff=cutoff) ```  ``` python     print inspect.getsource(nx.bidirectional._all_simple_paths_graph) ```  ``` def _all_simple_paths_graph(G, source, target, cutoff):      if cutoff < 1:         return      tree = [{(source,)}, {(target,)}]      for i in range(cutoff):                tree1  = tree[i%2]         tree2  = tree[(i+1)%2]         temp   = set()          leaves = {x[-1] for x in iter(tree1)} # only to reduce some effort                 for path in iter(tree2):             for s in iter(G[path[-1]]):                 if s not in path:                     if s in leaves:                         for _path in iter(tree1):                             if s == _path[-1]:                                 if not set(_path).intersection(path):                                     if i % 2:                                         yield list(path)  + [x for x in reversed(_path)]                                     else:                                         yield list(_path) + [x for x in reversed(path)]                     temp.add(path + (s,))          tree[(i+1)%2] = temp ``` ## 1. Examples  ``` python     %pylab inline     import matplotlib.pyplot as plt     plt.rcParams['figure.figsize'] = (10.0, 8.0)      Populating the interactive namespace from numpy and matplotlib      G = nx.complete_graph(5)       nx.draw_circular(G) ```  ![output_7_0](https://cloud.githubusercontent.com/assets/3089101/8331677/d917956c-1a89-11e5-816f-40d0d09c2a06.png) ### 1.1 bidirectional.all_simple_paths_tweak  ``` python     for path in nx.bidirectional.all_simple_paths(G, source=0, target=4):         print(path) ```  ``` [0, 4] [0, 1, 4] [0, 2, 4] [0, 3, 4] [0, 1, 2, 4] [0, 3, 2, 4] [0, 2, 1, 4] [0, 3, 1, 4] [0, 1, 3, 4] [0, 2, 3, 4] [0, 1, 2, 3, 4] [0, 1, 3, 2, 4] [0, 3, 1, 2, 4] [0, 3, 2, 1, 4] [0, 2, 1, 3, 4] [0, 2, 3, 1, 4] ```  ``` python     paths = nx.bidirectional.all_simple_paths(G, source=0, target=4, cutoff=2)     print(list(paths)) ```  ``` [[0, 4], [0, 1, 4], [0, 2, 4], [0, 3, 4]] ``` ### 1.2 bidireactional.all_shortest_paths  ``` python     for path in nx.bidirectional.all_shortest_paths(G, source=0, target=4):         print(path) ```  ``` [0, 4] ``` ### 1.3 bidirectional.has_path  ``` python     print nx.bidirectional.has_path(G, source=0, target=4) ```  ``` True ``` ## 2. Multigraphs  All algorithms can also run on multigraphs, with the same benefits  ``` python     Gm = nx.MultiGraph()     Gm.add_nodes_from([2,3])     Gm.add_nodes_from([2,3])     H=nx.random_geometric_graph(10,0.2, 2)     H.add_path([0,1,2,3,4,5,6,7,8,9])     Gm.add_nodes_from(H)     Gm.add_node(H)      Gm.add_edges_from(H.edges())     Gm.add_edges_from(H.edges())      nx.draw_circular(Gm) ```  ![output_16_0](https://cloud.githubusercontent.com/assets/3089101/8331699/fbaf6ce4-1a89-11e5-9ddd-9057595374d6.png) ### 2.1 All simple paths ... produce the same results in order  ``` python     for path in enumerate(nx.bidirectional.all_simple_paths(Gm, 1, 8, cutoff=4)):         print path ```  ``` (0, [1, 3, 8]) (1, [1, 3, 8]) (2, [1, 3, 8]) (3, [1, 3, 8]) (4, [1, 0, 9, 8]) (5, [1, 0, 9, 8]) (6, [1, 0, 9, 8]) (7, [1, 0, 9, 8]) (8, [1, 0, 9, 8]) (9, [1, 0, 9, 8]) (10, [1, 0, 9, 8]) (11, [1, 0, 9, 8]) (12, [1, 2, 3, 8]) (13, [1, 2, 3, 8]) (14, [1, 2, 3, 8]) (15, [1, 2, 3, 8]) (16, [1, 2, 3, 8]) (17, [1, 2, 3, 8]) (18, [1, 2, 3, 8]) (19, [1, 2, 3, 8]) (20, [1, 2, 6, 7, 8]) (21, [1, 2, 6, 7, 8]) (22, [1, 2, 6, 7, 8]) (23, [1, 2, 6, 7, 8]) (24, [1, 2, 6, 7, 8]) (25, [1, 2, 6, 7, 8]) (26, [1, 2, 6, 7, 8]) (27, [1, 2, 6, 7, 8]) (28, [1, 2, 6, 7, 8]) (29, [1, 2, 6, 7, 8]) (30, [1, 2, 6, 7, 8]) (31, [1, 2, 6, 7, 8]) (32, [1, 2, 6, 7, 8]) (33, [1, 2, 6, 7, 8]) (34, [1, 2, 6, 7, 8]) (35, [1, 2, 6, 7, 8]) ```  ``` python     for path in enumerate(nx.all_simple_paths(Gm, 1, 8, cutoff=4)):         print path ```  ``` (0, [1, 0, 9, 8]) (1, [1, 0, 9, 8]) (2, [1, 0, 9, 8]) (3, [1, 0, 9, 8]) (4, [1, 0, 9, 8]) (5, [1, 0, 9, 8]) (6, [1, 0, 9, 8]) (7, [1, 0, 9, 8]) (8, [1, 2, 3, 8]) (9, [1, 2, 3, 8]) (10, [1, 2, 3, 8]) (11, [1, 2, 3, 8]) (12, [1, 2, 6, 7, 8]) (13, [1, 2, 6, 7, 8]) (14, [1, 2, 6, 7, 8]) (15, [1, 2, 6, 7, 8]) (16, [1, 2, 6, 7, 8]) (17, [1, 2, 6, 7, 8]) (18, [1, 2, 6, 7, 8]) (19, [1, 2, 6, 7, 8]) (20, [1, 2, 3, 8]) (21, [1, 2, 3, 8]) (22, [1, 2, 3, 8]) (23, [1, 2, 3, 8]) (24, [1, 2, 6, 7, 8]) (25, [1, 2, 6, 7, 8]) (26, [1, 2, 6, 7, 8]) (27, [1, 2, 6, 7, 8]) (28, [1, 2, 6, 7, 8]) (29, [1, 2, 6, 7, 8]) (30, [1, 2, 6, 7, 8]) (31, [1, 2, 6, 7, 8]) (32, [1, 3, 8]) (33, [1, 3, 8]) (34, [1, 3, 8]) (35, [1, 3, 8]) ``` ### 2.2 but there is a difference in all shortest paths ... our approach seems to find all paths, while the original implimentation does not  ``` python     for path in enumerate(nx.bidirectional.all_shortest_paths(Gm, 1, 8)):         print path ```  ``` (0, [1, 3, 8]) (1, [1, 3, 8]) (2, [1, 3, 8]) (3, [1, 3, 8]) ```  ``` python     for path in enumerate(nx.all_shortest_paths(Gm, 1, 8)):         print path ```  ``` (0, [1, 3, 8]) ``` ## 3.Benchmark  ``` python     import time     import random      # trying out a huge graph...     G1 = nx.dense_gnm_random_graph(15000,15000,2) ``` ### 3.1 Speed - has_path  unfortunately, our approach for has_path seems to be slower than the original approach...  ``` python     times1, times2 = [], []     for i in range(15000):         source = random.randint(0, len(G1)-1)         target = random.randint(0, len(G1)-1)          # tweak         t = time.time()         nx.bidirectional.has_path(G1, source, target)         times2.append(time.time()-t)          # original         t = time.time()         nx.has_path(G1, source, target)         times1.append(time.time()-t)       print "original:\t", mean(times1)     print "bidirectional:\t", mean(times2) ```  ``` original:   0.000111669810613 bidirectional:  0.000192139514287 ```  ``` python     n, bins, patches = plt.hist(times1, bins=50, normed=1, histtype='bar', rwidth=0.8, label="original")     n, bins, patches = plt.hist(times2, bins=200, normed=1, histtype='bar', rwidth=0.8, label="bidirectional")     plt.xlim(0, 0.002)     plt.ylim(0, 5000)     plt.legend()     plt.title("Comparison - has_path")      <matplotlib.text.Text at 0x7f5f72630ed0> ```  ![output_28_1](https://cloud.githubusercontent.com/assets/3089101/8331715/0d70169a-1a8a-11e5-9938-8db167cedce7.png) ### 3.2 Speed - Shortest Paths  ... but in the shortest path approach we win ... as you see in the diagrams below, there is even three outliers  below that are below the average of original shortest path search. By the way, both diagrams depict the relation of resulting path lengths and time for their identification... I actually do not know why there are these two chunks in the original approach...  ``` python     times1, times2     = [], []     results1, results2 = [], []     lengths1, lengths2 = [], []     for i in range(5000):         source = random.randint(0, len(G1)-1)         target = random.randint(0, len(G1)-1)          if not nx.has_path(G1, source, target):             continue          # bidirectional         t = time.time()         res = list(nx.bidirectional.all_shortest_paths(G1, source, target))         times2.append(time.time()-t)         results2.append(len(res))         lengths2.append(len(res[0]))          # original         t = time.time()         res = list(nx.all_shortest_paths(G1, source, target))         times1.append(time.time()-t)         results1.append(len(res))         lengths1.append(len(res[0]))          #print i, times1[-1], times2[-1]         #time.sleep(1)       print "original:\t", mean(times1)     print "bidirectional:\t", mean(times2) ```  ``` original:   0.024720553465 bidirectional:  0.000553524412061 ```  ``` python     plt.plot(lengths1, times1, 'bs')     plt.xlabel("Number of found paths")     plt.ylabel("Time in seconds")     plt.title("Original: Time vs. Number of shortest paths found")      <matplotlib.text.Text at 0x7f5f72531850> ```  ![output_32_1](https://cloud.githubusercontent.com/assets/3089101/8331730/1bfb0df0-1a8a-11e5-9253-c712e1ca1519.png)  ``` python     plt.plot(lengths2, times2, 'gs')     plt.xlabel("Number of found paths")     plt.ylabel("Time in seconds")     plt.title("Bidirectional: Time vs. Number of shortest paths found")      <matplotlib.text.Text at 0x7f5f711de190> ```  ![output_33_1](https://cloud.githubusercontent.com/assets/3089101/8331740/26962204-1a8a-11e5-8f38-212a5f11e6a8.png)  ``` python     n, bins, patches = plt.hist(times1, bins=50, normed=1, color="b", histtype='bar', rwidth=0.8, label="original")     n, bins, patches = plt.hist(times2, bins=50, normed=1, color="g", histtype='bar', rwidth=0.8, label="bidirectional")     plt.legend()     plt.title("Comparison - all_shortest_paths")      <matplotlib.text.Text at 0x7f5f71210610> ```  ![output_34_1](https://cloud.githubusercontent.com/assets/3089101/8331744/2efccff6-1a8a-11e5-922b-3c1ed4a426df.png) ### 2.3 Speed - All Simple Paths  Next to the benefit of finding all simple paths in order... the bidirectional search seems also to be much faster... The following code measures the time it takes for generating all simple paths with both approaches. Whereby the cutoff is increased step by step resulting in very huge results sets...  ``` python     times1, times2     = [], []     results1, results2 = [], []     print "Cutoff\t#\tTimes original\t\tTimes bidirectional"     for i in range(31):         t = time.time()         res = list(nx.bidirectional.all_simple_paths(G1, 1, 4999, cutoff=i))         times2.append(time.time()-t)         results2.append(len(res))              # original         t = time.time()         res = list(nx.all_simple_paths(G1, 1, 4999, cutoff=i))         times1.append(time.time()-t)         results1.append(len(res))          print i, "\t", results1[-1], "\t",times1[-1], "\t",times2[-1]         time.sleep(1) ```  ``` Cutoff  #   Times original      Times bidirectional 0   0   9.05990600586e-06   2.28881835938e-05 1   0   1.21593475342e-05   4.60147857666e-05 2   0   5.00679016113e-05   0.000115156173706 3   1   3.79085540771e-05   8.9168548584e-05 4   1   4.31537628174e-05   9.41753387451e-05 5   1   0.000125169754028   0.000171184539795 6   1   0.000373125076294   0.00026798248291 7   1   0.000718832015991   0.000355005264282 8   1   0.00141310691833    0.000416040420532 9   1   0.00272083282471    0.000531196594238 10  1   0.00544095039368    0.000647068023682 11  1   0.00988912582397    0.000939846038818 12  2   0.011785030365  0.00146794319153 13  2   0.02867603302   0.00288987159729 14  4   0.0268549919128     0.00106501579285 15  7   0.0633940696716     0.00675392150879 16  14  0.123420000076  0.00654101371765 17  25  0.230616092682  0.0211839675903 18  56  0.479142904282  0.0115299224854 19  102     0.979547977448  0.0393309593201 20  201     1.95987606049   0.0607471466064 21  436     4.03744196892   0.135717868805 22  872     8.60605311394   0.325693130493 23  1814    16.5568730831   0.766483783722 24  3580    34.1799459457   2.57762503624 25  7227    68.5836060047   5.14452195168 26  14670   142.398111105   23.4591898918 27  29613   310.70114994    45.2433450222 28  59372   599.497899055   167.191638947 29  119355  1300.70439291   289.602411032 30  239761  2149.18087816   615.817314863 ```  ``` python     plt.title("Search in graph with 15000 nodes: Time vs. Cutoffs")     plt.ylabel("Time in seconds (logarithmic scale)")     plt.xlabel("Cutoffs")     plt.plot(range(len(times1)), times1, color="b", linestyle='-', marker='o', label="nx.all_simple_paths")     plt.plot(range(len(times2)), times2, color="g", linestyle='-', marker='o', label="bidirectional.all_simple_paths")     plt.yscale('log')     plt.legend(loc="lower right")     plt.grid(True, which="both") ```  ![output_37_0](https://cloud.githubusercontent.com/assets/3089101/8331748/386c5b42-1a8a-11e5-99e7-89a2bfd1fa3f.png) ### A smaller graph  Trying the same speed test with a smaller graph (with relatively more edges) seems to produce be similar results... But as you can see in both diagrams, there is something like a break-even point, where it is acutally better to apply the original graph traversing algortithm. Thus, in both logarithmic scales, the original graph traversing shows a linear increase ... in contrast to our approach ... But only for very large result sets or for highly connected graphs.  ``` python     G2 = nx.dense_gnm_random_graph(100,500,1)     nx.draw_networkx(G2) ```  ![output_39_0](https://cloud.githubusercontent.com/assets/3089101/8331755/3f8efc04-1a8a-11e5-8dfd-0eca925381d1.png)  ``` python     times1, times2     = [], []     results1, results2 = [], []     print "Cutoff\tPaths\tTime orig.\t\tTime bidirect."     for i in range(11):         res = 0         t = time.time()         for _ in nx.bidirectional.all_simple_paths(G2, 1, 99, cutoff=i):             res += 1         times2.append(time.time()-t)         results2.append(res)              # original         res = 0         t = time.time()         for _ in nx.all_simple_paths(G2, 1, 99, cutoff=i):             res += 1         times1.append(time.time()-t)         results1.append(res)          print i, "\t", results1[-1], "\t",times1[-1], "\t",times2[-1],         time.sleep(1)         print ```  ``` Cutoff  Paths   Time orig.      Time bidirect. 0   0   5.96046447754e-06   1.00135803223e-05 1   0   1.71661376953e-05   4.50611114502e-05 2   3   0.000102996826172   0.000167846679688 3   11  0.000810146331787   0.000355958938599 4   99  0.00350999832153    0.00141596794128 5   981     0.0222702026367     0.0144529342651 6   9459    0.35150885582   0.112168073654 7   89808   2.1227080822    0.789459943771 8   840734  19.211204052    8.78042912483 9   7775454     201.188947201   127.474290848 10  70932787    1477.70097995   1536.45552993 ```  ``` python     plt.title("Search graph with 500 nodes: Time vs. Cutoffs")     plt.ylabel("Time in seconds (logarithmic scale)")     plt.xlabel("Cutoffs")     plt.plot(range(len(times1)), times1, linestyle='-', marker='o', label="nx.all_simple_paths")     plt.plot(range(len(times2)), times2, linestyle='-', marker='o', label="bidirectional.all_simple_paths")     plt.yscale('log')     plt.legend(loc="lower right")     plt.grid(True, which="both") ```  ![output_41_0](https://cloud.githubusercontent.com/assets/3089101/8331767/4bd37a76-1a8a-11e5-8765-315da8902098.png) ## Memory  Actually I was expecting much more memory consumed by our approach. As you see in the code, we apply the memit, which measures the "process" and the highest amount of memory consumed. The for-loop is chosen to prevent the storage and thus the (probably) wrong increase of elements from the resulting list. The memory measurement should only contain memory allocated by both generators... As it seems, it is more valuable to store the paths, than the iterators over the nodes...  ``` python     from IPython.utils import io     import memory_profiler      def load_ipython_extension(ip):         ip.define_magic('memit', memory_profiler.magic_memit)       memory1, memory2   = [], []     print "Level\tMem orig\tMem bidirect"     for level in range(11):          res = 0         with io.capture_output() as mem:             %memit -r 3 for _ in nx.all_simple_paths(G2, 1, 99, cutoff=level): res+=1         mem = str(mem.stdout)           pos1 = mem.find("increment:") + 11         pos2 = mem.rfind(" MiB")         memory1.append(float(mem[pos1:pos2]))          #time.sleep(5)          res = 0         with io.capture_output() as mem:             %memit -r 3 for _ in nx.bidirectional.all_simple_paths(G2, 1, 99, cutoff=level): res +=1         mem = str(mem.stdout)           pos1 = mem.find("increment:") + 11         pos2 = mem.rfind(" MiB")         memory2.append(float(mem[pos1:pos2]))          #time.sleep(5)          print level, "\t", memory2[-1], "\t\t", memory1[-1] ```  ``` Level   Mem orig    Mem bidirect 0   0.0         0.0 1   0.0         0.0 2   0.0         0.0 3   0.0         0.0 4   0.0         0.0 5   0.0         0.0 6   0.0         0.0 7   0.0         0.0 8   0.27        0.0 9   8.55        0.0 10  26.18       0.0 ``` 
