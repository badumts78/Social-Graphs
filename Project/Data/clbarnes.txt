issue
compose() erases some MultiGraph edges#TITLE_END#If a user wants to compose two multigraphs, it is very likely that they want to use all of the edges present in both. In MultiGraphs, edges which share the same (source, target) pair are not the same. Currently, edges which share the same (source, target, key) tuple are treated the same: as keys are assigned in insertion order by default, rather than having anything to do with the data, the end user just sees that an arbitrary few of their edges have gone missing.  ``` python import networkx as nx  a, b = nx.MultiGraph(), nx.MultiGraph() a.add_path([1,2]) b.add_path([1,2])  nx.compose(a,b).number_of_edges() == a.number_of_edges() + b.number_of_edges() >>> False ```  The documentation states that the edge sets are unioned. If this edge set is hashed by (source, target) pair, then the function cannot be advertised as applicable to MultiGraphs, because it collapses all multiedges. If the edge set is hashed by (source, target, key), as it is currently, then there is unexpected and possibly arbitrary behaviour which is not well documented. The edge set should be hashed by a UUID for MultiGraphs (i.e. all edges are distinct), in order to reflect how these classes are actually going to be used. 
issue
Feature request: MultiGraph.remove_edge(u, v) should removes all such edges, not an arbitrary one#TITLE_END#Same goes for MultiDiGraph...  Currently, if a user wants to disconnect two nodes and doesn't know how many edges there are between them, the best way to do this is using an infinite while loop and breaking on exception. This has to throw and catch an exception for every edge removed, which can be a large number, and is thus inefficient. 
