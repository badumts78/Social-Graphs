issue
Floating-point error results in error in Preflow-Push Algorithm#TITLE_END### Preflow-Push Algorithm Issue in `relabel()` Function  This issue pertains to the Preflow-Push algorithm, specifically in the `relabel()` function within `preflow_push_impl()` in the `preflowpush.py` file.  ---  ### Current Behavior  I ran a network simulation utilizing your library, which extensively uses the `max_flow` algorithm based on the Preflow-Push algorithm. Occasionally, though rarely, the `min()` operation in the `relabel()` function encounters an empty set. Specifically, the following expression:  ```python R_nodes[v]["height"] for v, attr in R_succ[u].items() if attr["flow"] < attr["capacity"] ```  returns an empty set. However, according to the Preflow-Push algorithm, this situation should not be possible. If there is excess on a node, it implies that the excess originated from another node via an edge. Hence, there should be an edge in the residual graph that fulfills the condition, ensuring the above set is not empty.  When attempting to reproduce this issue, it proved elusive as it appears to occur randomly. However, during debugging, I observed the following:  - When the issue occurs, the excess is very small, typically in the range of `[1e-10, 1e-11]`. - All edges leaving the problematic node have `capacity = flow = 0`.  This suggests that the excess is effectively zero but affected by floating-point errors. Consequently, the algorithm fails to recognize this and triggers the error.  To address this, I implemented a rounding mechanism for the comparison at Line 151:  ```python if round(R_nodes[u]["excess"], 8) == 0:     # The node has become inactive.     levels[height].inactive.add(u)     break ```  This modification resolved the issue in my use case.  ---  ### Expected Behavior  The `relabel()` function should not operate on an empty set under any circumstances, as per the theoretical guarantees of the Preflow-Push algorithm. Proper handling of floating-point errors should ensure this.  ---  ### Steps to Reproduce  Unfortunately, this issue is difficult to reproduce as it occurs sporadically. A minimal example or controlled simulation has not yet been identified.  ---  ### Environment  - **Python version**: 3.11.10   - **NetworkX version**: 3.4.2  ---  ### Additional Context  I am using a `DiGraph` where each edge is assigned a capacity. Floating-point inaccuracies in flow calculations appear to be the root cause of this issue.  ---  
