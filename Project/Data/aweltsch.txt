issue
WIP: Implement Incremental Topological Sort (Issue 1457)#TITLE_END#I started to add an algorithm that can be used to incrementally update the topological sorting of a directed graph. I'm not 100% content with the API design. It would be great to get some feedback.  I am particularly concerned with the placement of the corresponding data structure (`class IncrementalTopologicalSort`). Is the `dag.py` file the right place?  Also I wondering if I should derive the class from the `nx.DiGraph` or something like that.  Any additional feedback is greatly appreciated! Thank you!
issue
Enumerate all topological sorts of a digraph#TITLE_END#Issue #2720  Implementation of an enumeration algorithm for topological sorts. Based on https://doi.org/10.1016/0020-0190(74)90001-5
issue
Copy graph in transitive closure algorithm.#TITLE_END#Hi, I implemented a small patch to fix issue #2578. I used the solution propsed there and added appropriate tests. Andre
comment
If there is noone working on it currently, I would like to work on this.
comment
I'm currently implementing https://doi.org/10.1016/0020-0190(74)90001-5 My plan is to implement both the recursive as well as the iterative version and then give the option to choose the algorithm (default will be iterative) I already implemented the recursive version (as it is significantly easier to do). Obviously, the recursive procedure comes with the usual problems related to recursion depth (linear in the number of nodes). Also I don't know any easy way to use the yield statement with recursive function calls, so there will be huge memory requirements (as there are up to`n!` on a graph with `n` nodes)   I did not yet examine the dynamic programming/iterative procedure, but I guess there we can use the yield keyword, so we don't have to hold all topological sorts in memory.  If there is no interest in the recursive version at all, I'll just leave it and will only include the iterative version. I just chose to implement the recursive one, because it's so easy to do, and then we have at least one working version, until I find time to implement the iterative one.
comment
Ok, I decided to replace the recursive algorithm with the iterative one, as they are very similar. I kept the recursive one in a separete commit, to record it in the project history. I hope this is ok.  Another question: I'm a very big fan of property based testing on randomized instances. Does it make sense to add something like this to the tests? I'm thinking about creating a random dag by selecting random pairs of the form `(i, j)` with `i < j`. For graphs up to 10 nodes, we could then compare the algorithm output with a naive filtering of permutations (take permutations of nodes that are topological sorts of the graph (easy to check)) Another idea is to test it on bigger random graphs and check if the first few results returned by the algorithm hold the topological sorting property. I'm very interested in ensuring that the implementation that I provided is correct, so it might be worth considering. Obvious downsides include prolonged tests.
comment
Also I found some other papers that might also be interesting to implement. Maybe I can look into this and add this in another merge request, when I find time next week: https://doi.org/10.1023/A:1016548222238 https://doi.org/10.1007/11537311_39 
comment
I read the papers, and this seems doable. I would like to work on this.
