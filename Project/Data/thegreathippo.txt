issue
Invalid call to from_pandas_dataframe function?#TITLE_END#While looking for a problem in my branch, I noticed what looks like an invalid chunk of code (direct link to the line [here](https://github.com/networkx/networkx/blob/d7d906e1d16ef331da0bc1d149953e7532155acc/networkx/convert.py#L133-L134)):  ```     try:         import pandas as pd         if isinstance(data, pd.DataFrame):             try:                 return nx.from_pandas_dataframe(data, create_using=create_using)             except:                 msg = "Input is not a correct Pandas DataFrame."                 raise nx.NetworkXError(msg) ```  `from_pandas_dataframe` requires, at the very least, _three_ arguments -- with `create_from` being an optional keyword argument. Because the `try: except:` block is untyped, this will always report a `NetworkXError` no matter what. 
issue
Graph.add_node method mutates attr_dict parameter#TITLE_END#``` >>> import networkx >>> g = networkx.Graph() >>> my_dict = {"x": 0, "y": 0} >>> g.add_node("node", my_dict, y=1) >>> print(my_dict) {'y': 1, 'x': 0} >>> my_dict["x"] = 1 >>> print(g.node["node"]) {'y': 1, 'x': 1} >>> my_other_dict = {"x": 5} >>> g.add_node("node", my_other_dict) >>> print(my_dict) {'y': 1, 'x': 5} >>> g.add_node("other node", my_dict) >>> my_dict["x"] = 10 >>> print(g.node["node"]) {'y': 1, 'x': 10} >>> print(g.node["other node"]) {'y': 1, 'x': 10} ```  Is this working as-intended? It seems like it could create some very subtle, very hard-to-track bugs -- such as someone using the same dictionary to initialize multiple nodes without realizing that by doing so, they've caused all those nodes to share the same dictionary -- or someone naively using an object's `__dict__` to generate node attributes, not realizing that by doing so, they'll modify that object's attributes every time they modify the node attributes (or vice versa).  (I suppose there are some potential edge cases where this might be beneficial? Maybe you _want_ certain nodes to share a dictionary, or maybe you _want_ to be able to modify node attributes from outside the graph object? But both those things seem like a bad idea to me, and something you could probably handle by _directly_ assigning a dictionary rather than doing it through the add_node method)  I also noticed that add_edge avoids part of this issue by creating a new dict ('datadict') and updating it with attr_dict -- though it still mutates attr_dict with the **kwargs passed to it (so you'll always end up with a fresh edge attribute dictionary, but you'll still mutate the dictionary you passed to the method to create that dictionary). If this wasn't done, then it would be very easy to have multiple edges share the same dictionary (which would potentially play havoc when it came time to start relying on the 'weight' edge attribute!).  If this isn't intentional, it seems easy to fix (just use a copy of attr_dict rather than attr_dict); if it _is_ intentional, there might be some benefit to documenting the difference between how add_node assigns node attributes and how add_edge assigns edge attributes?  (Apologies in advance if this issue has already been raised / addressed!) 
issue
Graph.add_node, Graph.add_edge, and Graph.add_edges_from modification#TITLE_END#For each respective method, I just snuck in an empty `node_attr` and `edge_attr` dictionary, updated it based on the supplied parameters (`attr_dict` and `attr`), then either plugged it in if no attribute dictionary existed -- or updated an existing attribute dictionary if it was there. That way, you avoid mutating attr_dict and don't end up accidentally sharing a dictionary across multiple nodes (or other objects).   Notably, this caused some test failures -- because we're no longer invoking the `update` method on`attr_dict`. And since a Python dictionary's `update` method can accept an empty sequence, just passing an empty sequence through `attr_dict` no longer raised an exception. So I added an int to the sequences to make the exception raise.  This leads to an interesting positive trade-off, though: Since we're updating a dictionary with `attr_dict`, `attr_dict` doesn't _have_ to be a dictionary. It can be any value that the `update` method accepts: Including sequences of 2-d tuples. So this:  ``` >>> import networkx >>> g = networkx.Graph() >>> g.add_node("node", [("weight", 5)]) >>> print(g.node["node"]) {'weight' : 5} ```  -- is perfectly acceptable. So is:  ``` >>> import networkx >>> g = networkx.Graph() >>> my_dict = {"x": 0} >>> g.add_node("node", my_dict.items()) >>> print(g.node["node"]) {'x' : 0} ```  And, of course, the old way works too, sans mutation or direct assignment:  ``` >>> import networkx >>> g = networkx.Graph() >>> my_dict = {"x": 0} >>> g.add_node("node", my_dict, x=1) >>> print(g.node["node"]) {'x' : 1} >>> print(my_dict) {'x' : 0} ```  (As an aside, this is my first attempt at trying to help with a collaborative github project -- so if I've messed up anywhere in this process, please feel free to tell me!) 
issue
MultiGraph.add_edge overwrites edges in certain non-explicit cases#TITLE_END#``` >>> import networkx >>> mg = networkx.MultiGraph() >>> mg.add_edge("n1", "n2", weight=0) >>> mg.add_edge("n1", "n2", key=0, weight=1) >>> print(mg["n1"]["n2"]) {0: {'weight': 1}} ```  The same problem pops up when adding edges with `add_edges_from`:  ``` >>> my_edges = [("e1", "e2", {"weight": 0}), ("e1", "e2", 0, {"weight": 1})] >>> mg.add_edges_from(my_edges) >>> print(mg["e1"]["e2"]) {0: {'weight': 1}} ```  It's a fairly fringe case, but potentially important when dealing with tuples of asymmetric size. The expected behavior would be for unspecified keys to never collide with specified keys. The problem seems to be [this](https://github.com/networkx/networkx/blob/992eec97fa68647ccd67f6e1f3faa743a443247e/networkx/classes/multigraph.py#L325-L332) piece of code, in `multigraph.py`'s `add_edge` method:  ```         if v in self.adj[u]:             keydict = self.adj[u][v]             if key is None:                 # find a unique integer key                 # other methods might be better here?                 key = len(keydict)                 while key in keydict:                     key += 1 ```  The simple fix that springs to mind is that in cases where we don't care enough to specify the key, we should use a non-int key that can't be reproduced (but can be copied); something like:  ``` class UnspecifiedKey(object):     _id = 0     def __init__(self, _id=None):         if _id is None:             _id = self._id             type(self)._id += 1         self.id = _id      def __eq__(self, other):         if type(self) == type(other):             return self.id == other.id      def __hash__(self):         return hash((type(self), self.id))      def __copy__(self):         return type(self)(self.id) ```  ...which shouldn't raise any notable exceptions (actually, double-checking -- it breaks `test_remove_edges_from` [here](https://github.com/networkx/networkx/blob/d7d906e1d16ef331da0bc1d149953e7532155acc/networkx/classes/tests/test_multigraph.py#L213-L230), but I strongly suspect that's because the test _assumes_ that unspecified keys will increment from 0 upward; the equivalent test for `MultiDiGraph` _doesn't_ break, probably because it _doesn't_ make that assumption).  (Also, posting this issue only because I noticed it while dealing with my pull request, but didn't want to take anything else on -- just wanted to make a notation somewhere so I wouldn't forget to mention it!) 
comment
Cool! Thanks again for helping me complete this pull; it's been a great chance to learn about programming (especially in a collaborative environment) and github in general. I appreciate the opportunity! 
