issue
Hashable graphs?#TITLE_END#The behavior of hashing a graph is not ideal.  For reference, this is how hashing a graph currently works:  ```python In[10]: G = nx.balanced_tree(4,2) In [11]: hash(G) Out[11]: 275084920 In [12]: G.add_node(100) In [13]: hash(G) Out[13]: 275084920 ```  Further:  ```python In [14]: G.nodes() Out[14]: NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 100)) In [15]: G = nx.balanced_tree(4,2) In [16]: hash(G) Out[16]: -9223372036579765409 In [17]: G.nodes() Out[17]: NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)) ```  So basically, the way it works now is that graphs are assigned a hash upon creation, and it does not change if they change. It is also not the case that two graphs which are exactly similar have the same hash.  Further, the following:  ```python In [18]: nx.balanced_tree(4,2) == nx.balanced_tree(4,2) Out[18]: False ```  This is not ideal if you want to memoize a function that has a graph as a parameter (my specific use case), or compare graphs.  My proposed solution would be to create a hashing function something akin to the following:  ```python def __hash__(self):     return hash(set(self.nodes()) | set(self.edges())) ```  Since nodes and edges are already inherently hashable.  This would ignore changes to node attributes, but given that node attributes need not be hashable, this is to be expected. Users can create their own custom hash functions in these cases, and perhaps a user warning could be raised as well.
issue
nx.write_gpickle and nx.read_gpickle not implementing os.PathLike#TITLE_END#If you use pathlib in python3, networkx.write_gpickle and networkx.read_gpickle will not accept these as paths.
