issue
Add feature: finding densest k-node subgraph. Corresponding to issue #999#TITLE_END#Answering the wish list #999. I implemented the approximate algorithms proposed in the [paper 2](http://arxiv.org/abs/0912.5327) @hagberg mentioned in his comment.  paper 2 is based on previous work of [paper 1](http://link.springer.com/article/10.1007/s004530010050). Both are referred in the code.  Basically, this problem is NP-hard. The algorithm proposed is a combination of 5 different algorithms (as in the code, they correspond to `__trivial(), __greedy(), __walks2(), __walks3(), __walks4()`. For reference, better see in paper 1, since paper 2 didn't mention all 5 algorithms in detail), each of which can solve one aspect of this problem, and by choosing the best result out of 5 different results, the paper claim it has constant approximation ratio. Combining first 3 is called algorithmA, while adding the left 2 is called algorithmB. algorithmA alone can give reasonable approximation in average cases, algorithmB is brought up to deal with the worst cases. The work of paper 2 is mainly dealing with worst cases, too, besides more rigorous performance proof.   However, I found the 4th and 5th algorithm (hence algorithmB) too complicated, and slow. Meanwhile, as proven in the paper, I don't think they contribute much to the average case. I did write algorithm 4 (`__walks3()`), but I found it really consuming since it makes quite a lot of calls on the other 3 algorithms. So I dropped them, waiting for your review and suggestion, for now I don't want to dive into this blindly. I'm not math student, all the formulas made me dizzy already, so forgive me I didn't work it through.  For the tests, I used one graph from the [wikipedia page](en.wikipedia.org/wiki/Dense_subgraph) for this program. And one using nx.wheel_graph(), because the centre of wheel_graph must be included if k > 1. in doc tests, I used nx.house_graph(), again, the triangle is the optimum solution when k == 3.  Waiting for your review. I would be happy to listen to your suggestion, and of course, open to bug fixes ;) 
issue
Issue 762 shortest path hide nodes edges#TITLE_END#I add the monkey patching context manager in a separate file named `restrictions.py`. I'm glad to hear your code reviews. About testing, I add some in the `test_generics.py`, because I think it duplicated if I also test them in `test_weight.py` or `test_unweight.py`, etc. Let me know if you have concerns about adding more tests. ;) 
comment
I'd like to pick this up. It turns out the paper you just mentioned is mostly based on [this work](http://link.springer.com/article/10.1007/s004530010050). I think I can implement those 5 algorithms they mentioned, by the way, which directory should I put it in? `/networkx/algorithm/` ? 
comment
I'm almost done with the algorithm, can you give me some guidelines on testing? Those algorithms are only maximal/heuristics with a proven performance bound, but not guaranteed to give accurate/maximum answer, can you show me (other testing code in NetworkX) how you handle those tests in your project? Or any other thoughts? 
comment
Ok, that could be a good start. I will open a code review after I package the algorithm and tests. 
comment
@chebee7i I see, 1) the tests should verify that these algorithms can meet the theoretical lower bound proven in the papers. 2) And, I would remember to add a brute force algorithm for small graphs, that seems to be a great idea. 3) about consistence across NetworkX versions, would you kindly point to me more guidelines? Is there any tools available, or I need to run it in different versions of NetworkX distributions manually? (Isn't travis-ci already handling different Python runtimes?) If the later is the case, I would like to know which versions we are talking about. 
comment
@chebee7i  Ok, I get what you mean, thanks for your helpful inputs. I will work on it, as you suggested. 
comment
I find monkey-patch approach very interesting, and intriguing. I'd like give it a try. I'm working on it, hope we can make it before 1.9  
comment
Just tried it on my Mac EI Caption. Same error here. 
comment
@aschilling @hagberg   Hi, I'm also interested in social network influence analysis. As influence spread model, you think it also interesting to add influence maximization models [kempe, kdd03](http://www.cs.cornell.edu/home/kleinber/kdd03-inf.pdf) [wei chen, kdd10](http://research.microsoft.com/pubs/117862/msr-tr-2010-2_v2.pdf) into NetworkX ?  
comment
About this: "If we want to use this approach - returning generators of components instead of lists of components - then we should change the other code in networkx/algorithms/components to match." I think I can pick these up.  Let me list the change requirements I found in your commit: 1. *_component_subgraphs() functions add copy default argument (=True) 2. returning generators of components instead of lists of components 3. change to use `not_implemented_for` decorator 4. change corresponding test cases.  Am I missing anything? 
comment
I added some modifications following your suggestions, see PR #1009  
