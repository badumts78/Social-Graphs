issue
MultiGraph Isomorphism ignores edge_match?#TITLE_END#Consider the following code:  ``` import networkx as nx import networkx.algorithms.isomorphism as iso  G98 = nx.MultiGraph() G98.add_edge(1, 2, key = 1) G98.add_edge(1, 3, key = 5)  G185 = nx.MultiGraph() G185.add_edge(1, 2, key = 5) G185.add_edge(2, 3, key = 1)  G0 = nx.MultiGraph() G0.add_edge(1, 2, key = -1) G0.add_edge(1, 3, key = -1)  G1 = nx.MultiGraph() G1.add_edge(1, 3, key = 2) G1.add_edge(1, 2, key = 4)  em = iso.numerical_multiedge_match("key", -1)  nx.is_isomorphic(G98, G185, edge_match = em) nx.is_isomorphic(G98, G0, edge_match = em) nx.is_isomorphic(G98, G1, edge_match = em) nx.is_isomorphic(G0, G185, edge_match = em) ```  All four tests return `True`. The graphs are indeed all isomorphic, but only if we ignore the `key` attribute. By passing the `edge_match` function, I think I'm explicitly telling `is_isomorphic` to consider the `key` attribute, but it seems it is still ignoring it. Only `G98` and `G185` are truly isomorphic.  This is done in Networkx 2.1, Python 3.6, Ubuntu 18.04.  If I were to replace the `nx.MultiGraph` with `nx.Graph`, and `numerical_multiedge_match` with `numerical_edge_match`, the code would behave as I expect it to. Unfortunately, even if in the example there are no real multigraphs, down the line I'll have also multigraphs to test so I need this to work with `nx.MultiGraph`.  Note: the same behavior happens if I initialize `GraphMatcher` myself.  I'm not sure this is a bug, maybe I'm doing something wrong. How do I test `MultiGraph` isomorphism in `Networkx` without ignoring edge keys?
issue
Multigraph Monomorphisms#TITLE_END#I think the multigraph isomorphism matching routine is not working as expected. Consider the following code:  ``` python import networkx as nx from networkx.algorithms import isomorphism  MG = nx.MultiGraph() MG.add_edge(0, 1, label = 0) MG.add_edge(0, 1, label = 1) MG.add_edge(1, 2, label = 1) MG.add_edge(1, 2, label = 2) MG.add_edge(1, 2, label = 4) MG.add_edge(1, 3, label = 0) MG.add_edge(2, 3, label = 0) MG.add_edge(2, 3, label = 3) MG.add_edge(3, 4, label = 2) MG.add_edge(3, 4, label = 3) MG.add_edge(3, 4, label = 4) MG.add_edge(3, 5, label = 1)  edge_labels = 6 motifs_tocheck = []  for i in range(edge_labels):    motif = nx.MultiGraph()    motif.add_edge(0, 1, label = i)    motifs_tocheck.append(motif)  for i in motifs_tocheck:    GM = isomorphism.GraphMatcher(MG, i, edge_match = isomorphism.numerical_multiedge_match("label", -1))    print GM.subgraph_is_isomorphic()    for isos in GM.subgraph_isomorphisms_iter():       print isos ```  The generated MultiGraph is represented here:  ![toy](https://f.cloud.github.com/assets/3075791/1076310/3962d5f0-14e0-11e3-8dce-7a24e25a92bd.png)  The current output is:  ``` True {1: 0, 3: 1} {1: 1, 3: 0} True {3: 0, 5: 1} {3: 1, 5: 0} False False False False ```  What I'd expect as output is:  ``` True {0: 0, 1: 1} {0: 1, 1: 0} {1: 0, 3: 1} {1: 1, 3: 0} {2: 0, 3: 1} {2: 1, 3: 0} True {0: 0, 1: 1} {0: 1, 1: 0} {1: 0, 2: 1} {1: 1, 2: 0} {3: 0, 5: 1} {3: 1, 5: 0} True {1: 0, 2: 1} {1: 1, 2: 0} {3: 0, 4: 1} {3: 1, 4: 0} True {2: 0, 3: 1} {2: 1, 3: 0} {3: 0, 4: 1} {3: 1, 4: 0} True {1: 0, 2: 1} {1: 1, 2: 0} {3: 0, 4: 1} {3: 1, 4: 0} False ```  In motifs_tocheck there is one single-edge motif per element. The GraphMatcher catches only an isomorphism with labels "0" and "1" because they are the only ones for which there is no parallel edge (between nodes 1-3 and 3-5 respectively). However, I'd expect that all motifs find a match except the last, because label 5 is not present in the graph. "1-2" and "3-4" should be correct matches for a motif composed by a single edge labeled with "2". 
issue
k-core algorithm produces incorrect output for DiGraph#TITLE_END#As per title, calling `nx.k_core(G, k = x)` does not return the x-core of a graph, if `G` is a `DiGraph`.  See attached file.  [6954_2011.txt](https://github.com/networkx/networkx/files/105086/6954_2011.txt)  To reproduce, run:  ``` python import networkx as nx  G = nx.DiGraph() with open("6954_2011.txt", 'r') as f:    for line in f:       fields = line.strip().split('\t')       G.add_edge(fields[0], fields[1])  core = nx.k_core(G, k = 12) core.number_of_nodes() # Outputs "24"; expected output: "12" ```  There are only 12 nodes with (in+out) degree 12 once you remove recursively all those which don't qualify. These are:  IND AUT CHE BEL USA ESP CHN FRA NLD GBR ITA DEU  While  ``` python core.nodes() ```  says `['BEL', 'SWE', 'DEU', 'GBR', 'KOR', 'USA', 'SGP', 'MYS', 'POL', 'NLD', 'HKG', 'FRA', 'CHE', 'ESP', 'CHN', 'AUT', 'THA', 'JPN', 'TUR', 'ITA', 'IND', 'RUS', 'NOR', 'CZE']`  The method seems to work ok for `nx.Graph`, or at least I've yet to find a counter-example. 
comment
Hi! I don't know if the issue is known and if a fix is planned yet, but make sure "local_reaching_centrality" uses floats. The current development version uses ints and, as a result, it always returns the wrong result.
