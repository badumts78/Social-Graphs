issue
Controlling the in_degree and out_degree of MultiDiGraph#TITLE_END#``` def get_flowchart_nodes_by_type(graph):     connector = []       process = []     decision = []     for node in graph.nodes:         if graph.out_degree(node)>1:             decision.append(node)         elif graph.in_degree(node)==0 or graph.out_degree(node)==0:             connector.append(node)         else:             process.append(node)      return (connector, process, decision) ```  ``` def plot_pydot(graph):     pdot = nx.drawing.nx_pydot.to_pydot(graph)     circle, rect, kite = get_flowchart_nodes_by_type(graph)     for node in pdot.get_nodes():         if node.get_name().strip('"') in kite:             node.set_shape('diamond')         elif node.get_name().strip('"') in circle:             node.set_shape('rect')         elif node.get_name().strip('"') in rect:             node.set_shape('rect')      outpath = os.path.join(__dirname__, 'pydot_out.png')     pdot.write_png(outpath) ``` I am wondering is there any way to handle Degrees of the Graph. Rectangle can take multiple input and produce only one output. Decision will take multiple input and produce only two output. Condition if Decision is having more than 2 outputs than there should be one more decision created with "xyz" name and connecting pending outputs of the decision.  Networkx output using pydot - https://ibb.co/PrzJB46 Third party app output - https://ibb.co/S30Rygm
issue
Export JSON with shapes and links between each nodes#TITLE_END#I am trying to implement the logic where data comes from excel sheet and I add edge from the below list. It checks if it has an edge or not. And finally I export this in JSON. This JSON doesn't defines the proper connection and shapes as I am expecting.  ``` dataList = ['open browser',  'type username',  'type password',  'click on submit button',  'user loged in',  'nan',  'open browser',  'type username',  'type password',  'click on submit button',  'user password is wrong'] ```  ``` G = nx.MultiDiGraph() def get_graph_from(dataList):     for i in range(0, len(dataList)-1):         curr_val = dataList[i]         next_val = dataList[i+1]         if (curr_val=='nan' or next_val=='nan'):              continue         if not G.has_edge(curr_val, next_val):             G.add_edge(curr_val, next_val)     return G ``` When I am trying to export it in JSON using `json_graph.node_link_data(G)` I am getting this as output   ``` {'directed': True,  'multigraph': True,  'graph': {},  'nodes': [{'id': 'open browser'},   {'id': 'type username'},   {'id': 'type password'},   {'id': 'click on submit button'},   {'id': 'user loged in'},   {'id': 'user password is wrong'}],  'links': [{'source': 'open browser', 'target': 'type username', 'key': 0},   {'source': 'type username', 'target': 'type password', 'key': 0},   {'source': 'type password', 'target': 'click on submit button', 'key': 0},   {'source': 'click on submit button', 'target': 'user loged in', 'key': 0},   {'source': 'click on submit button',    'target': 'user password is wrong',    'key': 0}]} ```  I am expecting output like   ``` {     "list": {         "Elements": [             {"id":1, "text":"open browser", "Shape":"Rectangle"},             {"id":2, "text":"type username", "Shape":"Rectangle"},             {"id":3, "text":"type password", "Shape":"Rectangle"},             {"id":4, "text":"click on submit button", "Shape":"Rectangle"},             {"id":5, "text":"user logged in", "Shape":"Decision"},             {"id":6, "text":"user password is wrong", "Shape":"Rectangle"}         ],         "links": [             {"source":"1", "Target":2},             {"source":"2", "Target":3},            {"source":"3", "Target":4},             {"source":"4", "Target":5},            {"source":"4", "Target":6}                      ]     } } ```  If shapes are **given/decided** Above output will help us to draw diagrams outside networkx library. For your information I have tried deciding shape using this snippet.  ``` Elements = [] for i, node in enumerate(G.nodes, 1):     if G.out_degree(node)>1:         Elements.append({"id":i, "text":node, "Shape":"Decision"})     elif G.in_degree(node) == 0 or G.out_degree(node) == 0:         Elements.append({"id":i, "text":node, "Shape":"Rectangle"})     else:         Elements.append({"id":i, "text":node, "Shape":"Rectangle"}) ```   [s1.xlsx](https://github.com/networkx/networkx/files/5010844/s1.xlsx) 
