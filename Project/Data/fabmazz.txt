issue
common_neighbor_centrality throws KeyError in presence of multiple connected components#TITLE_END#I have just tried to run `networkx.algorithms.link_prediction.common_neighbor_centrality` on a graph, but it throws KeyError in the shortest path dictionary. I might be wrong, but from the code it seems the computation assumes that there is one connected component, in my case I have 3.  ### Current Behavior Throws KeyError:  ``` --------------------------------------------------------------------------- KeyError                                  Traceback (most recent call last) <ipython-input-14-d81293677b37> in <module> ----> 1 r_comm = tuple(lp.common_neighbor_centrality(G_cut))  /usr/lib/python3.9/site-packages/networkx/algorithms/link_prediction.py in <genexpr>(.0)      38     if ebunch is None:      39         ebunch = nx.non_edges(G) ---> 40     return ((u, v, func(u, v)) for u, v in ebunch)      41       42   /usr/lib/python3.9/site-packages/networkx/algorithms/link_prediction.py in predict(u, v)     280     def predict(u, v):     281         return alpha * len(list(nx.common_neighbors(G, u, v))) + (1 - alpha) * ( --> 282             G.number_of_nodes() / (len(shortest_path[u][v]) - 1)     283         )     284   KeyError: 169 ```  ### Expected Behavior Give the scores for the missing edges  ### Steps to Reproduce This snippet is sufficient to trigger the error: ```python import networkx as nx import urllib.request as urllib import io import zipfile  url = "http://nrvis.com/download/data/socfb/socfb-Haverford76.zip"  sock = urllib.urlopen(url) s = io.BytesIO(sock.read()) sock.close()  zf = zipfile.ZipFile(s)  mtx = zf.open('socfb-Haverford76.mtx')  G = nx.Graph() for l in mtx:     fields = l.split()     if len(fields) == 2:         G.add_edge(int(fields[0]), int(fields[1]))  import random random.seed(8)  G_cut  = G.copy()   for e in tuple(G_cut.edges):     if random.random() < 0.05:         G_cut.remove_edge(*e)  lp = nx.algorithms.link_prediction r_comm = tuple(lp.common_neighbor_centrality(G_cut)) ```  ### Environment  Python version: 3.9 (also 3.7) NetworkX version: 2.5.1   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
Improve reproducibilty of geometric graphs#TITLE_END#Since on different versions of python `sp.spatial.cKDTree` gives the edge indices in different order, it becomes impossible to reproduce exactly the same graph, even when passing the same random number generator state.  This PR solves the problem by sorting the`edge_indexes` after getting the result from cKDTree.  Closes #4767 
issue
Unable to get the same network from `soft_random_geometric_graph` on different machines#TITLE_END#I'm unable, with version 2.5 of networkx, to get the same graph from `soft_random_geometric_graph` (with same parameters of course, and same seed of random number generator)  A cause of the problem is the fact that `scipy.spatial.cKDTree` doesn't return the edges in the same order. A simple pass of "sorted(...)" solves the probelm  ### Current Behavior The generated graph has different edges on different machines, even with the same seed  ### Expected Behavior The generated graph should have the same edges, given the same seed  ### Steps to Reproduce ``` import numpy as np import networkx as nx  rng = np.random.RandomState() rng.seed(4) N =100 scale = 2 x_pos = np.sqrt(N)*rng.random(N) y_pos = np.sqrt(N)*rng.random(N) # for soft geometric graph generation pos  = {i: (x, y) for i, (x, y) in enumerate(zip(x_pos,y_pos))}  rng = np.random.RandomState() rng.seed(2) G = nx.generators.soft_random_geometric_graph(N,4, pos=pos, seed=rng ) ``` This snippet is sufficient to generate graphs with different edges on different machines, provided that scipy is installed  ### Environment  Python version: 3.8, 3.7 NetworkX version: 2.5  
