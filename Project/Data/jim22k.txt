issue
Allow multiple graphs for `@nx._dispatch`#TITLE_END#A new `graphs` keyword is added. For the case of two graphs named `G` and `H` as the first to arguments in `foo`, the new spelling is  ```python @nx._dispatch(graphs="G,H") def foo(G, H, other_arg, **kwargs):     ... ``` <!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Test dispatching via nx-loopback backend#TITLE_END#The dispatch functionality is used to delegate graph computations to a different backend. Because those backends are not part of NetworkX, testing the dispatching feature was not originally added, relying instead on the other backends (e.g. graphblas-algorithms) to verify the dispatch functionality is working.  This change creates a "loopback" backend where NetworkX dispatches to itself for the sole purpose of exercising the dispatching machinery.  In one incarnation, various tests are augmented to use the LoopbackGraph family and force loopback dispatching to occur as normal usage would (see nx.algorithms.components.tests.test_connected:64).  A second incarnation forces *all* tests to run in dispatch mode but use of a different `_dispatch` decorator. This mode is triggered for all of pytest, so it must be tested by the CI system specifically.
comment
> I have trouble with Rule 2. It seems to assume that every backend has a single backend graph type. And every graph type has a single backend associated with it.   I think @dschult brings up a good point. I was definitely thinking of a 1:1 relationship between graph type and graph library.  I would prefer the behavior to be:  1. If `backend=backend_name` is given then use that backend (and fail if can't) 2. Step through the `backend_priority` entries -- if backend can handle the graph without conversion, call it 3. Step through the `backend_priority` entries -- if backend can handle the graph **_with_** conversion, call it 4. Step through all registered backends (in alphabetical order) -- if any can handle the graph without conversion, call it 5. Step through the `backend_fallback` entries -- if backend can handle the graph **_with_** conversion, call it  This removes the need to lookup a backend based on the graph type. It is deterministic. It provides the user with several ways to specify their preferred backend while minimizing unnecessary graph conversions.  The `backend_priority` specifies both the backend preference as well as authorizes networkx to do graph conversions. The `backend_fallback` is only used as a last resort when conversion is required.  @eriknw Feel free to push back against any of this. You have spent a lot more time thinking about this than I have. But I'm hoping this suggestion feels simple, understandable, and useful.
comment
@eriknw This was always a hack, and you're finding the rough edges.  I was really hoping to not force every backend algorithm to check if the input is `nx.Graph` and convert. However, if we assume that backends have a `core` implementation and a `wrapper` implementation that matches the NetworkX API, then the conversion check and handling would live in the `wrapper` code, keeping the `core` implementation clean. It would give us the ultimate flexibility to correctly handle whatever algorithm-specific arguments affect the conversion.  Now that NetworkX handles multiple graphs (G, H) in the same call, this only gets more complicated.  I vote to throw away the hacks and pass `nx.Graph` directly into the backend implementation layer. For a deprecation policy, we can check if the backend has a `convert_from_nx` method and only call it if it exists. That way backends can "upgrade" by not implementing `convert_from_nx` and instead handling `nx.Graph` directly in the `wrapper` code.  Finally, if we're making this change for `convert_from_nx`, should we go ahead and eliminate `convert_to_nx` and make the `wrapper` layer do the conversion to a NetworkX object if we passed in a NetworkX object? We talked about that during the initial discussions. I was against it then, but it's looking like that might be the better option now. Keeping the conversions fully contained within a single algorithms means that full context is available if a particular algorithm needs one-off logic.
