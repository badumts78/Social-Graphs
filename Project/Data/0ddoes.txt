issue
Add Triad example plot#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Sir, I have included an example of the ```16 Triad Types``` in the Gallery Section. I figured having it in Gallery is better than including in the Documentation under Algorithms. Please let me know if I have to change it. I have included a reference of this Gallery Plot in the documentation as well.
issue
Examples for 7 Functions in Triads.py added solving issue #5498#TITLE_END#Fixes #5498  I have added the examples for 7 Functions in Triads.py file. I manually applied black style to the doc examples as well. I will update the documentation under the same thread. Please let me know if I can improve the examples further. 
issue
DAG Layouts Added solving #5124#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Hi! I created the plots of DAG in different layouts, except for bipartite and multipartite. Please let me know if I need to edit anything here. Also, I am new to testing so I didn't quite get the Contributor Guidelines on how to do the Image Comparisons and Adding Tests. Which file in test folder am I supposed to edit to include tests or for Image Comparisons?
issue
Improve Examples Section of ```set_edge_attributes```#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->   <!--- Tell us what happens instead of the expected behavior --> While looking at the ```set_edge_attributes``` function, it doesn't include an example using multigraphs. As the ```values``` argument is passed different for non-multigraphs and multigraphs, I figured having a small example will show the difference easily.   <!--- Tell us what should happen -->  <!--- Provide a minimal example that reproduces the bug -->  <!--- Please provide details about your local environment --> NetworkX version: 2.6.2  <!--- Add any other context about the problem here, screenshots, etc. --> 
issue
Updated networkx/classes/function.py . Solves Issue #5463#TITLE_END#Fixes #5463
issue
Improving Triads Algorithms Documentation#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion --> There are 7 Functions under Triads.  1. [triadic_census](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.triadic_census.html#networkx.algorithms.triads.triadic_census)(G[, nodelist]) 2. [random_triad](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.random_triad.html#networkx.algorithms.triads.random_triad)(G) 3. [triads_by_type](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.triads_by_type.html#networkx.algorithms.triads.triads_by_type)(G) 4. [triad_type](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.triad_type.html#networkx.algorithms.triads.triad_type)(G) 5. [is_triad](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.is_triad.html#networkx.algorithms.triads.is_triad)(G) 6. [all_triads](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.all_triads.html#networkx.algorithms.triads.all_triads)(G) 7. [all_triplets](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.triads.all_triplets.html#networkx.algorithms.triads.all_triplets)(G)   None of these have any examples included. I will like to include some and also improve the documentation on Triads and its Types.   NetworkX version: 2.6.2
issue
Examples for Centrality Algorithms#TITLE_END#Except for the 4 ```EigenVector``` Centrality Measure Algorithms, there aren't any simple basic Examples for the rest of the **Centrality measures**. I would like to work on some. If alright, can I try to include real datasets analysis in the Examples and put the link to the dataset in the documentation?   
issue
```G.edges(data = True)``` not giving attributes of self loops#TITLE_END#While I was trying to get the edge DataView of the following graph for the Contribution #5474 I saw that the attributes assigned to the self Edge in the Multigraph is not displayed when given  ```G.edges(data = True)```. Is it because it outputs only the ```OutMultiEdgeDataView```(meaning only the out edges?) or is this a defect?  ```python  >>> import networkx as nx >>> G = nx.MultiDiGraph([(0,1), (0,1), (1,0), (2,2), (3, 4), (1,3)]) >>> nx.set_edge_attributes(G, {(0,1,0): {"weight": 20, "cost": 21}, (2,2,4): {"weight": 10, "cost": 3}, (0,1,1): {"cost":7}}) >>> G.edges(data=True) OutMultiEdgeDataView([(0, 1, {'weight': 20, 'cost': 21}), (0, 1, {'cost': 7}), (1, 0, {}), (1, 3, {}), (2, 2, {}), (3, 4, {})])  ```
issue
Sorting of Connected Components for Directed Graphs#TITLE_END#It is not possible to sort the connected_graphs() of a Directed Network as it raises the ```nx.NetworkXNotImplemented``` Error for me. I wanted to plot only the most connected subgraph , however it doesn't allow to sort. Is this normally not implemented for Directed Graphs?  
issue
Issues with ```to_numpy_array``` outputs#TITLE_END#Sir, I tried working on the issue. I am finding a few other issues with the results obtained. I have summarised what I get below:  I found a few issues with ```to_numpy_array``` while I worked on Issue #5255. Attaching the part of the Comment below:   **MultiDiGraph**  In this example I wanted to show the significance of the other arguments : ```multigraph_weight``` and structured array ```dtype```.  ```python >>> G = nx.MultiDiGraph() >>> edges = [(0,1), (0,1), (1,0), (2,2), ("love", "hate"), (1,"love")] >>> G.add_edges_from(edges) [0, 1, 0, 0, 0, 0] >>> nx.to_numpy_array(G, nodelist=[0, 1, 2]) array([[0., 2., 0.],        [1., 0., 0.],        [0., 0., 1.]]) >>>  >>>  >>>  >>> attributes = {(0,1,0): {"weight": 20, "cost": 5}, (2,2,4): {"weight": 10, "cost": 3}, (0,1,1): {"cost":5}} >>> nx.set_edge_attributes(G, attributes) >>>  >>> dtype = np.dtype([("weight", float), ("cost", int)]) >>> A = nx.to_numpy_array(G, nodelist=[0, 1, 2], dtype=dtype, weight=None, multigraph_weight = sum) >>> A["cost"] array([[0, 2, 0],        [1, 0, 0],        [0, 0, 1]]) ```  There are 2 edges between 0 and 1 and that reflects in the Adjacency matrix.  Also document can be edited to include that ```multigraph_weight```  will take values (sum, min , max).   As the dtype is structured Array, according to documentation I gave **None**. But the output is still the previous Adjacency Matrix. It doesn't show the values of **Attribute "Cost"**.    To tackle this issue, I tried other ways. And changed it to just any Attribute name first (here) "cost".  ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight="cost", multigraph_weight = sum) >>> A["cost"] array([[ 0, 10,  0,  0,  0],        [ 1,  0,  0,  1,  0],        [ 0,  0,  1,  0,  0],        [ 0,  0,  0,  0,  1],        [ 0,  0,  0,  0,  0]]) ```  Although it took sum of cost attribute for multiple edges between (0,1), it didn't show the value for (2,2) Self edge. Does this not work for a Self edge?   This output was also seen:  ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight="cost", multigraph_weight = sum) >>> A["cost"] array([[ 0, 10,  0,  0,  0],        [ 1,  0,  0,  1,  0],        [ 0,  0,  1,  0,  0],        [ 0,  0,  0,  0,  1],        [ 0,  0,  0,  0,  0]]) ```  Even if "weight" is accessed, the previous values of "costs" are given. On displaying A :  ```python >>> A array([[( 0.,  0), (10., 10), ( 0.,  0), ( 0.,  0), ( 0.,  0)],        [( 1.,  1), ( 0.,  0), ( 0.,  0), ( 1.,  1), ( 0.,  0)],        [( 0.,  0), ( 0.,  0), ( 1.,  1), ( 0.,  0), ( 0.,  0)],        [( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0), ( 1.,  1)],        [( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0)]],       dtype=[('weight', '<f8'), ('cost', '<i8')]) ```  Both values got assigned with the cost Attribute Value, as weights was given as "cost" at the start. But if the weight is given as a tuple ("weight", "cost"), it gives similar to adjacency Matrix. Both values of the tuple get assigned with the number of edges in between.   ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight= ("weight","cost"), multigraph_weight = sum) >>> A array([[(0., 0), (2., 2), (0., 0), (0., 0), (0., 0)],        [(1., 1), (0., 0), (0., 0), (1., 1), (0., 0)],        [(0., 0), (0., 0), (1., 1), (0., 0), (0., 0)],        [(0., 0), (0., 0), (0., 0), (0., 0), (1., 1)],        [(0., 0), (0., 0), (0., 0), (0., 0), (0., 0)]],       dtype=[('weight', '<f8'), ('cost', '<i8')]) ```  I hope I am using the function right. I checked the code again but I found some of these issues persist.   I noticed that the current example in documentation with the structured ```dtype``` (at the end) is not providing the same output as well.   Can you please guide me on how to proceed forward?  _Originally posted by @0ddoes in https://github.com/networkx/networkx/issues/5255#issuecomment-1086009899_
comment
Sir, wouldn't it be cooler if we could include a link that takes you to an external webpage (maybe nx-guides) containing a jupyter notebook explaining what this function does thoroughly , than include a small example in the same documentation?   In that way probably we can include from Basic multidirected graphs that we define, to real datasets (For eg Political Blogs or Social Networks) on same notebook and show the functionalities on that as well? Like from beginner to advanced kind? 
comment
Understood Sir! I will try to work on a good example as well. Also if the latter issue is opened sometime, I will love to explore it!  Sorry for previous comment. That was a different account , not registered with Outreachy. 
comment
Sir, I tried working on the issue. I am finding a few other issues with the results obtained. I have summarised what I get below:  I tried to make an example from a simple graph and a Multi directed graph to show the difference in usage of arguments.   **Simple Graph:**   ```python >>> G = nx.Graph() >>> edges = [(0,1),(2,2), ("love", "hate"), (1,"love")] >>> G.add_edges_from(edges) >>> nx.to_numpy_array(G, nodelist=[1, "love"]) array([[0., 1.],        [1., 0.]]) >>>  >>>  >>> attrs = {edges[0]: {"weight": 20}, edges[1]: {"weight": 3}} >>> nx.set_edge_attributes(G, attrs) >>> A = nx.to_numpy_array(G, dtype= int, weight = "weight", nonedge = 99) >>> A array([[99, 20, 99, 99, 99],        [20, 99, 99,  1, 99],        [99, 99,  3, 99, 99],        [99,  1, 99, 99,  1],        [99, 99, 99,  1, 99]]) ```  This shows how arguments like ```nodelist```, ```nonedge```, ```dtype```, ```weight```  can be used. In this example the ```dtype``` is not structured as well. On adding more edge attributes and values I get the following :   ```python >>> attrs = {edges[2]: {"cost": 20, "money" : 5000}, edges[3]: {"cost": 3}} >>> nx.set_edge_attributes(G, attrs) >>> A = nx.to_numpy_array(G, dtype= int, weight = "cost") >>> A array([[ 0,  1,  0,  0,  0],        [ 1,  0,  0,  3,  0],        [ 0,  0,  1,  0,  0],        [ 0,  3,  0,  0, 20],        [ 0,  0,  0, 20,  0]]) >>> A = nx.to_numpy_array(G, dtype= int, weight = "money") >>> A array([[   0,    1,    0,    0,    0],        [   1,    0,    0,    1,    0],        [   0,    0,    1,    0,    0],        [   0,    1,    0,    0, 5000],        [   0,    0,    0, 5000,    0]]) ```  Only **Issue** I found was that according to documentation nan values can be assigned but when I tried it gives me the following output. Please let me know if I am doing anything wrong.  ```python >>> A = nx.to_numpy_array(G, dtype= int, weight = "weight", nonedge = float("nan")) >>> A array([[-9223372036854775808,                   20, -9223372036854775808,         -9223372036854775808, -9223372036854775808],        [                  20, -9223372036854775808, -9223372036854775808,                            1, -9223372036854775808],        [-9223372036854775808, -9223372036854775808,                    3,         -9223372036854775808, -9223372036854775808],        [-9223372036854775808,                    1, -9223372036854775808,         -9223372036854775808,                    1],        [-9223372036854775808, -9223372036854775808, -9223372036854775808,                            1, -9223372036854775808]]) ```   **MultiDiGraph**  In this example I wanted to show the significance of the other arguments : ```multigraph_weight``` and structured array ```dtype```.  ```python >>> G = nx.MultiDiGraph() >>> edges = [(0,1), (0,1), (1,0), (2,2), ("love", "hate"), (1,"love")] >>> G.add_edges_from(edges) [0, 1, 0, 0, 0, 0] >>> nx.to_numpy_array(G, nodelist=[0, 1, 2]) array([[0., 2., 0.],        [1., 0., 0.],        [0., 0., 1.]]) >>>  >>>  >>>  >>> attributes = {(0,1,0): {"weight": 20, "cost": 5}, (2,2,4): {"weight": 10, "cost": 3}, (0,1,1): {"cost":5}} >>> nx.set_edge_attributes(G, attributes) >>>  >>> dtype = np.dtype([("weight", float), ("cost", int)]) >>> A = nx.to_numpy_array(G, nodelist=[0, 1, 2], dtype=dtype, weight=None, multigraph_weight = sum) >>> A["cost"] array([[0, 2, 0],        [1, 0, 0],        [0, 0, 1]]) ```  There are 2 edges between 0 and 1 and that reflects in the Adjacency matrix.  Also document can be edited to include that ```multigraph_weight```  will take values (sum, min , max).   As the dtype is structured Array, according to documentation I gave **None**. But the output is still the previous Adjacency Matrix. It doesn't show the values of **Attribute "Cost"**.    To tackle this issue, I tried other ways. And changed it to just any Attribute name first (here) "cost".  ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight="cost", multigraph_weight = sum) >>> A["cost"] array([[ 0, 10,  0,  0,  0],        [ 1,  0,  0,  1,  0],        [ 0,  0,  1,  0,  0],        [ 0,  0,  0,  0,  1],        [ 0,  0,  0,  0,  0]]) ```  Although it took sum of cost attribute for multiple edges between (0,1), it didn't show the value for (2,2) Self edge. Does this not work for a Self edge?   This output was also seen:  ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight="cost", multigraph_weight = sum) >>> A["cost"] array([[ 0, 10,  0,  0,  0],        [ 1,  0,  0,  1,  0],        [ 0,  0,  1,  0,  0],        [ 0,  0,  0,  0,  1],        [ 0,  0,  0,  0,  0]]) ```  Even if "weight" is accessed, the previous values of "costs" are given. On displaying A :  ```python >>> A array([[( 0.,  0), (10., 10), ( 0.,  0), ( 0.,  0), ( 0.,  0)],        [( 1.,  1), ( 0.,  0), ( 0.,  0), ( 1.,  1), ( 0.,  0)],        [( 0.,  0), ( 0.,  0), ( 1.,  1), ( 0.,  0), ( 0.,  0)],        [( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0), ( 1.,  1)],        [( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0), ( 0.,  0)]],       dtype=[('weight', '<f8'), ('cost', '<i8')]) ```  Both values got assigned with the cost Attribute Value, as weights was given as "cost" at the start. But if the weight is given as a tuple ("weight", "cost"), it gives similar to adjacency Matrix. Both values of the tuple get assigned with the number of edges in between.   ```python >>> A = nx.to_numpy_array(G, dtype=dtype, weight= ("weight","cost"), multigraph_weight = sum) >>> A array([[(0., 0), (2., 2), (0., 0), (0., 0), (0., 0)],        [(1., 1), (0., 0), (0., 0), (1., 1), (0., 0)],        [(0., 0), (0., 0), (1., 1), (0., 0), (0., 0)],        [(0., 0), (0., 0), (0., 0), (0., 0), (1., 1)],        [(0., 0), (0., 0), (0., 0), (0., 0), (0., 0)]],       dtype=[('weight', '<f8'), ('cost', '<i8')]) ```  I hope I am using the function right. I checked the code again but I found some of these issues persist.   For the final argument ```order```, I was not able to understand from the documentation (how to create example to differentiate two values).   Can you please guide me on how to proceed forward?
comment
Hey @rossbar , I would like to contribute more examples. Could you please review my comment above? I appear to still face the same issues. The example given in documentation with structured ```dtype``` doesn't give me the same output as well. Please let me know. 
comment
Hi, thanks for pointing that out about ```nan```. I understand the mistake I made. I figured if I passed float("nan") , it will override it. But it doesn't seem the case.   Also I have edited the comment above for the other issues. I hope its alright. 
comment
Hey I would like to contribute into the example gallery if possible. I am Izza and applying for the Outreachy Cohort '22.
comment
According to Complex Network Theory, I don't think there should be double headed arrows for undirected graphs. If given <->, then there would not be any difference between ```nx.Graph()``` and ```nx.DiGraph()``` once arrows = ```True```. Or in other words, it might remove the difference between undirected and bidirectional graphs. Undirected is supposed to be showing connectedness while directed shows the mutual relations. And while studying actual datasets it could prove a problem.   My suggestion is that @dtekinoglu could perhaps work on ```nx.draw()``` such that it recognises that it is undirected and gives a default ```None``` value instead. At present it follows  ```python If `True`, draw arrowheads with FancyArrowPatches (bendable and stylish) ``` Something else I noticed Sir, the documentation is not yet updated for nx.draw? As I see under ```Draw``` tab , there is both ```draw``` and ```draw_networkx```, saying the latter gives a more full-featured drawing. But afaik, the arguments in ```draw_networkx``` can be used in ```draw``` function as of now. So shouldn't they both be merged? Please correct me if I am wrong @dschult 
comment
Sir, I am an Outreachy applicant. Is this issue still open? Can I try to make any updates to the documentation to make it more clear? If so please do guide me in what you expect , as to how I can improve it?
comment
@MridulS Hi, Is this issue still open? And if so can you guide me on how I can improve it?
