issue
Improve _sparse_fruchterman_reingold with L-BFGS#TITLE_END## Pull Request  Hello, NetworkX developers.  I'm Hiroki Hamaguchi from the University of Tokyo, Japan. We want to contribute to NetworkX by improving the `_sparse_fruchterman_reingold` function, a.k.a. `spring_layout`.  We know that this function is one of NetworkX's core features, so we are very careful about the changes and willing to receive any feedback to refine our approach. We hope that our proposal will benefit the NetworkX community.  ## Abstract  The **Fruchterman--Reingold (FR) model** is a framework that assumes both attractive and repulsive forces act between vertices. `nx.draw` uses this model and simulates this force system to perform graph drawing. Here, `_sparse_fruchterman_reingold` is one of the key internal functions called when **the number of vertices exceeds 500**.  To generate faster and better layouts using the FR force model, we aim to **modify this function** by adopting a different approach from the traditional force-directed method. Specifically, we utilize **SciPy's L-BFGS method** to optimize the layout, similar to `nx.kamada_kawai_layout`.  We can broadly classify our proposed method as an **energy-based algorithm**, but it may be more intuitive to interpret the approach as introducing a kind of momentum into the motion simulation and thus achieving a better layout. Please note that our proposal does not introduce a new model; **the conventional interpretation of the FR model works for most cases**.  This method is based on the research by Hosobe, H. [^hosobe] and our research paper [^our]. Our paper mainly discusses the initial placement with this L-BFGS approach, but this L-BFGS's approach itself is also discussed in detail. We can update our paper to explain our proposal more clearly if necessary.  ### Key Contribution  Our proposed method can usually achieve better visualization with faster computation. The visualization result is shown in the figure. (The blue `FR` means the current `nx.spring_layout`, and the orange `FR (L-BFGS)` means the our proposed method.)  $n \approx 500$ and 50 iterations: ![graphs_500_50](https://github.com/user-attachments/assets/17691e8f-2b11-4989-ab63-6f3aabd998b6)  $n \approx 600$ and 200 iterations: ![graphs_600_200](https://github.com/user-attachments/assets/3cc9d5ac-fa30-4ac6-92c2-5dbd3b7d9bb3)  ### Other Improvements (or Side Effects of Our Proposal?)  The output of our proposed method is theoretically equivalent to the output of the existing method when the graph $G$ is connected and has positive weights. However, the output differs when the graph is not connected or has negative weights due to the current implementation's **ill-defined** extension of the FR algorithm in [^FR].  By **ill-defined**, we mean that the corresponding optimization problem can be unbounded, leading to arbitrary results. This is why our proposed method cannot perfectly reproduce the existing method.  We used the current `nx.spring_layout` in the figure below. The three graphs on the left show the results with the number of iterations set to 50, 500, and 5000, respectively. The rightmost graph contains negative edges.  ![unconnected_and_negative_FR](https://github.com/user-attachments/assets/5ad0aa1f-7ed8-41b4-82c1-0ae2a0e2fa42)  As the number of iterations increases, the graphs blow away and become unreadable. The same issue arises in the rightmost graph. This is because the optimization problem behind the FR model is ill-defined in these cases, and thus we cannot reproduce the results by the optimization method.  Our proposed method introduces additional forces for each connected component and uses the absolute values of edge weights, preventing such problems. This approach often produces better results, which may not completely match the existing method. This is a side effect of our proposed method, which can be seen as either an advantage or a disadvantage.  ![unconnected_and_negative_L-BFGS](https://github.com/user-attachments/assets/a70d2af7-c862-4c59-83dd-1dababcf2164)  ## Algorithm  In this section, we describe our proposed algorithm. We wrote this content in our research paper [^our], Section 8.3.  ![algorithm](https://github.com/user-attachments/assets/9416405e-7ecf-4e46-b309-3e562bd29c32)  ## Implementation  Please refer to the diff in the pull request for the implementation details. Here are a few additional notes:  * We used batch processing to improve computational efficiency. The batch size is 500. As far as we tested, even if we increase the batch size more, the efficiency does not improve or sometimes decreases. * We set `method="auto"` as the default in `nx.spring_layout` because energy-based approaches like ours are relatively rare for the FR force model. We don't want to confuse users. * Temporary variables such as `distance2` and `Aid` improve computational speed. Although this may make the code look a bit redundant, it was a deliberate trade-off to enhance performance. * As discussed later, defining the additional force is one of the most challenging problems, not due to mathematical difficulty but rather the philosophical challenges of keeping the implementation concise and what aesthetic principles to base the design on. After various trials, errors, and considerations, we reached the current implementation.  ## Evaluation  We evaluated our proposed method. The code is available at [here](https://github.com/HirokiHamaguchi/Initial_Placement_for_Fruchterman-Reingold_Force_Model_with_Coordinate_Newton_Direction/blob/main/app/test.ipynb).  ### NetworkX Graphs  We evaluated our method on various graphs generated by NetworkX with different numbers of vertices: 10, 50, 500, and 600. We set the number of iterations to 50 or 200. (Note that `nx.kamada_kawai_layout` does not allow specifying the number of iterations.)  ![graphs_10_50](https://github.com/user-attachments/assets/58b3f93d-bb41-46af-83cd-212990cd4960) ![graphs_50_50](https://github.com/user-attachments/assets/4b51958d-96cd-431d-9ec4-3d21f5b6cb76) ![graphs_500_50](https://github.com/user-attachments/assets/17691e8f-2b11-4989-ab63-6f3aabd998b6) ![graphs_600_200](https://github.com/user-attachments/assets/3cc9d5ac-fa30-4ac6-92c2-5dbd3b7d9bb3)  From these experiments, we can see that our proposed method (orange, `FR (L-BFGS)`) can, in most cases, achieve better visualization with faster computation compared to the existing method (blue, `FR`).  For small graphs with around 10 vertices, the overhead of the `L-BFGS` method can make it slightly slower, but as the number of vertices increases, this overhead becomes negligible, or our method can even outperform the existing one due to the implementation technique. Since `nx.spring_layout` will use our approach only when the number of vertices exceeds 500 by default, we believe this trade-off is acceptable.  ### NetworkX Layouts with Different Methods  We also compared our method with `nx.arf_layout` and `nx.forceatlas2_layout`. Although these methods do not directly use the FR force model, we think that `FR (L-BFGS)` provides better visualization.  $n \approx 50$ and 100 iterations: ![arf_forceatlas_50_100](https://github.com/user-attachments/assets/140c3696-9a6e-437b-a552-1f69df493a51)  ### Graphs from SuiteSparse Matrix Collection  We tested our method on large-scale, real-world graphs from the SuiteSparse Matrix Collection. The superior performance of our method is evident in these cases as well.  200 iterations: ![ssgetpy_17758_200](https://github.com/user-attachments/assets/c0f35f74-9f87-4983-9510-c8c583e936b4)  For comparision, we listed some of the optimal layouts as follows.  ||jagmesh1|1138_bus|dwt_1005|dwt_2680|3elt|USPowerGrid| |-|-|-|-|-|-|-| | optimal layout  | ![jagmesh1](https://arxiv.org/html/2412.20317v2/extracted/6103965/individual/vis/opt_jagmesh1.png)  | ![1138_bus](https://arxiv.org/html/2412.20317v2/extracted/6103965/individual/vis/opt_1138_bus.png)  | ![dwt_1005](https://arxiv.org/html/2412.20317v2/extracted/6103965/individual/vis/opt_dwt_1005.png)  | ![dwt_2680](https://arxiv.org/html/2412.20317v2/extracted/6103965/individual/vis/opt_dwt_2680.png)  | ![3elt](https://arxiv.org/html/2412.20317v2/extracted/6103965/individual/vis/opt_3elt.png)  | ![USPowerGrid](http://yifanhu.net/GALLERY/GRAPHS/GIF_SMALL/Pajek@USpowerGrid.gif) |  Since the problem is a nonconvex optimization problem, it is easy to fall into the local optimum solutions, especially in cases such as `dwt_1005`, but depending on the seed, L-BFGS can obtain results close to those of optimal layout.  ### Special Cases  We confirmed that our method works correctly in special cases.  #### Unconnected Graphs  ![separated_100](https://github.com/user-attachments/assets/40bafef9-9035-4b73-9364-db4e6b619e7f)  #### Very Large Graphs  Although we do not provide specific output results here, we confirmed that our method successfully executed on a cycle graph with 100,000 vertices without causing kernel crashes.  We estimate the necessary memory size for the optimization as follows.  1. If we compute layout for a graph with 100'000 vertices for 100 iterations, it will takes about 55.5 hours with our laptop. (`(dim*|V|^2*iterations)/(computational speed per second) = (2*1e5^2*100)/1e7 = 200'000 seconds = 55.5 hours`. This method of estimation is broadly correct for smaller graphs.) Approximately this size would be the maximum size users would want to calculate. 2. We used batch processing with a batch size of 500, i,e., the size of `delta` in the `_sparse_fruchterman_reingold` is $500 \times 100000 \times 2$ when the number of vertices is 100,000 and `dim=2`. 3. `delta`'s data type is `np.float64`, which requires 8 bytes. 4. The memory size is $500 \times 100000 \times 2 \times 8 \approx 0.74$ GB. 5. In most modern laptops or runtime environments, this memory size is not a problem.  #### 3D Graphs  We confirmed that the method works correctly for graphs with `dim=3`.  ![3d](https://github.com/user-attachments/assets/0834873c-b2c4-4e08-bbae-0b70338c2c1b)  #### `fixed` Parameter  Our method also works correctly when the `fixed` and `pos` parameters are specified. The following figure shows the output for a cycle graph with four vertices specified as `fixed`.  ![fixed](https://github.com/user-attachments/assets/719c8a79-0fae-468d-98fb-c742a0eae385)  ## Discussion  We have demonstrated that our proposed method can, in most cases, achieve better visualization with faster computation compared to the existing method.  As far as we anticipate, there are few major inconveniences that users will experience due to this change. If we must point out one, when increasing the number of nodes stepwise from 100 to 1000 and drawing a graph that includes negative edge weights, discontinuities may occur at 500 with `method="auto"`. How to balance such corner cases against improvements in most situations is a matter of values. We personally think it's not a problem, while we would like to follow the community's intentions.  In general, the most well-known algorithm of the FR force model for large-scale graphs is the multi-level approach, such as [Graphviz's sfdp](https://graphviz.org/docs/layouts/sfdp/). Instead of our approach, we could have implemented this in NetworkX.  However, a complex implementation is not necessarily the best choice for a lightweight library like NetworkX. Furthermore, it is implemented in Python, a language known for its relatively slow execution time.  We believe leveraging SciPy's powerful scientific computing capabilities is a good choice in this situation, and it aligns well with NetworkX's [Mission and Values](https://networkx.org/documentation/stable/developer/values.html#mission-and-values).  We hope our proposal will benefit the NetworkX community.  Thank you for your attention.  [^hosobe]: [Hosobe, Hiroshi. "Numerical optimization-based graph drawing revisited." In 2012 IEEE Pacific Visualization Symposium, pp. 81-88. IEEE, 2012.](https://ieeexplore.ieee.org/iel5/6178307/6183555/06183577.pdf)  [^our]: [Hamaguchi, Hiroki, Naoki Marumo, and Akiko Takeda. "Initial Placement for Fruchterman--Reingold Force Model With Coordinate Newton Direction." arXiv preprint arXiv:2412.20317 (2024).](https://arxiv.org/abs/2412.20317)  [^FR]: [Fruchterman, Thomas MJ, and Edward M. Reingold. "Graph drawing by force-directed placement." Software: Practice and experience 21, no. 11 (1991): 1129-1164.](http://dx.doi.org/10.1002/spe.4380211102) 
issue
Add a new gallery spring layout#TITLE_END## Add a new gallery spring_layout  Dear NetworkX maintainers,  I am Hiroki Hamaguchi, a contributor to NetworkX and the author of [this previous pull request](https://github.com/networkx/networkx/pull/7889).  As mentioned in that PR, we would like to add a new gallery example illustrating the differences among algorithms for the spring layout. Please refer to the commit for further details. We will add the link to this gallery in the doc of `spring_layout` once the stable link is determined.  In particular, this gallery includes a description of the `sfdp` algorithm from GraphViz. As you know, this algorithm requires the additional installation of GraphViz. However, it often produces the fastest results among the available layout algorithms.  We hope that this gallery will serve as a useful reference for users when choosing an appropriate layout algorithm.  Below are screenshots and the image generated by `make html`:  ![new_gallery1](https://github.com/user-attachments/assets/8dc9748d-2161-4503-b6e9-955ac26888a6)  ![new_gallery2](https://github.com/user-attachments/assets/efda289e-3adf-47eb-8daa-e781591fbcdb)  ![new_gallery3](https://github.com/user-attachments/assets/bdfae9b6-d292-42f8-90c9-c2d0d09786d3)  We would like to ask for your review of this PR. If you have any questions or concerns, please ask us.  Thank you very much for your time and consideration. 
issue
fix bug of _sparse_fruchterman_reingold and remove try/except idiom#TITLE_END## Fix bug in _sparse_fruchterman_reingold  Dear NetworkX maintainers,  I am Hiroki Hamaguchi, a contributor to NetworkX and the author of [this previous pull request](https://github.com/networkx/networkx/pull/7889).  I sincerely apologize, but I have discovered a bug introduced in that PR. Specifically, when `method="auto"` is specified, the `nx.spring_layout` function does not use the new `_energy_fruchterman_reingold` function as intended.  The fix is trivial, and I would appreciate it if you could kindly review and merge the proposed correction.  Thank you very much for your time and consideration.  ---  **Added based on discussion (details in comments below)** I believe the try/except block [using ValueError as a signal to try a different branch of code] is unnecessary. A ValueError can occur in the following situations:  pos is a NumPy array and if pos == None is evaluated (Raises: ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all())  fixed is a NumPy array and if fixed == None is evaluated (Same error as above)  dim is set to -1, leading to calls like np.random.random((nnodes, dim)) or np.zeros(dim) (Raises: ValueError: negative dimensions are not allowed)  However, the first two issues are already addressed in the current code using if pos is None and if fixed is None, so the try/except block is redundant. For the third case, this ValueError is raised in the current version of NetworkX, so it is not related to the try/except block.  ---  Based on this, I fixed the bug [about "method" keyword] and cleaned up the code as suggested in the current PR.  I also tested the code with the following configurations and confirmed it works successfully:  (Please refer to [here](https://github.com/HirokiHamaguchi/Initial_Placement_for_Fruchterman-Reingold_Force_Model_with_Coordinate_Newton_Direction/blob/474bee4702e2d2a21f1b015ecc0d86cae11fcf63/app/test_for_issue.ipynb) for the results)  1. Different `method` values:     * `"auto"` (len(G)=499 and 500)    * `"energy"`    * `"force"`  2. Providing an initial layout via the `pos` argument  3. Fixing certain nodes using the `fixed` argument  4. Changing layout dimensionality with the `dim` argument:     * A 3D layout using `dim=3`    * An invalid layout with `dim=-1` to confirm error handling 
comment
Thanks for the mention.  Although I’ve been working mainly on a different approach of force-directed layouts, I wasn’t aware of this. But I have indeed observed the kind of 'vibrational' like effects being discussed here, and it makes intuitive sense that this parameter would influence convergence.  As far as I can tell, neither the [GraphViz implementation](https://gitlab.com/graphviz/graphviz/-/blob/main/lib/sfdpgen/spring_electrical.c) nor the original [Fruchterman-Reingold paper](https://onlinelibrary.wiley.com/doi/epdf/10.1002/spe.4380211102) describe such a threshold adjustment, so this seems to be a rather ad hoc solution. I haven’t come across a similar treatment elsewhere either.  While I can’t look into this immediately, I find the phenomenon quite interesting and plan to run some experiments myself in the next few days.
comment
# Reply  Hello, I have looked into this issue and would like to share my thoughts below.  ## Summary  * In general, the presence of oscillation is not necessarily a negative phenomenon. * In specific cases involving certain values of the parameter $k$ and the edge weights $A$, the bug-like code can have a significant negative impact. However, such cases are quite limited. * I *slightly* recommend changing `np.where(length < 0.01, 0.1, length)` to `np.where(length < 0.01, 0.01, length)`, as it generally causes no harm and improves readability. * However, keeping the code as-is does not introduce critical issues either, so I would like to leave the decision to the maintainers of NetworkX.  ## General Remarks on Oscillation  I agree with Rudyarthur’s statement that "undamped spring systems which I think is inevitable."  Such oscillations may even help escape from local optima. Therefore, oscillations themselves are not inherently bad; rather, they are part of the intended behavior.  This kind of oscillation (vibration) behavior has been discussed especially in the context of [Simulated Annealing](https://www.sciencedirect.com/topics/social-sciences/simulated-annealing). Simulated Annealing is a probabilistic optimization algorithm that searches for a good solution by sometimes accepting worse solutions to escape local minima. (Although the present case is somewhat special and not entirely analogous, but similar. The oscillation helps escape from local optima.)  Regarding temperature schedules, it's also true that many non-linear schedules have been proposed in SA. In practice, exponential temperature schedules work well. While I am not very familiar with the "quadratic schedule," such approaches do exist.  This kind of behavior was also discussed in [the original FR layout paper](https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380211102):  > Primarily, we compared a steady decrease in temperature with a combination of quenching and simmering: the first phase starts at a high temperature and cools steadily and rapidly, and the second is at a constant low temperature. The results from the latter schedule were better and required fewer iterations.  Still, I won't discuss this matter in depth here. For now, I just want to emphasize that oscillation is not inherently problematic.  ## The Animation  I created an animation based on the code shared by Rudyarthur. (Thank you, Rudyarthur!)  Note that I modified the following part of the code:  ```python length = np.where(length < XXX, YYY, length) ```  Originally, the `XXX` was a variable. In this animation, I set `XXX` to `0.01` and regarded `YYY` as a variable to compare between `0.1` and `0.01`, as mentioned in the initial comment.  Also, I modified the following line:  ```python t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1])) * 0.01 ```  Original NetworkX's code uses a coefficient of `0.1`, so I corrected it accordingly. This value also significantly influences the results.  The resulting animation is as follows. In this case, there is almost no visible difference.  ![desargues](https://github.com/user-attachments/assets/9a2ed55c-80bd-4bb6-b709-cda47a8e069d)  This suggests that the impact of the bug-like code is negligible in this situation.  ## Cases Where Layout Quality Degrades  In more extreme examples—such as when nearly all `length` values fall below 0.01—the effect becomes more apparent. Here's one example:  ```python n = 10 A = np.zeros((n, n)) for i in range(n):     A[i][(i + 1) % n] = 1e-3  G = nx.from_numpy_array(A)  k = 1e-2 ```  Using this setup, I compared both versions. Then, the performance of the current version (0.1) is much worse than fixed version(0.01).  ![circle](https://github.com/user-attachments/assets/4fefdd41-3925-42cb-9942-9a5f0d574a2d)  I also tested with random seeds from 0 to 9. With the modified value `0.01`, 6 out of 10 seeds produced accurate circular layouts, whereas with the original value `0.1`, only 1 out of 10 did.  This suggests that using `0.1` can degrade layout quality in such edge cases.  ![0.001_0](https://github.com/user-attachments/assets/a9c36673-d0b3-4ef0-b0c0-9433c033bd20) (With edge weights set to 1e-3)  However, if the edge weights are reduced further, both versions begin to fail. This suggests that the failure is not due to the specific choice between `0.1` and `0.01` but rather due to the very act of clipping itself.  ![1e-05_0](https://github.com/user-attachments/assets/2339524c-d79e-4e6b-84c3-22da01773160) (With edge weights set to 1e-5)  To avoid this, one could eliminate clipping—but this would lead to numerical instability, which is undesirable.  ## General Case Observations  As mentioned above, since `length < 0.01` rarely occurs in typical graphs, the change has little to no effect in most cases.  Here are the test results for graphs with uniform edge weights of 1 and default values of $k$. The code is [here](https://github.com/HirokiHamaguchi/Initial_Placement_for_Fruchterman-Reingold_Force_Model_with_Coordinate_Newton_Direction/blob/main/app/issue8113/test.ipynb).  ---  ![graphs_10](https://github.com/user-attachments/assets/f1d8b2c5-dfc6-4abb-afef-6089cc27926e)  (Graphs with approximately 10 nodes)  ---  ![graphs_50](https://github.com/user-attachments/assets/b0eef1d7-fc4d-40f1-8679-5f6671e0e23c) (Graphs with approximately 50 nodes)  ---  ![graphs_300](https://github.com/user-attachments/assets/77b3a2e1-ef5c-4444-8b65-c2ad0ef74c7e) (Graphs with approximately 300 nodes)  ---  According to [output logs](https://github.com/HirokiHamaguchi/Initial_Placement_for_Fruchterman-Reingold_Force_Model_with_Coordinate_Newton_Direction/blob/main/app/issue8113/test.ipynb), even in graphs with around 300 nodes, the number of nodes with `length < 0.01` never exceeded 28. In most graphs and most iterations, all `length` values exceeded 0.01, meaning clipping did not occur at all.  ## Conclusion  To reiterate the main points:  * Oscillations are not inherently problematic—in some contexts, they are beneficial. * In certain extreme configurations of $k$ and edge weights $A$, layout quality may degrade, but these cases are rare. * I *slightly* recommend changing `np.where(length < 0.01, 0.1, length)` to `np.where(length < 0.01, 0.01, length)` since it generally causes no harm and improves clarity. * However, keeping the current code is also acceptable. I would like to leave the final decision to the NetworkX maintainers.  Thank you.
