issue
add option "all_edges" to remove_edge, resolves #1349#TITLE_END#I have add option `all_edges` as was mentioned in the discussion of #1349 in this PR.  I took the liberty of adding a "5-tuple" `(u, v, key, data, all_edges)`, where the last element of the tuple determines whether the deletion of edges between u and v is exhaustive. I think this is the best way to preserve backward-compatibility.  Looking forward to your comments. Thanks. 
issue
add option "escape_backslashes" to write_dot, resolves #1348#TITLE_END#I have this PR made according to my own understanding on #1348. Looking forward to your comments.  P.S. I'm very interested in GSoC 2015. And I read that it's ok to introduce myself in my first PR, so here it goes. I'm an CS undergraduate from China and will be graduating this summer of 2015. I have been using Python for 4 years (from 2.6 to 3.4). While this is my first PR on GitHub, I have previously done some collaboration work with the good people of GNU Wget (http://git.savannah.gnu.org/cgit/wget.git/commit/?id=8b833). You can also see other works I have done on my GitHub profile. 
comment
I have tested the following code with my version of networkx  ``` python G = NX.Graph() G.add_node('A\A') NX.write_dot(G, 'graph.dot', escape_backslashes=True) ```  The output is following:  ``` strict graph  {         "A\\A"; } ```  And about  ``` python G = NX.Graph() G.add_node('A"A') NX.write_dot(G, 'graph.dot') ```  It outputs the following under pygraphviz 1.3rc2  ``` strict digraph  {     "A\"A"; } ``` 
comment
I agree that `remove_all_edges(u=None, v=None)` seems better.  Also, maybe the solution provided by @hagberg will have performance issue when there are a lot of edges to remove? Because it basically removes them one by one, instead of clearing the dict object once and for all (by calling internal C implementation which is a lot more faster). 
comment
I feel OK with current `remove_edge` method.  Firstly, you can delete a specific edge by filling the `key` parameter if you want. And if you look at `add_edge`, you'll find out that every edge defined without a key will be given a numeric key in an incremental manner, i.e. you can totally remove a specific edge.  Secondly, there are certain use cases e.g. when we do not care which edge is deleted (for example, the edges are identical). So we should, IMHO, leave `remove_edge` be. 
comment
Hi, @ysitu. The Python documentation for `dict.popitem` (version 3.4) explicitly states that "popitem() is **useful** to destructively iterate over a dictionary, as often used in set algorithms". So maybe it is at least **not discouraged** to have nondeterministic results when programming in Python.  I know that there are libraries which have their own design guidelines. But according to my observation, it seems that networkx does follow Python's style.  So IMHO, as long as this behavior is documented in `remove_edge` (which already is), we should leave it be to avoid any possible regressions or backward-incompatibility. 
comment
I am no expert of Mac OS X but probably you are missing some environment variables. Or maybe you have multiple Python installations on your system, so you need to specify the one with NetworkX installed for IntellijIDEA or other IDEs.  And I don't know how you installed networkx and decorator. I'd suggest that you install only networkx by `pip` (i.e. `pip install networkx`) and let `pip` resolve the dependencies of networkx on its own.  P.S. JetBrains has developed a Python-IDE named PyCharm, maybe you should check it out and see if that solves your problem. 
