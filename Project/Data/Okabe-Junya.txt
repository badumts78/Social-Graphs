comment
Hi!  Here is the solution using [nx.connected_components(G)](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.connected_components.html#networkx.algorithms.components.connected_components).  To create a simple sample, we will create a sample with the following Python code.   ```python import networkx as nx from random import randint  G = nx.Graph()  nodes = [i for i in range(10)] edges = [(randint(0, 10), randint(0, 10)) for _ in range(15)]  G.add_nodes_from(nodes) G.add_edges_from(edges) ```  This code generates a random undirected graph with 10 nodes and 15 edges. If you use  [nx.connected_components(G)](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.connected_components.html#networkx.algorithms.components.connected_components) for this graph,   ```python for components in nx.connected_components(G):     print(components)  ```  you get the following result.  ``` >>> {0, 2, 4, 5, 6, 7, 8, 10} {1} {9, 3} ```  Thus, you can create a function like the following  ```python def find_cycles_n(G, n):     cycles = []     for components in nx.connected_components(G):         if len(components) == n:             cycles.append(components)     return cycles ``` 
