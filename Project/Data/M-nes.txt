issue
Specifying number of shortest_wanted and adding condition on edges attribute#TITLE_END#Hello,  I am working with a **heavy graph** ```G``` that contains subway stations as nodes and paths between stations as edges. Each edges have two possible attributes: - ```'walk'``` or ```'subway'``` correspond to the time needed to go from a stop to the other either by walking (when taking the subway is impossible) or by riding the subway. - ```'time'``` is the time needed to go from a stop to the other without considering the transport type (so for each edge, ```'time'``` = ```'walk'``` or ```'time'``` = ```'subway'```). This is what I use as ```weight``` when I compute the shortest path between two nodes so it consider the trip's total time.  <details close><summary><code> Here is a simplified example of G </code></summary><p>  ``` G = nx.Graph() G.add_nodes_from(['A', 'B', 'C', 'D', 'E', 'F']) G.add_edges_from([('A', 'B', {'walk': 3, 'time': 3}), ('A', 'C', {'subway': 4, 'time': 4}), ('A', 'D', {'walk': 3, 'time': 3}),                    ('C', 'E', {'walk': 3, 'time': 3}), ('D', 'E', {'walk': 3, 'time': 3}), ('B', 'F', {'walk': 3, 'time': 3}),                    ('D', 'F', {'subway': 4, 'time': 4}), ('E', 'F', {'walk': 3, 'time': 3})]) nx.draw(G, with_labels=True, font_color='white')  sp = nx.shortest_path(G, 'A', 'F', weight='time') ```  </p></details>  **I have two questions in total:**  - **Is there a way to get, say, the 3 shorter paths between a specific set of nodes?** As an example, let's consider the three shorter paths between ```'A'``` and ```'F'```: ```A -> B -> F```, ```A -> D -> F``` and ```A -> D -> E -> F```. As I said I am working with a huge Graph and I compute up to millions of ```shortest_path```. I know I could use ```all_shortest_paths``` and select the ones that interest me but that would take too much time... Is there some options to the ```shortest_path``` algorithm that would allow to specify how many paths to return?  - **Is there a way to put a condition on the number of edges to get?** More specifically, in this example, I would like to get the shortest path (weighted on ```time```) that has the less number of ```walk``` attribute to the edges (here it would be ```A -> D -> F```). And again, as I am working with tons of paths, using ```all_shortest_paths``` and working on that would be too time consuming...  Any help would be greatly appreciated, I found nothing that could help me with my issues... 
issue
Issues saving a Graph as a Shapefile#TITLE_END#Hello,  I am working with GTFS files and OSMNX to generate a Graph (called G2) containing roads of the Paris region in France.  I found a very interesting tutorial [here](http://kuanbutts.com/2018/12/24/peartree-with-walk-network/) that I followed and allows to generate said Graph and I then calculate the shortest path between two points with: ``` nx.shortest_path_length(G2, source = source, target = target, weight = None, method = 'dijkstra') ``` I have an issue with how big the Graph is. As I am working with big data, I find myself having to restart the kernel from time to time and have to re-run everything which is quite restrictive as the generation of G2 takes me about <i> 6-7 hours </i> each time.  So I would like to save G2 as a shapefile so I'll just have to read it with nx next time my notebook bugs. However nx.write_shp raised an error:  ``` nx.write_shp(G2, '/Users/mnes/Desktop/Shapefile/') ``` <details closed><summary><code>TypeError</code></summary><p>  ``` --------------------------------------------------------------------------- TypeError                                 Traceback (most recent call last) <ipython-input-101-764a76abb78d> in <module> ----> 1 nx.write_shp(G2, '/Users/mnes/Desktop/Shapefile/G2.shp')  ~/anaconda3/envs/inox/lib/python3.6/site-packages/networkx/readwrite/nx_shp.py in write_shp(G, outdir)     304     for n in G:     305         data = G.nodes[n] --> 306         g = netgeometry(n, data)     307         attributes, nodes = create_attributes(data, node_fields, nodes)     308         create_feature(g, nodes, attributes)  ~/anaconda3/envs/inox/lib/python3.6/site-packages/networkx/readwrite/nx_shp.py in netgeometry(key, data)     227         elif 'Wkt' in data:     228             geom = ogr.CreateGeometryFromWkt(data['Wkt']) --> 229         elif type(key[0]).__name__ == 'tuple':  # edge keys are packed tuples     230             geom = ogr.Geometry(ogr.wkbLineString)     231             _from, _to = key[0], key[1]  TypeError: 'int' object is not subscriptable ```  </p></details>  ---  Bellow are prints that could maybe help you further: <details closed><summary><code>G2.graph</code></summary><p>  ``` {'name': 'unnamed',  'crs': '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs',  'simplified': True,  'streets_per_node': {272629764: 3,   1933574168: 1,   371195933: 4,   6587154464: 3,   274726948: 4,   1933574180: 1,   274726950: 4,   274726951: 3,   1933574184: 3,   1933574189: 3,   1933574191: 3,   1933574192: 3,   1933574200: 3,   1933574201: 1,   1933574203: 3,   1933574207: 3,   1933574208: 1,   1583349835: 3,   2585788512: 4,   2780823653: 3,   2780823656: 1,   2585788524: 1,   2585788525: 3,   2585788526: 3,   1583349880: 3,   3340763260: 3,   2585788543: 1,   3340763263: 1,   1583349890: 3,   520093828: 4,   2585788548: 1,   2585788550: 3,   2585788551: 1,   2585788552: 3,   2585788549: 1,   274727050: 4,   499122309: 3,   2585788559: 3,   499122321: 3,   499122325: 1,   520093848: 4,   499122329: 3,   499122331: 1,   499122335: 1,   5995757736: 3,   3307208874: 3,   3307208875: 3,   3307208880: 3,   3307208882: 3,   3307208884: 3,   3307208885: 3,   5995757749: 3,   3307208890: 3,   5995757754: 3,   3307208893: 3,   3307208895: 3,   3307208896: 3,   5995757760: 3,   3307208899: 3,   5995757763: 3,   3307208911: 3,   3307208913: 3,   3307208916: 3,   3307208918: 3,   3307208923: 3,   3307208924: 3,   1583349980: 3,   3307208926: 3,   1583349983: 3,   773849313: 4,   5163188457: 3,   3307208938: 4,   3307208941: 3,   1755316464: 4,   1755316466: 3,   3307208950: 3,   1583350009: 1,   213909753: 4,   1231028483: 3,   2789212422: 1,   274727184: 4,   1952448806: 3,   5163188527: 3,   5163188530: 3,   ...}} ```  </p></details>  The nodes have attributes I would like to also save in the shapefile: <details closed><summary><code>print(list(G2.nodes(data=True))[0])</code></summary><p>  ``` (272629764, {'y': 48.8949291, 'x': 2.2500055, 'osmid': 272629764, 'boarding_cost': 0}) ```  </p></details> 
issue
Troubles importing shapefiles and working with them#TITLE_END#Hello,  ## Context I am currently working on a project for which I need to import a road network in .shp format and then calculate the shortest path between two points of my domain.  I first started working with osmnx where I got my domain edges and nodes and followed the tutorial that was given here : https://automating-gis-processes.github.io/2018/notebooks/L6/network-analysis.html  However, it troubles me to have to download the network each time I run my script (which will be used frequently) so instead, I saved the edges.shp and nodes.shp and would like to work with them using networkx.  ## Problem Someone posted their method on importing their shapefiles here : https://gis.stackexchange.com/questions/227909/from-shapefile-to-python-networkx  I first tried that script on a small portion of my domain and it worked wonderfully. I had my nodes and edges where they should have been. I then tried it on a bigger part of the domain and an error was found.  <details open><summary><code>Script I used</code></summary><p>  ``` G   = nx.read_shp('/Users/im/Desktop/temp/test_map.shp')  #Importing the edges.shp pos = {k: v for k,v in enumerate(G.nodes())}  X = nx.Graph() #Empty graph X.add_nodes_from(pos.keys()) #Add nodes preserving coordinates l = [set(x) for x in G.edges()] #To speed things up in case of large objects edg = [tuple(k for k,v in pos.items() if v in sl) for sl in l] #Map the G.edges start and endpoints onto pos      fig, ax = plt.subplots(figsize=(15,10))  nx.draw_networkx_nodes(X, pos, node_size=50, node_color='skyblue') X.add_edges_from(edg) nx.draw_networkx_edges(X, pos) #plt.xlim(2.4625, 2.4765) #plt.ylim(48.775, 48.7817) plt.xlabel('X [m]') plt.ylabel('Y [m]') plt.title('From shapefiles to NetworkX') ``` </p></details>  ### And this is the error I get <details><summary><code>Error message</code></summary><p>  ``` NetworkXError                             Traceback (most recent call last) <ipython-input-10-8e4cfd733afa> in <module>       1 fig, ax = plt.subplots(figsize=(15,10))       2 nx.draw_networkx_nodes(X, pos, node_size=50, node_color='skyblue') ----> 3 X.add_edges_from(edge)       4 nx.draw_networkx_edges(X, pos, edge_color='b')       5   ~/anaconda3/lib/python3.6/site-packages/networkx/classes/graph.py in add_edges_from(self, ebunch_to_add, **attr)     967             else:     968                 raise NetworkXError( --> 969                     "Edge tuple %s must be a 2-tuple or 3-tuple." % (e,))     970             if u not in self._node:     971                 self._adj[u] = self.adjlist_inner_dict_factory()  NetworkXError: Edge tuple (35,) must be a 2-tuple or 3-tuple. ``` </p></details>   From what I understand, the edg variable must be a tuple of (x,y) coordinates basically. For some reasons, some nodes are either in the (x,) format or in the ((x,y),) format, which does not allow the script to run. I put in the box bellow the part that arises the error when I print edg.  <details><summary><code>print(edg)</code></summary><p> <!-- between the ticks below, paste the output of 'conda info' -->  ``` [ ... (33, 292),  (33, 293),  (31, 34),  (34, 380),  (2, 35),  (35,),  (2, 36),  (37, 38),  (38, 41),  (38, 43),  (37, 39),  (39, 200), ... ] ``` </p></details>   I don't understand what the origin of the problem is and how to fix it. I really just want to import my shapefiles and get the shortest path between two nodes... I am not very experimented with python and english is not my native language so I'm sure my problem is not explained very well but I would very much appreciate any help that could be given to me.   ## Edit  I checked every variables used and found out that the "l" one might be the problem. Each edges gets two sets of coordinates which are the start and end of the edge but some only have one set.  <details><summary><code>print(l)</code></summary><p>  ``` [ ...  {(2.455183, 48.7774425), (2.455329, 48.7774934)},  {(2.4553081, 48.7776195), (2.455329, 48.7774934)},  {(2.455329, 48.7774934), (2.4576711, 48.7775673)},  {(2.455183, 48.7774425), (2.4551873, 48.7776523)},  {(2.454872, 48.7820323), (2.4551873, 48.7776523)},  {(2.4574735, 48.7736999), (2.4577528, 48.7738954)},  {(2.4574735, 48.7736999)},  {(2.4577528, 48.7738954), (2.4578287, 48.7723847)},  {(2.4586793, 48.7825114), (2.4595176, 48.7825368)},  {(2.4585674, 48.7823935), (2.4586793, 48.7825114)},  {(2.4583212, 48.7825048), (2.4586793, 48.7825114)},  {(2.4595176, 48.7825368), (2.4596865, 48.7825375)},  {(2.4596865, 48.7825375), (2.45971, 48.7826767)},  ... ] ``` </p></details>  What does it mean for an edge to only have one set of coordinates? Isn't that supposed to be just a node? Is there a way I can 'fill' the missing set by duplicating the first set, so instead of having something like this:  ```  {(2.4574735, 48.7736999)}, ```  I'd have something more like this which, I think, might get my code to run:  ```  {(2.4574735, 48.7736999), (2.4574735, 48.7736999)}, ```  Thank you in advance for taking time to read all that.
