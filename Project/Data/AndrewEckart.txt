issue
Store `G.adj` as a local variable to speed up `complement_edges(G)`#TITLE_END#As discussed in #3700, repetitive access to the `Graph.adj` property may degrade performance. This is the case for the current implementation of the `complement_edges` function located in `networkx.algorithms.connectivity.edge_augmentation.py`.  This PR includes a trivial change to store the adjacency view as a local variable instead of repeatedly accessing the property inside of a loop. This eliminates `(n choose 2)` function calls, so the performance gain can be noticeable.  Demo code (profiled line-by-line using [pprofile](https://pypi.org/project/pprofile/)): ```python import pprofile import networkx as nx from networkx.algorithms.connectivity.edge_augmentation import complement_edges   if __name__ == "__main__":     G = nx.complete_graph(1000)     prof = pprofile.Profile()     with prof():         res = sorted(complement_edges(G))     prof.dump_stats("stats.out") ```  Before change: ``` Total duration: 16.0684s ... File: C:\Users\Andrew\Desktop\networkx\networkx\algorithms\connectivity\edge_augmentation.py File duration: 5.00392s (31.14%) Line #|      Hits|         Time| Time per hit|      %|Source code ------+----------+-------------+-------------+-------+----------- ...   1103|         1|            0|            0|  0.00%|def complement_edges(G): ...   1134|    499501|     0.654009|  1.30932e-06|  4.07%|        for u, v in it.combinations(G.nodes(), 2): (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\graph.py:661 nodes (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:204 __call__ (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:184 __iter__ (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:181 __len__   1135|    499500|      4.34991|  8.70854e-06| 27.07%|            if v not in G.adj[u]: (call)|    499500|      3.27943|  6.56542e-06| 20.41%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\graph.py:338 adj (call)|    499500|      3.41293|  6.83269e-06| 21.24%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\coreviews.py:81 __getitem__ (call)|    499500|      4.37214|  8.75304e-06| 27.21%|# C:\Users\Andrew\AppData\Local\Programs\Python\Python39\lib\_collections_abc.py:766 __contains__   1136|         0|            0|            0|  0.00%|                yield (u, v) ```  After change:  ``` Total duration: 11.3651s ... File: C:\Users\Andrew\Desktop\networkx\networkx\algorithms\connectivity\edge_augmentation.py File duration: 3.71185s (32.66%) Line #|      Hits|         Time| Time per hit|      %|Source code ------+----------+-------------+-------------+-------+----------- ...   1103|         1|            0|            0|  0.00%|def complement_edges(G): ...   1127|         1|            0|            0|  0.00%|    adj = G.adj (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\graph.py:338 adj ...   1135|    499501|     0.528476|  1.05801e-06|  4.65%|        for u, v in it.combinations(G.nodes(), 2): (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\graph.py:661 nodes (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:204 __call__ (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:184 __iter__ (call)|         1|            0|            0|  0.00%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\reportviews.py:181 __len__   1136|    499500|      3.18338|  6.37312e-06| 28.01%|            if v not in adj[u]: (call)|    499500|      3.24649|  6.49949e-06| 28.57%|# C:\Users\Andrew\Desktop\networkx\networkx\classes\coreviews.py:81 __getitem__ (call)|    499500|      4.40576|  8.82034e-06| 38.77%|# C:\Users\Andrew\AppData\Local\Programs\Python\Python39\lib\_collections_abc.py:766 __contains__   1137|         0|            0|            0|  0.00%|                yield (u, v) ```
issue
Add unit tests and examples / doctests for nx.descendants_at_distance#TITLE_END#Documented some examples and added a couple of unit tests for `nx.descendants_at_distance`. Also did some minor refactoring to eliminate an unreachable line. Increases module coverage to 100%.  Fixes #4957 
issue
MAINT: Refactor test_edgelist.py, add tests for parse_edgelist#TITLE_END#The scope of this PR consists of several improvements to `networkx/readwrite/tests/test_edgelist.py`: - Adds static methods to generate data used repeatedly throughout tests for `read_edgelist`. - Uses the `textwrap.dedent` utility to avoid ugly (byte)string formatting, and adds static methods to generate StringIO and BytesIO objects from indented multiline strings. - Gives `read_edgelist` tests more informative names, e.g. `test_read_edgelist_no_data` rather than `test_read_edgelist_1`. - Removes some code which was duplicated across tests. - Adds three test cases for `parse_edgelist` to match the [documentation](https://networkx.github.io/documentation/stable/reference/readwrite/generated/networkx.readwrite.edgelist.parse_edgelist.html?highlight=parse_edgelist).  Fixes #4127 
issue
DOC: Fix copy-pasted docs for random_tournament and hamiltonian_path#TITLE_END#Looks like someone copy-pasted the docs for `random_tournament` and `hamiltonian_path` from `is_tournament` and forgot to change the return types.
issue
MAINT: Refactor nx.info#TITLE_END#I was reading the discussion into #4139 and it led me to some questionable code in `nx.info`. For example, in a digraph we compute the average in-degree and out-degree by iterating over the nodes (twice), even though both `G.number_of_edges` and `G.number_of_nodes` are called earlier in the function. Unless I'm missing something (certainly possible), these are both equal to #nodes/#edges by definition. Similarly, the average degree in an undirected graph should just be double the ratio of edges to nodes.  This is a small refactor to eliminate redundant computation. In theory, it should make `nx.info` faster on large graphs, but using @rossbar's example of `nx.path_graph(int(1e7))` I got similar results before and after the changes. So maybe it's unnecessary, but I figured I'd leave that up to the maintainers since it's already done.
comment
~~I think there is a middle ground that could be useful in some cases: keep the property, but if it is going to be used many times, then store it as a local variable as a performance optimization. For an example of this approach, see #5032.~~  Edit: I see this is already the pattern used in most places throughout the codebase. I also notice this pattern used in a few different places: ```     adj = G.pred if G.is_directed() else G.adj ``` which is the type of thing that could be abstracted away with a property.
comment
Haha beat me to the punch! Just wrote nearly the exact same thing.  I think people working with many large graphs might be a little surprised when `str(G)` takes linear time, but hopefully this is a very small subset of users. In any case it sounds like keeping track would require some type of distributed counter and significant engineering.
comment
> Do we need/want to keep `nx.info`?  `nx.info` has some functionality that `Graph.__str__` doesn't - you can pass it a specific node to find out information about that node (its degree and its neighbors). If that logic is redundant or can be given another home, I think `nx.info` could be deprecated - getting rid of it outright would create some back-compat issues.
comment
I'd like to get into this, but I have a question: is there any particular reason that `G.number_of_edges` (or really, `G.size`) is calculated on demand and not stored as an attribute on `Graph` and maintained whenever edges are added/removed to facilitate O(1) lookups?   I think @parth-verma's suggestion above is perfect, but `__str__` should run in constant time.
