issue
Fix all_node_cuts output for complete graphs#TITLE_END#Closes #6533   I modified the special condition for complete graphs in `all_node_cuts` to return an empty generator and also changed the test cases accordingly.
issue
Similar functions in shortest_paths produce different types of output#TITLE_END#The single_source_shortest_path_length method returns a dictionary while the single_target_shortest_path_length returns a generator.  This was first discussed [here](https://github.com/networkx/networkx/discussions/5511).  I further looked into the output types of all related functions in shortest_paths and I believe it would make sense to change the output type of all length-related methods to dictionary for the sake of consistency.  <img width="278" alt="image" src="https://user-images.githubusercontent.com/82928853/226372801-5a4edf02-4dbe-4294-bcfc-93b9ab8ed74a.png">  Fixing this would only require minor code edits and I presume some changes in the test files as well, it'd be great if I can get someone else's opinion on this as well!
issue
Changed return types of shortest path methods to improve consistency#TITLE_END#Fixes: #6527  Deprecation warnings for this added in #6567   This should be merged in v3.3  Changed the output of `single_target_shortest_path_length` to dictionary, and of `shortest_path` to iterator. The test cases have also been modified accordingly.  This makes the shortest path methods more consistent.
issue
Update documentation for community algorithms#TITLE_END#Some of the community algorithms like `kernighan_lin_bisection`, and `naive_greedy_modularity_communities` are only implemented for certain types of graphs (undirected, not multigraph). The documentation should be updated to reflect the same.   What would be the appropriate place to add that, in the _parameters_ section or the _raises_ section?
issue
Handling corner cases in laplacian_centrality#TITLE_END#This was first touched upon in #6565 and #6571. But, I think the previous discussion is part of a broader issue in `laplacian_centrality` that needs to be handled.  TLDR; Exceptions should be raised for the two cases - 1. when there are no edges on the graph and 2. when there is a single node in the graph.  The following formula gives the computation for Laplacian Centrality.  $$\begin{align}\begin{aligned}C_L(u_i,G) = \frac{(\Delta E)_i}{E_L (G)} = \frac{E_L (G)-E_L (G_i)}{E_L (G)}\end{aligned}\end{align}$$  $$\begin{align}E_L (G) = \sum_{i=0}^n \lambda_i^2\end{align}$$  From this particular part -   $$\begin{align}\begin{aligned}C_L(u_i,G) = \frac{E_L (G)-E_L (G_i)}{E_L (G)}\end{aligned}\end{align}$$  It is evident that when the Laplacian energy of G (E<sub>L</sub>(G)) = 0, Laplacian centrality is not defined because of zero division error.   E<sub>L</sub>(G) = 0 when the eigenvalues of Laplacian matrix of G are all zero i.e. Laplacian matrix is a null matrix. Laplacian matrix of G is a null matrix when there are no edges in G. Currently the `laplacian_centrality` method does not handle this case very well.   ```python G = nx.Graph() G.add_nodes_from([3, 4]) nx.laplacian_centrality(G) ``` The following Numpy warning is raised. ``` RuntimeWarning: invalid value encountered in double_scalars   lapl_cent = lapl_cent / full_energy ``` Output: ```python {3: nan, 4: nan} ```  I think Laplacian matrix can be null only when there are no edges in the graph (self-loops not counted as edges).  ```python H = nx.Graph() H.add_nodes_from([1, 2, 3]) H.add_edges_from([(1, 1)]) print(nx.laplacian_matrix(H).toarray()) ``` Output: ```python [[0 0 0]  [0 0 0]  [0 0 0]] ```  Thus, NetworkX should raise an exception when a graph with zero edges (ignoring self loops) is passed to the `laplacian_centrality` method.  Also, for the case when there is a single node in the graph, the above condition obviously holds true since there are no edges. But there is another side to it - to compute the `laplacian_centrality` of a node, we also calculate **E<sub>L</sub>(G<sub>i</sub>)** i.e. Laplacian energy of graph G when the node is dropped. When the one and only node of G is dropped, G is now an empty graph and the Laplacian matrix isn't defined on an empty graph.  ```python K = nx.Graph() print(nx.laplacian_matrix(K).toarray()) ``` ``` NetworkXError: Graph has no nodes or edge ```  While `laplacian_centrality` already handles the case when there are no nodes in a graph to begin with, a separate exception should be raised for the case when there is a singular node in the graph.  @dschult @rossbar Can you give your inputs on this?
issue
nx.draw_networkx_multigraph_edges method#TITLE_END#This is a continuation of PR #5882   Tried to resolve the problems discussed [here](https://github.com/networkx/networkx/pull/5882#discussion_r949526503).
issue
Fix Johnson method for unweighted graphs#TITLE_END#Closes #6749   Modified the behavior of the code to match the docstring for Johnson's shortest path method.  Now the unweighted edges in a graph are assumed to have weight 1.
issue
Fix intersection_all method#TITLE_END#Fix for issue #6728   Implemented the suggested fix for `intersection_all` method.
issue
Add Lowest Common Ancestor example to Gallery#TITLE_END#I have written a python script that computes the Lowest Common Ancestor for certain node pairs in a generated tree and then visualizes them with a color scheme.
issue
Fix output of is_chordal for empty graphs#TITLE_END#Closes #6562   For graphs with number of nodes <= 3, is_chordal should return True. I have added a special condition to the code for the same.  Also added a test case that checks if True is returned when an empty graph is passed.   Though, I am confused about a particular test case -   ```python self_loop_G = nx.Graph() self_loop_G.add_edges_from([(1, 1)]) cls.self_loop_G = self_loop_G  with pytest.raises(nx.NetworkXError, match="Input graph is not chordal"):        nx.is_chordal(self.self_loop_G) ``` Since the graph has only 2 nodes, shouldn't it return True?
issue
Fixing DOT format for to_agraph()#TITLE_END#Fixes: #6049   First, I replicated the issue discussed in #6049 and found that it still persists.  <img width="566" alt="image" src="https://user-images.githubusercontent.com/82928853/223691011-25ed6908-d842-471e-8fed-da58ce1c2413.png">  The output of the out.dot file is given below which is in the format pos="(0,0)"  <img width="170" alt="image" src="https://user-images.githubusercontent.com/82928853/223691185-e362d361-d47c-48cc-a7ac-8b4c56b45054.png">  As discussed in the issue, I made changes to the to_agraph() method so that the DOT format is pos="0,0". Now the code executes without any warnings as expected.  <img width="565" alt="image" src="https://user-images.githubusercontent.com/82928853/223691422-2bff0a12-f78a-4c75-b058-b2df4f3c4cd3.png">  The contents of the file out.dot are also as expected.  <img width="157" alt="image" src="https://user-images.githubusercontent.com/82928853/223691785-01127d4c-7a62-4f5a-b9d0-9ec46f1e46cb.png">
issue
Add examples to bipartite centrality.py#TITLE_END#I added examples in the docstring for the degree_centrality, betweenness_centrality and closeness_centrality methods in  centrality.py
issue
Fix links in laplacian_centrality and laplacian_matrix#TITLE_END#Fixed the links in the `See Also` section for [laplacian_centrality](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.laplacian_centrality.html) and [laplacian_matrix](https://networkx.org/documentation/stable/reference/generated/networkx.linalg.laplacianmatrix.laplacian_matrix.html) that were not working
issue
Fixed method description in ismags.py#TITLE_END#Closes #6594   Changed the method description of `partition_to_color` so that it is easier to understand.
issue
Layout of website page for ISMAGS needs fixing#TITLE_END#The website documentation page for [ISMAGS algorithm](https://networkx.org/documentation/stable/reference/algorithms/isomorphism.ismags.html) is not rendering properly. The layout of components is messed up.  <img width="959" alt="image" src="https://user-images.githubusercontent.com/82928853/227500999-8a7f51a5-f04e-41b1-9c0c-b17e9be9b3dc.png">  <img width="960" alt="image" src="https://user-images.githubusercontent.com/82928853/227501167-c14302bd-9b80-4139-9a6a-95d1bd4e8b0b.png"> 
issue
Error in method description in ismags.py#TITLE_END#The docstring of `partition_to_color` method in ismags.py seems off to me. The description is not clear, and it's hard to understand what the method is supposed to do.  ```python def partition_to_color(partitions):      """     Creates a dictionary with for every item in partition for every partition      in partitions the index of partition in partitions.          Parameters     ----------     partitions: collections.abc.Sequence[collections.abc.Iterable]         As returned by :func:`make_partitions`.     Returns     -------     dict     """     colors = {}     for color, keys in enumerate(partitions):         for key in keys:             colors[key] = color     return colors  ``` I think the following description explains the method better.  ```python def partition_to_color(partitions):     """     Creates a dictionary that maps each item in each partition to the index of      the partition it belongs to     """ ``` If the new description looks alright, I'll go ahead and make the changes.
issue
Fixed doc_string return type inconsistencies in weighted.py#TITLE_END#Reference issue #6527   Fixed the return type inconsistencies in the following methods of weighted.py -   1. `all_pairs_dijkstra_path` 2. `all_pairs_bellman_ford_path` 3. `single_source_bellman_ford_path_length`
issue
Add community detection example to Gallery#TITLE_END#I have written a python script that demonstrates the use of Girvan-Newman method to detect communities in the Zachary Karate Club dataset. It also plots the change in modularity as the important edges are removed with each iteration.
issue
Improve test coverage for redundancy.py#TITLE_END#I found that the [test coverage for redundancy.py](https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/bipartite/redundancy.py) is currently 92.31%.  I have added some code that tests an _if_ condition that was previously not covered.  The test coverage has now reached 100%.  ![image](https://user-images.githubusercontent.com/82928853/227724810-f844b1cd-b4ce-46fd-9f0b-53f8d3af0f64.png) 
issue
Fixed return type inconsistencies in shortest path methods documentation#TITLE_END#Minor edits to correct the return type of path-related methods from `lengths` to `paths` in the documentation.
issue
Add docstring examples to dag.py#TITLE_END#I added examples in the docstring for the compute_v_structures method in dag.py for better understanding.
issue
Add docstring examples to boundary.py#TITLE_END#I added examples in the docstring for the edge_boundary and node_boundary methods in boundary.py
issue
Add docstring example to weighted.py#TITLE_END#Added example in the docstring for computing edges of shortest path in a MultiGraph in `dijkstra_path` method in weighted.py based on the discussion over [here](https://github.com/networkx/networkx/discussions/5818).
issue
Improve test coverage for mst.py and bug fix in prim_mst_edges()#TITLE_END#Closes #6477   I have added test cases for Kruskal and Prims algorithms. The test coverage for mst.py has now increased to 98%.  ![image](https://user-images.githubusercontent.com/82928853/224429707-4cc0fcd8-ebf8-4dd5-8c63-b9de5fc59c43.png)  This is my first time writing tests, so I apologize in advance if there are any errors in the code. I am specifically doubtful of the Prims test when ignore_nan = False and an Error is raised.  Edit - This PR also fixes some bugs based on [this discussion](https://github.com/networkx/networkx/pull/6486#discussion_r1136069166). The bug fix introduces new branches to the code, so the test coverage is now 96%.
issue
Add examples clarifying ambiguity of nbunch#TITLE_END#I have added examples to the definition of `nbunch` in the glossary section of documentation.  They clarify the behavior when an iterable is passed as nbunch to a method in Networkx.  Reference issues #6509 and #4781
issue
Improve test coverage for edgelist.py#TITLE_END#I found that the [test coverage for edgelist.py](https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/bipartite/edgelist.py) is currently 86%.  I have added test cases for the various conditions specific to the parse_edgelist() method and the coverage has now reached 100%.  ![image](https://user-images.githubusercontent.com/82928853/225000103-3a95658e-069c-4ab9-baaa-bc554b84c40a.png) 
issue
Improve test coverage for astar.py#TITLE_END#I found that the [test coverage for astar.py](https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/shortest_paths/astar.py) is currently 91%.  I have added test cases for the two exceptions that can possibly be raised by the astar_path and astar_path_length methods.  The test coverage has now reached 100%.  ![image](https://user-images.githubusercontent.com/82928853/224756817-81ca5a05-5c60-4d7c-bc69-20f487d0f28f.png) 
issue
Improve test coverage for MST algorithms#TITLE_END#I found that the test coverage for the mst.py file in algorithms/tree is 92.49%  https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/tree/mst.py  I am working on improving this.  Current Behavior We don't test all the paths the code can take us.  Expected Behavior We should be testing everything so there aren't any surprises.
comment
I think this issue has to do with complete graphs in general, because for a complete graph with `n` nodes, the connectivity is `n-1` which is the size of every node cut-set.  _Node cut-set of an undirected graph G is the set of nodes, that if removed, would break G into two or more connected components._  For a K-N graph, we will have to remove n-1 nodes that will break the graph into two components - one with a single node and another with no nodes.  If we assume an empty graph to be a component by itself, then perhaps the output of `all_node_cuts` is valid, else maybe an exception can be raised whenever a complete graph is passed in.
comment
I too read a couple of articles yesterday that discussed cut sets with regard to complete graphs. (refer [CMU lecture notes](https://www.math.cmu.edu/~af1p/Teaching/GT/CH3.pdf), [Wolfram MathWorld](https://mathworld.wolfram.com/VertexCut.html)).  All sources said that complete graphs have no vertex cut, even though the vertex-connectivity is n âˆ’ 1.  I think we should remove the code that handles the case of complete graphs. The test cases should check that in case of complete graphs, `list(all_node_cuts(KN_graph)` should be empty and of size node_connectivity in other cases.
comment
> Make the code return an empty set when the input is a complete graph. I think this just means deleting the special case handling code, but we better check that.  I ran the code after removing the special condition, but it does not give the required output. This is what we get -   ```python graph = nx.Graph() graph.add_edge(1,2) list(nx.all_node_cuts(graph)) >>> [{1}] ```  ```python graph = nx.complete_graph(5) list(nx.all_node_cuts(graph)) >>> [{0, 1, 2, 3}] ```  So, I have modified the condition to return an empty generator instead in the PR.
comment
@dschult You're right, it seems that the problem is not just the edge cases.   I'm also surprised by the fact that when I run the following code (which is the same as above except for the edges removed) the answer comes out to be correct -   ```python G = nx.complete_graph(5) G.remove_edges_from([(1, 2), (0, 4)]) print(list(nx.all_node_cuts(G))) # returns [{1, 2, 3}, {0, 3, 4}] ``` I have been trying to understand the issue with this function but haven't come up with anything yet, but I'll keep looking.
comment
This is because the nodes in the node list of a cycle are not necessarily returned in the order by which they appear in the cycle.   This behavior has been documented [here](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.cycles.minimum_cycle_basis.html#networkx.algorithms.cycles.minimum_cycle_basis).
comment
The parameters part of the docstring may have been copied from the rest of the functions (Dijkstra and Bellman-ford) in the file. These methods assume the weight of the edge to be 1 when not specified.  It makes sense to have similar behavior for the Johnson method as well. We'll only need to remove the `nx.is_weighted` condition and modify/remove the test cases for unweighted and single-node graphs.  No other changes will be required since the Johnson method uses `_bellman_ford` and `_dijkstra` methods that already handle the unweighted edges.  If this approach seems alright, I'll create a PR.
comment
@Qudirah `if nodes is None` is marked yellow because we have to check for the condition when Nodes is NOT equal to None. Add a testcase where a container of nodes is provided to the method.
comment
When `is_chordal` is called, this statement is executed -   ```python return len(_find_chordality_breaker(G)) == 0 ``` Since no source `s` has been specified in `_find_chordality_breaker`, the following statements execute which further raises `StopIteration` because there are no nodes in G.  ```python if s is None:         s = arbitrary_element(G) ```  I believe a specific condition needs to be added to `is_chordal` that returns True when `len(G.nodes) == 0`,  in fact this condition can be extended to `len(G.nodes) <= 3` because such a graph will always be chordal.
comment
> I'll add bit more context for the change in the docstring as well and add relevant tests.  @PurviChaurasia Hey, I'm already working on it, was just adding test cases when I saw the comments ðŸ˜…
comment
> There is actually a wrong test case in `test_chordal.py` in line 63. It is mentioned: `assert nx.is_chordal(nx.complete_graph(3))` I think we'll have to comment that out as well.  No, but why? The test case looks alright to me
comment
This issue has been discussed in #6626   When `normalized=True` and `full_energy=0`, I'm not sure if it is a good idea to return a zero value for Laplacian centrality since the mathematical formula does not provide a valid value for the given graph. I suggested to raise an exception that explains the behavior.  BUT if we consider the definition that Laplacian centrality is a _measure of drop in Laplacian Energy of graph when the particular node is removed_, it can be reasoned that since the initial energy of graph is zero, removing any node of the graph will have no effect whatsoever on the Laplacian Energy, thus zero values for Laplacian centrality make sense.  For the case with single nodes, there is a suggestion [here](https://github.com/networkx/networkx/issues/6626#issuecomment-1512170299) that is consistent with the changes made in this PR, but the reasoning behind it is different.
comment
@vanshika230 Hey, I created a [PR](https://github.com/networkx/networkx/pull/6542) for LCA example too a couple of days back. Just wanted to let you know! If it's something different that you're working on, I apologize :)
comment
@Hanspagh Hey, you can check out a related discussion over [here](https://github.com/networkx/networkx/issues/4781)!  @dschult I think we should include some clarifying examples in the [documentation here](https://networkx.org/documentation/stable/reference/glossary.html#term-nbunch) for the time being, irrespective of whether we plan to change the current behavior or not, so that there are no surprises for users!
comment
> And yes @navyagarwal including some clarifying examples in the documentation would be good! :)  I'll get to it!
comment
Based on the discussion over [here](https://github.com/networkx/networkx/issues/5723), I gather that the pydot package has issues and is not actively maintained. Consider using nx.nx_agraph.read_dot instead.
