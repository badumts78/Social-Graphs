issue
FEAT: Add a describe method for some basic info about graphs#TITLE_END#Fixes https://github.com/networkx/networkx/issues/5326  I think 3 years is the perfect time to get this done ðŸ˜„   This adds a new function which computes some couple of stats as proposed in https://github.com/networkx/networkx/issues/5326, users can also hook into the describe function if they want to calculate more properties.
issue
Stop using codecov, test out using pytest-cov instead#TITLE_END#One immediate idea for replacement would be to move the `coverage` job from github over to `circleci`. The `pytest-cov` extension already has native support for generating nice (static) html coverage summaries which we'd be able to view directly with circleci's artifact system.  _Originally posted by @rossbar in https://github.com/networkx/networkx/issues/8152#issuecomment-3088881831_             
issue
MAINT: Use pytest-cov to generate html reports#TITLE_END#Fixes https://github.com/networkx/networkx/issues/8157, upload the coverage report to github instead of using the `codecov-action` github action.
issue
MAINT: Support PEP 639 for license metadata#TITLE_END#While building the wheel, the warning pops up multiple times. Hopefully the setuptools bump shouldn't be consequential. 
issue
DOC: Add details about more grants#TITLE_END#resolves https://github.com/networkx/networkx/issues/7809
issue
DOC: Remove myself from the mentor list for projects#TITLE_END#I won't have bandwidth this summer so I'll remove myself for the time being.
issue
Refactor shortest_paths logic with match#TITLE_END#In the spirit of https://github.com/networkx/networkx/issues/7036 just wanted to test out how we can use structural matching in the context of networkx. I think `shortest_paths` is definitely a good candidate.   I'm not sure if this is indeed the best way!  Once we have some basic agreement about this we can try to spread this across networkx :)  PS: I do like how the code reads!
issue
Add a toggle to API docs backend section#TITLE_END#Let's try this out. Need to move the backend section to the top if this looks nice.
issue
MAINT: Move stub func in the correct scope for pickle test#TITLE_END#pytest-randomly seems to be tripping up on this https://github.com/networkx/networkx/actions/workflows/pytest-randomly.yml  Closes #7808 
issue
MAINT: Close mpl figures in tests to clear up test env#TITLE_END#The test in https://github.com/networkx/networkx/pull/7739 added some flakiness to our [pytest-randomly runs](https://github.com/networkx/networkx/actions/workflows/pytest-randomly.yml). This should hopefully clean it up :)
issue
Revert "Clarify that basis generates simple cycles only"#TITLE_END#Reverts networkx/networkx#6882  woopsie
issue
CI: Fix typo in nightly run pip install#TITLE_END#Nightly tests are broken https://github.com/networkx/networkx/actions/workflows/nightly-release-test.yml because of a typo in the pip install command.
issue
Add disclaimer about LLM driven PRs#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html --> 
issue
DOC: Bring back plausible for docs#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html --> 
issue
FIX: scipy 1d indexing tripped up numpy?#TITLE_END#Our nightlies are broken right now https://github.com/networkx/networkx/actions/workflows/nightly-release-test.yml and my hunch is something happened after https://github.com/scipy/scipy/pull/20120  I am not sure if this is expected behavior @dschult ?
issue
FEAT: adding a PoC of creating an internal cache#TITLE_END#We had a nice discussion in the networkx developer meeting today about cache-ing intermediate scipy sparse states and also providing this cache dictionary to backends so they can store their objects once converted.  This is just a PoC to show how it could look like, we should probably create a NXEP or a doc to cover the cacheing policy.  There is considerable speedups on the second call as this caches the sparse array, even without a "backend" there is considerable speedup and we should look at this in a bit more detail.  ``` python In [1]: import networkx as nx  In [2]: G = nx.erdos_renyi_graph(10_000, 0.1)  In [3]: %time _ = nx.pagerank(G) CPU times: user 7.85 s, sys: 1.53 s, total: 9.38 s Wall time: 7.68 s  In [4]: %time _ = nx.pagerank(G) CPU times: user 73.6 ms, sys: 11.4 ms, total: 85 ms Wall time: 85.7 ms  In [5]: G.remove_node(0)  In [6]: %time _ = nx.pagerank(G) CPU times: user 5.45 s, sys: 254 ms, total: 5.7 s Wall time: 5.76 s  In [7]: %time _ = nx.pagerank(G) CPU times: user 72.2 ms, sys: 12.2 ms, total: 84.4 ms Wall time: 85.3 ms ```
issue
Random failures in nightly wheel upload action#TITLE_END#Not sure what is causing this but the action https://github.com/networkx/networkx/actions/workflows/nightly.yml failed a couple of times during this week. Manually re-triggering makes the action work just fine.  From the error, seems like the action was uploading and deleting it at the same time? ``` Uploading file "scientific-python-nightly-wheels/networkx/3.3rc0.dev0/networkx-3.3rc0.dev0-py3-none-any.whl" Warning:  Distribution "networkx-3.3rc0.dev0-py3-none-any.whl" already exists. Removing. Error:  ("release version='3.3rc0.dev0' does not exist", 404) ```  I am not sure if this is just a connectivity bleep?  
issue
CI: update upload-nightly-action to 0.5.0#TITLE_END#<!-- Please use pre-commit to lint your code. For more details check out step 1 and 4 of https://networkx.org/documentation/latest/developer/contribute.html --> 
issue
ENH: Speed up common/non_neighbors by using _adj dict operations#TITLE_END#I'm not sure why we should not use direct set operations on the `_adj` dictionary to find common neighbors. This will require a deprecation probably as we will change the behavior of the return type (`generator` to `set`).  This was spurred by https://github.com/networkx/networkx/discussions/7243.
issue
Divisive community algorithms#TITLE_END#This PR brings in the algorithms implemented in https://github.com/networkx/networkx/pull/764, cleaned up a bit.
issue
DOC: build with nx-parallel extra documentation information#TITLE_END#This should let us add information about nx-parallel implementation in the main networkx.org doc website. https://github.com/networkx/nx-parallel/pull/27 adds the `backend_info` entry point for nx-parallel.
issue
DOC: Add plots to classic graph generators docs#TITLE_END#Builds on top of https://github.com/networkx/networkx/pull/6401  I have added a seed and removed the links to download script/png/pdf from the doc build. IMO we should be using this to just quickly show how the graph looks like, we don't need to worry about making this reproducible on a pixel level.
issue
Remove deprecated shortest_path behaviour and fix docs#TITLE_END#This PR removes the deprecation warnings from https://github.com/networkx/networkx/pull/6567 and builds on https://github.com/networkx/networkx/pull/6584
issue
Sync up behavior of is_{type} for empty graphs#TITLE_END#Currently we get very different answers if we use a `nx.is_something()` method with an empty graph. This PR tries to sync them up. It's still not synced up, we should probably decide on one behavior.  Current: - `is_aperiodic` -> StopIteration (empty digraph) - `is_arborescence` -> NetworkXPointlessConcept: G has no nodes. - `is_branching` -> NetworkXPointlessConcept: G has no nodes. - `is_chordal` -> StopIteration - `is_connected` -> NetworkXPointlessConcept: ('Connectivity is undefined ', 'for the null graph.') - `is_distance_regular` -> StopIteration - `is_eulerian` -> NetworkXPointlessConcept: ('Connectivity is undefined ', 'for the null graph.') - `is_forest` -> NetworkXPointlessConcept: G has no nodes. - `is_regular` -> StopIteration - ` is_semiconnected` -> NetworkXPointlessConcept: Connectivity is undefined for the null graph. - `is_semieulerian` -> NetworkXPointlessConcept: ('Connectivity is undefined ', 'for the null graph.') - `is_strongly_connected` -> NetworkXPointlessConcept: Connectivity is undefined for the null graph. - `is_strongly_regular` -> StopIteration - `is_tree` -> NetworkXPointlessConcept: G has no nodes. - `is_weakly_connected` -> NetworkXPointlessConcept: Connectivity is undefined for the null graph.  I have added a `nx.NetworkXError("Graph has no nodes.")` error for methods which were raising a `StopIteration` error. I could change this to `NetworkXPointlessConcept` if that makes more sense. Ideally I would like to see all of these methods returning uniform answers. Maybe there should be a decorator for this :me cringing:
issue
MAINT: use ruff format instead of black#TITLE_END#The [ruff formatter ](https://docs.astral.sh/ruff/formatter/)is in "production-ready beta" now, and it's supposed to be a [99% drop in replacement for black](https://docs.astral.sh/ruff/formatter/#black-compatibility).  I ran our codebase with the ruff formatter and it makes minimal changes to our black formatted codebase and it's much faster than the black formatter (it still follows the black spec).  We still will depend on blacken-docs for now. They are still finialising support for formatting code inside docstrings (https://github.com/astral-sh/ruff/issues/8908).
issue
DOC: add reference to fast_label_propagation_communities#TITLE_END#addresses https://github.com/networkx/networkx/pull/6843#issuecomment-1855983250
issue
 DOC: consistent spelling of neighbor and rename vars #TITLE_END#This addresses the comment by @dschult https://github.com/networkx/networkx/pull/4308#issuecomment-730305251 and also builds on top of https://github.com/networkx/networkx/pull/4309 
issue
Hamming distance code bits from PR #893#TITLE_END#Opening this PR with some changes so we can go through this once again.  This supersedes #893
issue
DOC: fix URL econded links and doc references#TITLE_END#This should fix https://github.com/networkx/networkx/issues/7150 atleast in networkx docs (not the root cause in sphinx). I also found that `compute_v_structures` wasn't properly listed in the reference docs.
issue
DOC: Link methods in functions to base Graph methods/properties#TITLE_END#This links the functions.py docstrings to the base Graph class, should resolve https://github.com/networkx/networkx/issues/7124
issue
FIX: Match the doc description while copying over data#TITLE_END#As pointed out by @eriknw in https://github.com/networkx/networkx/pull/7066#discussion_r1374017287, we weren't following our own docs :) 
issue
Properly handle edge cases for greedy_modularity_communities#TITLE_END#Currently we don't do a good job of catching edge cases like empty graph, no edges, 3 nodes 1 edge: ``` python >>> greedy_modularity_communities(G) # empty graph .... .... ValueError: cutoff must be between 1 and 0. Got 1.  >>> greedy_modularity_communities(G) # 3 nodes 1 edge ..... ..... StopIteration:  >>>  greedy_modularity_communities(G) # no edges .... .... ZeroDivisionError: division by zero ```  We should catch them and error out more gracefully.
issue
Revert "MAINT: Disable building delaunay geospatial example temporarily"#TITLE_END#Reverts networkx/networkx#6981  There is new contextily release already, this shouldn't be necessary.
issue
MAINT: Disable building delaunay geospatial example temporarily#TITLE_END#Fix to make our CI happy for now. Should be reverted as soon as there is a new contextily release https://github.com/networkx/networkx/issues/6980
issue
CI broken due to delaunay plotting example#TITLE_END#Our current doc building pipeline is broken as there has been a change in one of the services behind contextily https://github.com/geopandas/contextily/issues/223, I think we can should wait for them to cut a new release.  We can temporarily stop building `plot_delaunay` to make our CI happy.
issue
MAINT: Use importlib.resources instead of file dunder to access files#TITLE_END#This should fix https://github.com/networkx/networkx/issues/3929  I'm not too sure if there is a better way of doing this. I don't really like writing down the paths explicitly.
issue
MAINT: Scipy nightly failing with np alias#TITLE_END#Nightly build was failing as `errstate` alias isn't available in scipy anymore https://github.com/networkx/networkx/pull/6857
issue
MAINT: Clean up commented out code in triads#TITLE_END#Looks like these functions weren't implemented after https://github.com/networkx/networkx/pull/3742
issue
FIX: MultiDiGraphs keys got lost in weighted shortest paths#TITLE_END#This should fix https://github.com/networkx/networkx/issues/6921  The `_weight_function` assumes that the key of a multigraph is also passed in the data dictionary but `nx.selfloop_edges` only returns the keys when explicitly asked. 
issue
MAINT: Raise clean error with random_triad for graph with <3 nodes#TITLE_END#fixes https://github.com/networkx/networkx/issues/6915
issue
Add non-graphical examples to graphical degree sequences doc strings #TITLE_END#In https://github.com/networkx/networkx/pull/5634/ examples were added to the doc strings for graphical sequences, but it would be nice to add an example for non graphical sequences too. An example is available in a review comment by @dschult  https://github.com/networkx/networkx/pull/5634#issuecomment-1731412262.
issue
Make position part of the API for geometric_edges#TITLE_END#Implements the node attr part from https://github.com/networkx/networkx/issues/6753
issue
edges property and edges() give different results for Multi(Di)Graphs.#TITLE_END#``` python >>> import networkx as nx >>> G = nx.complete_graph(5, create_using=nx.MultiGraph()) >>> G.add_edge(0, 1) >>> G.edges MultiEdgeView([(0, 1, 0), (0, 1, 1), (0, 2, 0), (0, 3, 0), (0, 4, 0), (1, 2, 0), (1, 3, 0), (1, 4, 0), (2, 3, 0), (2, 4, 0), (3, 4, 0)]) >>> G.edges() MultiEdgeDataView([(0, 1), (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) ```  The property one gives out the key name while calling `edges` with the graph object only prints out the nodes. Is this expected behaviour?
issue
MAINT: move dispatch test workflow as an independent CI job#TITLE_END#This change does make us write the same bit multiple times but it will make it much quicker to check if a test failure in the PR came from dispatching. This will change the action label from `test / base` to `test / dispatch`
issue
FIX: Better default behaviour for percolation centrality with no node attrs#TITLE_END#Closes #6886 (we could raise an error instead) If the default attribute (`percolation`) is not present for every node it will default to 1. This will also add defaults to nodes if the node attribute is only present for a subset of nodes. This shouldn't break any old code as anyone using this with the node attribute not set for every node would have been getting a `KeyError`.   ~This depends on https://github.com/networkx/networkx/pull/6887~
issue
 API: Add a decorator to deprecate positional args #TITLE_END#[Scikit-learn has a decorator](https://github.com/scikit-learn/scikit-learn/blob/8ed0270b99344cee9bb253cbfa1d986561ea6cd7/sklearn/utils/validation.py#L37C1-L90C44) which took care of the deprecation cycle for moving to keyword args from positional args. I have vendored that in as a networkx decorator.  This should resolve https://github.com/networkx/networkx/issues/4845. 
issue
Rename nx.join to something which gives more context about operations on trees#TITLE_END#While reviewing #6503 [@dschult noted](https://github.com/networkx/networkx/pull/6503#issuecomment-1707200999) that the current function name `nx.join` doesn't give enough information to the user. The function is used to "join" trees.  This will require a deprecation cycle.
issue
DOC: Add example for self loop multidigraph in contraction#TITLE_END#Add an example to explain for multidigraphs while contracting nodes with self loops in the original graph.  An example to resolve https://github.com/networkx/networkx/issues/6739  @Diarmuid-ODonoghue do you think this accurately covers the case?
issue
MAINT: Make GEXF and graphml writer work with numpy 2.0#TITLE_END#Nightly tests are failing with numpy 2.0 as numpy has removed `np.float_` https://github.com/networkx/networkx/actions/runs/6061305343/job/16446362472  I think this change should be backward compatible (?) as GEXF and graphml the format don't have a concept of numpy floats (?).
issue
Add a quickstart guide/option to use github codespaces to our developer docs?#TITLE_END#Currently our developer docs only cover using local installs/developer env setup. Should we also look into supporting github codespaces? It can help interested new contributors, especially for quick doc changes or during sprints.
issue
 MAINT: Point the PR template to pre-commit #TITLE_END#The PR template was asking users to install black and use it manually to fix linting. We should be asking contributors to run pre-commit.
issue
ENH: let users set a default value in get_attr methods#TITLE_END#Currently it's not possible to get a dictionary with a default value if someone uses the `get_(node/edge)_attributes` methods. If a user passes an attribute name which is set by only a subset of nodes/edges they need to augment the return dictionary manually if they want to set a default value.  The implementation in this PR should be backward compatible so if someone is only expecting to get the nodes/edges which has these attributes it will keep on working.  This came up while trying to come up with a fix for https://github.com/networkx/networkx/issues/6886
issue
Remove deprecated function nx.info#TITLE_END#bye bye nx.info, we should really try to get something which is more useful and informative.
issue
Move benchmarks inside main repo#TITLE_END#As discussed in the meeting this PR move the benchmarks from https://github.com/networkx/nx-benchmarks to this repo. We can also go the submodule road if we want to keep the main repo a bit leaner (I don't have strong opinions on this).  These are the basic ASV benchmarks, this is not comprehensive. We can(should) add more tests. There is some documentation https://asv.readthedocs.io/en/stable/writing_benchmarks.html about writing benchmarks with ASV.  We will use a subset of these benchmarks (TBD) to run the continuous benchmark action in https://github.com/networkx/networkx/pull/6834
issue
NetworkX fails with NumPy 2.0dev - NEP 51#TITLE_END#The `main` branch currently [fails](https://github.com/networkx/networkx/actions/runs/5845735581/job/15850137542) with the numpy 2.0 nightly release as numpy has changed the (printing) behavior of scalars [NEP 51](https://numpy.org/neps/nep-0051-scalar-representation.html). Our doctests will fail as it's expecting an exact string match (?).  
issue
Remove survey banner#TITLE_END#fixes https://github.com/networkx/networkx/issues/6817
issue
Make weight part of the API for functions which had default assumptions#TITLE_END#As part of https://github.com/networkx/networkx/pull/6688, we found some functions were making assumptions about the `weight` parameter. It was not user programmable and it was defaulting to `weight` the string.  This implements https://github.com/networkx/networkx/issues/6753 and exposes `weight` as part of the API.
issue
Add preserve_all_attrs to convert_from_nx to make it concise#TITLE_END#implements the idea by @eriknw in https://github.com/networkx/networkx/pull/6688/files#issuecomment-1652314158
issue
MAINT: Ignore SciPy v1.11 in requirements#TITLE_END#Should we just keep this pin till scipy 1.11+ becomes the min supported scipy version for networkx?
issue
DOCS: Add walks to algorithms.index#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Use the correct namespace for girvan_newman examples#TITLE_END#Users won't be able to run the example code just by doing copy and paste with the current examples. And the first guess of doing `nx.girvan_newman` will also be wrong. We should try to be explicit about the namespaces (something I got from the user survey).
issue
remove survey banner#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
MAINT: Add subgraph_view and reverse_view to nx namespace directly through graphviews#TITLE_END#Currently `subgraph_view` and `reverse_view` are available in the global `nx` namespace but they are exposed via a redirect in `functions.py`. This was added in https://github.com/networkx/networkx/pull/3627 and I'm not a 100% sure why it is done this way. Also made changes to some other places where `subgraph_view` and `reverse_view` where being imported via `networkx.graphviews` and not via the `nx` namespace. 
issue
MAINT: Add a github action cron job to upload nightly wheels#TITLE_END#implements https://github.com/networkx/networkx/issues/6700  Just testing this out, still need to add a token.
issue
MAINT: fix file path in nightly build workflow#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
MAINT: cron job to test against nightly deps every week#TITLE_END#implements https://github.com/networkx/networkx/issues/6703  Currently using https://pypi.anaconda.org/scipy-wheels-nightly/simple which hosts the nightly wheels
issue
Improve test coverage for algorithms in maxflow.py#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for algorithms in maxflow.py. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/flow/maxflow.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/algorithms/flow/tests/test_maxflow.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/flow/maxflow.py 
issue
add ruff commit to git-blame-ignore#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Add Plausible Analytics to our docs#TITLE_END#This gives us an anonymous way of tracking usage of our documentation website. By this PR we will only be able to track usage of the latest dev website, which I think is a good start.  This uses the instances hosted by the Scientific Python project.  Should we also put up some disclaimer or note in our README that we are using this? 
issue
DOC: list pred method for MultiDiGraphs#TITLE_END#Fixes https://github.com/networkx/networkx/issues/6408
issue
spectral bisection for graphs using fiedler vector#TITLE_END#Merge the last remaining bits of GSoC 2011 work by @bjedwards  This is follow on of https://github.com/networkx/networkx/pull/764/  - moved spectral_bisection to `networkx/linalg/algebraicconnectivity.py` and updated the code to use fiedler_vector to find the bisection. 
issue
Remove pdf latex builds of docs#TITLE_END#This has been discussed before and it's currently a blocker of moving to myst_nb from nb2plots for code block directives in our documentation. Opening this just so we can get the ball rolling on this one and have a decision :)
issue
Clean up similarity.py and use dataclasses for storing state#TITLE_END#Made some subjective maintenance changes to similarity.py and fix https://github.com/networkx/networkx/issues/5532  I have also used dataclasses for the 2 classes used in similarity.py as the only usecase here was to store state.
issue
Start using ruff for pyupgrade and isort#TITLE_END#Use ruff's isort and pyupgrade in the pre-commit pipeline.  All works except there is a ruff-isort change in `networkx/algorithms/centrality/betweenness_subset.py`, not a 100% sure if this is an issue or not. I'm fine either way.
issue
NXEP 0 and NXEP 1 - change status to Accepted#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  We should change the status of our governance NXEP to "Accepted".
issue
Remove deprecated function is_string_like#TITLE_END#Remove functions is small modular fashion so it's easy to revert them.  Bye bye `is_string_like`
issue
Add pytest-mpl to requirements/test#TITLE_END#I just tried a clean install using our documentation and it didn't install pytest-mpl
issue
ignore isort commit from git blame#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Update subgraph views tests to pass with out of order execution#TITLE_END#pytest-randomly fails here (https://github.com/networkx/networkx/pull/4553)
issue
Correctly point towards 2.8.8 in release notes#TITLE_END#Fixes https://github.com/networkx/networkx/issues/6297
issue
Update copyright years to 2023#TITLE_END#Time for the new-year-update-copyright PR. Happy new year!  There is a debate about this if we even need to keep the years in the notice[1][2] but until that is resolved let's update them.   [1] https://hynek.me/til/copyright-years/ [2] https://github.com/scipy/scipy/issues/15282#issuecomment-1003762552
issue
Improve test coverage for line graph generators#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for the line graphs generators. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/line.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/generators/tests/test_line.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/line.py 
issue
Improve test coverage for algorithms in beamsearch.py#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for algorithms in beamsearch.py. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/traversal/beamsearch.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/algorithms/traversal/tests/test_beamsearch.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/traversal/beamsearch.py 
issue
 Improve test coverage for algorithms in dominating_set.py#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for algorithms in dominating_set.py. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/approximation/dominating_set.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/algorithms/approximation/tests/test_dominating_set.py ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/approximation/dominating_set.py 
issue
Improve test coverage for algorithms in betweenness_subset.py#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for algorithms in betweenness_subset.py. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/centrality/betweenness_subset.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/algorithms/centrality/tests/test_betweenness_centrality_subset.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/centrality/betweenness_subset.py
issue
DRAFT: Adding support for a GraphBLAS backend#TITLE_END#This a minimal draft PR to get the conversation rolling. I have moved bits of algorithms from https://github.com/python-graphblas/graphblas-algorithms (currently being developed by @eriknw) so that we can "natively" support a GraphBLAS backend. This does require people to have [suitesparse-graphblas](https://github.com/GraphBLAS/python-suitesparse-graphblas) available locally and pypi only has wheels for linux right now (that shouldn't be a big issue atleast right now I guess).   For the API bits, I was thinking of creating an independent submodule where users needs to explicitly call to use graphblas.  Current API in this PR and performance comparison with our current implementations: ``` python In [1]: import networkx.graphblas as gnx  In [2]: import networkx as nx  In [3]: G = nx.erdos_renyi_graph(500, 0.8)  In [4]: %%timeit    ...: gnx.average_clustering(G)    ...:     ...:  204 ms Â± 2.49 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)  In [5]: %%timeit    ...: nx.average_clustering(G)    ...:     ...:     ...:  6.97 s Â± 606 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)  In [6]: %%timeit    ...: gnx.transitivity(G)    ...:     ...:  177 ms Â± 7.41 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)  In [7]: %%timeit    ...: nx.transitivity(G)    ...:     ...:  7.18 s Â± 570 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)  In [8]: %%timeit    ...: nx.pagerank(G)    ...:     ...:  106 ms Â± 2.85 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)  In [9]: %%timeit    ...: gnx.pagerank(G)    ...:     ...:  124 ms Â± 2.88 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each) ```
issue
 Improve test coverage expanders stochastic graph generators#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for the stochastic graphs generators. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/stochastic.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/generators/tests/test_stochastic.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/stochastic.py 
issue
plugin based backend infrastructure to use multiple computation backends#TITLE_END#With these changes backends like `graphblas`, `scipy.sparse`, `cugraph` can directly plug into networkx and use it as an API. The computation and return logic is handled by the backend. These changes are opt-in and experimental right now so this will not break any networkx code (hopefully).  The `graphblas` backend plugin is available at https://github.com/python-graphblas/graphblas-algorithms/ and a minimal working prototype which wraps `scipy.sparse.csgraph` is available at https://github.com/MridulS/nx_csgraph  The main logic of this exists in `networkx/classes/backends.py` (we can move this to another place if that makes more sense) which defines a decorator `dispatch`. The decorator does a type check on the first argument of an algorithm (usually a Graph object) and dispatches it to appropriate backend. This decorator doesn't yet work with algorithm that expects multiple graphs like `is_isomorphic` and there is no magical conversion between types (nx->graphblas or any other) just yet. We can do the heuristic bits of conversion once we have tested this out a bit more.  An example of how this will look like for a user:  ``` python In [1]: import networkx as nx  In [2]: import graphblas_algorithms as gba  In [3]: G = nx.erdos_renyi_graph(1000, 0.2)  In [4]: G_gba = gba.Graph.from_networkx(G)  In [5]: %%timeit    ...: nx.pagerank(G_gba)    ...: 5.71 ms Â± 200 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)  In [6]: %%timeit    ...: nx.pagerank(G)    ...: 125 ms Â± 1.82 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each) ```       TODOs - [ ] tests for the decorator - [x] get the docs bit into our documentation so sphinx picks it up - [x] xfail pytest if the decorator dispatches to a backend which doesn't implement the algorithm
issue
DOC: Specifically branch off main, instead of current branch#TITLE_END#Update the new contributor documentation to branch off from main. This will make sure people are creating branches from their local copy of main instead of the current working branch. 
issue
 Improve test coverage expanders line graph generators#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for graph generators in expanders.py. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/expanders.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/generators/tests/test_expanders.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/expanders.py
issue
 Improve test coverage for algorithms in load centrality#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  Currently we don't have full coverage for the algorithms in load centrality. Code blocks which are highlighted with red at codcov https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/centrality/load.py don't have corresponding tests. The tests should be added in https://github.com/networkx/networkx/blob/main/networkx/algorithms/centrality/tests/test_load_centrality.py  ### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  We don't test all the paths the code can take us.  ### Expected Behavior  <!--- Tell us what should happen -->  We should be testing everything so there aren't any surprises.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug -->  Visit https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/algorithms/centrality/load.py 
issue
Revert "Cache edges, degree, adj properties of Graph classes (#5614)"#TITLE_END#This reverts commit f50fc70b8cb6b4f5217a6d5505ba0e2b82b4761b and https://github.com/networkx/networkx/commit/d46c0c219f6082424074f077ef2c1e40a9ff7065  This change brought in a performance regression in core classes. I'm not a 100% sure if we should keep this change (cacheing) in 3.0 or not?  If we want to revert, this can also go into 2.8.5
issue
Add direct link to github networkx org sponsorship#TITLE_END#If someone clicks on the `<3 Sponsor` button top of the repo in https://github.com/networkx/networkx/ this change will let them directly sign up via GitHub sponsors and it will take them to https://github.com/sponsors/networkx (which we need to update). 
issue
Speed up unionfind a bit by not adding root node in the path#TITLE_END#As suggested by @dschult in https://github.com/networkx/networkx/pull/4810, but FWIW it doesn't have that much of difference in speed. I'm +0 on this.
issue
Use py_random_state to control randomness of random_triad#TITLE_END#Make sure results are reproducible.
issue
Test out explicit paths while installing pygraphviz in macOS#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Catch ':' explicitly while working with pydot#TITLE_END#pydot has it's own mechanism to deal with quoting string and we shouldn't try to change that.  In https://github.com/networkx/networkx/pull/5667 I added a catch all which didn't work with the internal system of pydot as it adds quotes for some strings.  In this PR I am explicitly looking for `:` and if someone provides a node/edge name/attribute without the double quotes it will fail on the them gracefully. But this change should keep on working for people who were depending on pydot to add quotes to their strings. 
issue
Error out when pydot fails to correctly parse node names#TITLE_END#Maybe we should error out gracefully when there is an issue with converting a python string (name of the node in the networkx object) to a pydot Node object.  This should help out with issues like https://github.com/networkx/networkx/issues/5662, https://github.com/networkx/networkx/issues/4663  Also this way we can probably catch other parsing errors, not just `:` ones.
issue
[WIP] CI: Boilerplate benchmarks using asv#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Currently planning on running the whole suite on NX 2.0 - 2.7, testing out at https://mriduls.com/nx-asv-benchmarks/ 
issue
Remove deprecated code from utils for 3.0#TITLE_END#Now that 2.8 is out, it's time to start removing all the code ðŸ’ƒ   I'm wondering if we should do this in one go in one PR or should we break this up in more modular PR's to make it easier to review? 
issue
pagerank_* profiling, let users pass in a scipy.sparse object instead of only a networkx graph object?#TITLE_END#I did some basic code profiling for `pagerank`, `pagerank_numpy`, `pagerank_scipy`. Most of the time is taken up by the conversion process of a NetworkX object to a scipy.sparse or numpy matrix object inside the `pagerank_scipy` function. The one time conversion cost can be reduced for all the algorithms which use `to_scipy_sparse_matrix` internally.  We may probably complicate the API if we let users pass in graph objects other than NetworkX.  I tested them with 2 new functions `matrix_pagerank_scipy` (it takes in a scipy sparse object instead of a NetworkX graph object) and `matrix_pagerank_scipy_cython` (takes in a scipy sparse object with a bit of Cython sprinkled in the code).  `matrix_pagerank_scipy` can be 80-90x faster than `pagerank_scipy` and 800-900x faster than pure python pagerank. `matrix_pagerank_scipy_cython` can be 1.2-1.4x faster than `matrix_pagerank_scipy`  Example with a graph with 5000 nodes. ``` python G = nx.fast_gnp_random_graph(5000, 0.1) M = nx.to_scipy_sparse_matrix(G,dtype=float)  %%timeit nx.pagerank(G) 26.3 s Â± 77.8 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)  %%timeit nx.pagerank_scipy(G) 2.46 s Â± 158 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)  %%timeit matrix_pagerank_scipy(M) 27.7 ms Â± 1.82 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)  %%timeit matrix_pagerank_scipy_cython(M) 24.1 ms Â± 712 Âµs per loop (mean Â± std. dev. of 7 runs, 10 loops each)  ``` 
issue
Condensation function: mapping and members attributes are hardly accessible.#TITLE_END#### Discussed in https://github.com/networkx/networkx/discussions/5446  <div type='discussions-op-text'>  <sup>Originally posted by **Moss4t** March 31, 2022</sup> In [this](https://networkx.org/documentation/stable/_modules/networkx/algorithms/components/strongly_connected.html#condensation) documentation, I found how to access mapping attribute on graph C: C.graph['mapping']. But still no idea how to access the dictionary for found SCCs and corresponding nodes (still researching). Please make the description more clear on how to use this function. I'm a beginner in python, but I'm already thankful for the makers of the code. It helps a lot!</div>  Currently we don't have any example how to access the SCCs and mapping from the `condensation` function. We should add an example in the function documentation.  An example is present in the discussion.
issue
Make HITS numpy and scipy private functions#TITLE_END#Okay this one may require some discussion. Should we keep both implementations which use scipy?
issue
Remove deprecated functions hub_matrix and authority_matrix#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Add more comprehensive tests for pydot#TITLE_END#Thanks for the catch @hectormauer!  Added some more tests to catch these things.  Fixes https://github.com/networkx/networkx/issues/5790 and hopefully the last pydot fix :/
issue
Remove copy methods for Filter* coreviews#TITLE_END#I guess no one used this as we haven't heard anything.
issue
What could types/stubs look like if we end up with stubs#TITLE_END#Just a draft PR (not a serious attempt) to see what would types as stubs will end up looking like, reviewing a PR which adds stubs would also be pretty huge undertaking.
issue
Remove unused deprecated argument from to_pandas_edgelist#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Update return type of attrmatrix#TITLE_END#It does feel like I'm missing some update to documentation here.
issue
Update return type of google_matrix to numpy.ndarray#TITLE_END#Maybe there is some docs I am missing to update here?
issue
Remove deprecated function extrema_bounding#TITLE_END#bye bye `extrema_bounding`
issue
Remove deprecated function iterable#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `iterable`
issue
Remove deprecated function utils.default_opener#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `default_opener`
issue
Remove deprecated functions dict_to_numpy_array2 and dict_to_numpy_array1#TITLE_END#bye bye `dict_to_numpy_array2` and `dict_to_numpy_array1`
issue
Remove deprecated functions make_small_graph and make_small_undirected_graph#TITLE_END#bye bye `make_small_graph` and `make_small_undirected_graph`
issue
Remove deprecated function is_list_of_ints#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `is_list_of_ints`
issue
Remove deprecated function utils.to_tuple#TITLE_END#bye bye `to_tuple`
issue
Remove deprecated context managers#TITLE_END#bye bye context managers
issue
Remove deprecated function utils.empty_generator#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `empty_generator`
issue
Remove deprecated function utils.consume#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `consume`
issue
Remove deprecated function is_iterator#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `is_iterator`
issue
Remove deprecated function make_str#TITLE_END#Remove functions is small modular fashion so it's easy to revert them. Bye bye `make_str` 
issue
Another catch by pytest-randomly#TITLE_END#I guess we will see a bunch of other things when https://github.com/networkx/networkx/pull/4553 is merged and the cron job runs every day. 
issue
Some more changes to make pytest-randomly happy#TITLE_END#After this is merged we should be able to merge https://github.com/networkx/networkx/pull/4553, it passed locally on a bunch of runs after these changes.
issue
importorskip scipy instead of numpy for total spanning tree#TITLE_END#fixes https://github.com/networkx/networkx/issues/5692  To catch this we would have to run a CI pipeline with numpy but without scipy. I don't think we should be doing that as it takes up too much CI time, so just adding a fix and no test.
issue
Clean up maximal_independent_set tests#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> I was fiddling around with [memray](https://github.com/bloomberg/memray) and maximal_independent_set tests popped up because of the randomised graph test. Changed a couple of tests (empty_graph makes more sense to test out the seed) and removed the class structure.  
issue
MAINT: Cleanup centrality module, remove unused variables#TITLE_END#Remove more characters from our codebase. Make linters like pylint, isort a bit more happier.  Tiny subjective nitpicks around the code.
issue
Remove unused file from utils.test#TITLE_END# Blah... BLAH BLAH!!!!
issue
 Use isort with pre-commit to enforce import guidelines#TITLE_END#Another precommit automation where we can stop thinking about what and how to do things.  This does not touch any of the `__init__.py` files.  (I thought of doing this after reading https://github.com/networkx/networkx/issues/2723)
issue
Remove redundant py2 numeric conversions - Take 2#TITLE_END#This supersedes https://github.com/networkx/networkx/pull/4508, @eumiro I have pull in commits from https://github.com/networkx/networkx/pull/4508 and added a new commit to fix the conflicts.
issue
Extract valid kwds from the function signature for draw_networkx_*#TITLE_END#This makes sure we don't miss the cases where we add a new argument to a `draw_networkx_*` and not update the valid kwargs in `draw_networkx`.  An extremely explicit way of dealing with https://github.com/networkx/networkx/issues/5658 (I can go back to old way of checking valid kwds if this doesn't look good :) )
issue
Do we need NODE_OK input (Filter*) to accept Graph objects?#TITLE_END#Just testing this on our CI
issue
Filter* views input checks for NODE_OK look for .nodes attributes (?)#TITLE_END#While working on https://github.com/networkx/networkx/issues/4433 I started looking into the code of `Filter*` views and I was wondering why do we have the bit about checking for the `.nodes` attributes in filtered nodes input (`NODE_OK`).   https://github.com/networkx/networkx/blob/8feb4a645c93598bb187bf1707beb673fa27915e/networkx/classes/coreviews.py#L275-L278  Was this to make something like this work? @dschult  ``` >>> G = nx.Graph(...) >>> H = nx.Graph(...) >>> nx.subgraph_view(G, H) A subgraph of G with nodes from H? ``` From what I know, nowhere in our current documentation do we claim that users can use anything except a `filter_node` callable to get the underlying `FilterAtlas` view.   For now if I remove the bits of code (https://github.com/networkx/networkx/pull/5373) none of our tests are complaining.  
issue
Fix __setstate__ for OutEdgeView subclasses, read _adjdict from state#TITLE_END#This should fix https://github.com/networkx/networkx/issues/5655  The state written to disk was recently changes in https://github.com/networkx/networkx/pull/5614 for `OutEdgeView` but the sub-classes `InEdgeView` and `InMultiEdgeView` still depended on the old read mechanism from the Graph object itself, this PR changes it to read directly from the `_adjdict` state.
issue
Update dfs_test with more comprehensive tests#TITLE_END#From https://github.com/networkx/networkx/pull/1826, the current tests for DFS may miss an edge case (have multiple successors) if there are any changes in the code in the future.
issue
DOC: fix up links, remove references to directed graphs, add proper cites#TITLE_END#Was reading the codebase for Laplacian today :) 
issue
Fix sphinx build errors and warnings#TITLE_END#We currently have a couple of errors in our doc building pipeline. This should fix them.
issue
DOCS: add some guidelines for references#TITLE_END#Just some opinions about how to add references, feel free to edit them :) 
issue
MAINT: Prim MST test didn't pass algorithm name to all unit tests#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> While reviewing https://github.com/networkx/networkx/pull/5455 I realized we weren't explicitly testing a couple of unit tests with `prim`'s algorithm.
issue
Update black#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Ignore formatting changes with black, pep8 for git blame#TITLE_END#I picked up commits from the history of main branch which did a bunch of formatting changes with black. I also added some other commits like https://github.com/networkx/networkx/commit/be23fa0e422b51f4526828cb19b8105c89e5dcbb which was for compliance with PEP8.  We can merge this in and people locally using black with `.git-blame-ignore-revs` configured should be able to use this. We need to wait for GitHub to enable this all public wide to use this on the Github UI.  Closes https://github.com/networkx/networkx/issues/5382
issue
BUG: Explicity import importlib.machinery#TITLE_END#fixes https://github.com/networkx/networkx/issues/5367  Tested this on fedora 35 and it works ``` # pip install https://github.com/mriduls/networkx/archive/importlib.zip # python3 -c "import networkx" ```  We should probably have a 2.7.1 release too.
issue
Update mentored project info with the expected time commitment#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
DOC: change status to accepted for NXEP2, add resolution#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> Wasn't super sure about how to update this so added a new section `Resolution` in the NXEP
issue
MAINT: Cleanup assortativity module, remove unused variables#TITLE_END#Raise errors instead of accepting invalid arguments silently  This would also help with less errors for folks using linters locally in their IDEs  <!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
DOC: Update documentation to include callables for weight argument#TITLE_END#While going through some of the docs I saw that the documentation doesn't accurately represent what the `weight` argument can do. We can pass in a function callable to the `weight` argument too for these methods. 
issue
MAINT: Remove unnecessary helper functions, use inbuilt methods for line graph generator#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. -->  Closes https://github.com/networkx/networkx/issues/4459 Also removed other helper functions which could be rewritten quickly with python one liners. 
issue
MAINT: Cleanup link analysis module, remove unused variables#TITLE_END#Remove more characters from our codebase. Make linters like pylint, isort a bit more happier.  Tiny subjective nitpicks around the code. 
issue
add slice to __getitem__ for Node(Data)View#TITLE_END#@dschult I started playing around with returning slice lists when the user explicitly asks for it. I have done this for `Node(Data)View` right now, would love to get some feedback and thoughts about this design before going further with this.  The following code will be valid if we have slices in `Node(Data)View`. ``` python In [13]: G.nodes[0:5]                                                                                                              Out[13]: [8433035090, 6272075181, 1180114949, 3701032566, 4290388111]  In [14]: G.nodes(data=True)[0:5]                                                                                                   Out[14]:  [(8433035090, {'w': 2716738093, 't': '6076217445'}),  (6272075181, {'w': 7046427529, 't': '891215421'}),  (1180114949, {'w': 9901849457, 't': '4451045765'}),  (3701032566, {'w': 2467916768, 't': '3668632860'}),  (4290388111, {'w': 505061655, 't': '5801405547'})]  In [15]: G.nodes(data='w')[0:5]                                                                                                    Out[15]:  [(8433035090, 2716738093),  (6272075181, 7046427529),  (1180114949, 9901849457),  (3701032566, 2467916768),  (4290388111, 505061655)] ```
issue
Make nx.hits a wrapper around different implementations, use scipy one by default#TITLE_END#Wrappers for HITS, https://github.com/networkx/networkx/issues/4371
issue
DOC: Add links to proposals for completed projects#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Documentation deploy is flaky when generating documentation for osmnx example#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  There is a flaky deploy of documentation while building the osmnx example. It was an issue in osmnx (https://github.com/gboeing/osmnx/issues/734) but the fix is not in a released version yet.  ### Current Behavior <!--- Tell us what happens instead of the expected behavior -->  From GitHub actions https://github.com/networkx/networkx/runs/3814138884?check_suite_focus=true ```  Extension error: 3374 Here is a summary of the problems encountered when running the examples 3375  3376 Unexpected failing examples: 3377 /home/runner/work/networkx/networkx/examples/geospatial/plot_osmnx.py failed leaving traceback: 3378 Traceback (most recent call last): 3379   File "/home/runner/work/networkx/networkx/examples/geospatial/plot_osmnx.py", line 22, in <module> 3380     G = ox.graph_from_point((37.79, -122.41), dist=750, network_type="drive") 3381   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/graph.py", line 156, in graph_from_point 3382     G = graph_from_bbox( 3383   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/graph.py", line 81, in graph_from_bbox 3384     G = graph_from_polygon( 3385   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/graph.py", line 420, in graph_from_polygon 3386     response_jsons = downloader._osm_network_download(poly_buff, network_type, custom_filter) 3387   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/downloader.py", line 508, in _osm_network_download 3388     response_json = overpass_request(data={"data": query_str}) 3389   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/downloader.py", line 716, in overpass_request 3390     this_pause = _get_pause(base_endpoint) 3391   File "/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/site-packages/osmnx/downloader.py", line 327, in _get_pause 3392     sc = response.status_code 3393 UnboundLocalError: local variable 'response' referenced before assignment ```  
issue
Documentation for conda based dev environment setup fails#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->  The new contributor documentation available at https://networkx.org/documentation/latest/developer/contribute.html#development-workflow doesn't work for conda based development environment setup.  ### Current Behavior  While installing developer environment dependencies  ``` $ conda install -c conda-forge `for i in requirements/{default,developer,test}.txt; do echo -n " --file $i "; done`  InvalidVersionSpec: Invalid version '1.19;platform_python_implementation!='PyPy'andpython_version<'3.10'': invalid character(s) ``` it fails to parse the pip specific requirements.txt file. ### Expected Behavior <!--- Tell us what should happen -->  Users should be able to setup the development environment by following the documentation.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug -->  ``` $ conda install -c conda-forge `for i in requirements/{default,developer,test}.txt; do echo -n " --file $i "; done`  InvalidVersionSpec: Invalid version '1.19;platform_python_implementation!='PyPy'andpython_version<'3.10'': invalid character(s) ```  ### Environment <!--- Please provide details about your local environment --> Python version: 3.9.4 NetworkX version: main branch conda version: 4.10.1 
issue
DOC: Fix links, use DOI links, wayback machine where required#TITLE_END#After a bunch of grep-ing, regex-ing and URL checking found a bunch of places where links where broken in the codebase and documentation. I'm sure I would have missed a bunch of them.  For slides, I have linked to a copy from wayback machine where possible. For papers, I have linked to DOI where available.  PS: Maybe a tool like this exist? go through all the codebase and outputs broken links?
issue
DOC: point towards web archive link in GML docs#TITLE_END#The GML specification documentation is not available anymore on the linked website, use archive to points towards an older version of the website.
issue
Add a good first issue badge to README #TITLE_END#Directly takes you to issues grouped with "Good First Issue" label
issue
test out yaml.SafeLoader, let's see if this breaks any tests#TITLE_END#<!-- Please run black to format your code. See https://networkx.org/documentation/latest/developer/contribute.html for details. --> 
issue
Make nx.pagerank a wrapper around different implementations, use scipy one by default#TITLE_END#TODO: - [x] The original python implementation doesn't support multigraphs but scipy and numpy does. How to align that? Merge all the edges? - [x] Update tests to check for 'impl' arguments. - [x] Add deprecation warnings for 2.6
issue
use issue templates to redirect to discussions tab, add a bug report template#TITLE_END#Users will see a screen which asks them to make a choice between `Bug Report`, `Q-A`, `Discussions`, `Blank Issue` when they click on the `new issue` button on GitHub.
issue
NXEP 2 â€” API design of view slices#TITLE_END#[Draft of a draft enhancement proposal]  
issue
MAINT: Speed up transitivity, remove redundant call#TITLE_END#Remove multiple calls to `_triangles_and_degree_iter`. This cuts the `transitivity` calculation time by half.
issue
Add option to specify a column for edge keys in Multi(Di)Graphs when reading through pandas#TITLE_END#When reading in graphs using pandas `from_pandas_edgelist` should we have an option to let users specify the columns from the dataframe for edge keys?  Example ``` python G = nx.from_pandas_edgelist(dataframe, source=source,        target=target, edge_attr=[attr1, attr2, attr3], create_using=nx.MultiGraph()) ``` currently networkx will create keys for this graph automatically (0, 1, 2, 3 ......) and to access the edge data we would need to do something like `G[source_node][edge_node][0]`  it would be nice to add an option of adding custom edge keys (assuming we want attr1 to be edge key) ``` python G = nx.from_pandas_edgelist(dataframe, source=source,        target=target, edge_attr=[attr2, attr3], edge_key=attr1, create_using=nx.MultiGraph()) ``` and access the edge information using  `G[source_node][edge_node][attr1_node]`
issue
Add an interface to http://www.graphclasses.org/smallgraphs.html#TITLE_END#This could help us in problems like #1343. We could remove graph atlas and instead use http://www.graphclasses.org/smallgraphs.html for all the small graphs calculations. 
issue
remove f strings from setup.py for clear error message < py3.6#TITLE_END#fixes https://github.com/networkx/networkx/issues/3737
issue
Update single_source_dijkstra_path and all_pairs_dijkstra_path#TITLE_END#@dschult  
issue
Notebooks and Tutorial at github/networkx/notebooks#TITLE_END#With many discussions regarding having Jupyter notebooks for examples and tutorial the consensus is to create a new repo https://github.com/networkx/notebooks. Currently this contains some files (verbose copy) from docs/examples in .ipynb format. Making sure this works and is manageable requires the notebooks to be tested (preferably with something like Travis) and the other advantage of having notebooks is having an interactive way for users to play around with NetworkX. This can be done with https://beta.mybinder.org (this is still under works so the UI doesn't work yet)[1] a build can be triggered for the notebooks repo by this URL https://beta.mybinder.org/v2/gh/networkx/notebooks/master , the build is failing right now because of pygraphviz. Need to look into that.  I have a built a rudimentary setup with binder and travis for the tutorial notebook at https://github.com/MridulS/test-tut , the binder notebook can be spawned by https://beta.mybinder.org/v2/gh/mriduls/test-tut/master and using https://github.com/computationalmodelling/nbval we can test the notebooks. Travis: https://travis-ci.org/MridulS/test-tut   Another important point is that we need to maintain at least 2 copies[different branches] of notebooks to make sure that the notebooks work with the latest release available through pip and the current master dev branch on GitHub. This could be done through branches. The default branch should point to the latest release.   [1] https://github.com/jupyterhub/binderhub  @hagberg @dschult @jarrodmillman 
issue
Functions that currently produce lists which can (should) produce iterators#TITLE_END#We should discuss about various functions/algorithms (non core classes methods) that generate lists which can (should) produce iterators. - `cluster.triangles()` - `cluster.clustering()` - `cluster.square_clustering()` - `boundary.edge_boudary()` - `boundary.node_boundary()` - `core.core_number()` - `dag.topological_sort()` - `dag.dag_longest_path()`  - `approximation.kcomponents.k_components()` - `assortativity.connectivity.connectivity()` - `bipartite.basic.color()` - ........... - .......... - .........  Looking forward to inputs @dschult @hagberg @chebee7i @jfinkels @jtorrents @ysitu 
issue
Design of G.query()#TITLE_END#This was a initial design proposed by @ysitu regarding a G.query() function. https://github.com/networkx/networkx/issues/1246#issuecomment-53139093  > G.query is just a placeholder name. G.**call** may well be a better option. I have the following sketch design in mind (assuming that it is implemented as G.**call**): > - None and a set-like type ANY are reserved for internal use, so None, ANY and instances of ANY cannot be used as nodes or edge/data keys. > - G(u, v, key, data) is a generator of (u, v, key, data, value) tuples, although some components of the tuples may be suppressed per the rules below. If data is suppressed, value is also suppressed. > - Each of the parameters of G(u, v, key, data) can be None, some concrete value, ANY or ANY([value1, value2, ...]). The parameters are interpreted as query filters. > - None and ANY are both universal wildcards, but None also causes the corresponding component in the output tuple to be suppressed. > - value is equivalent to ANY([value]). ANY([value1, value2, ...]) discards a tuple if the corresponding component is not in [value1, value2, ...]. > - None of G(u, v=None, key=None, data=None), G(u, v, key=None, data=None) or G(u, v, key, data=None) returns duplicate tuples. > - For undirected graphs, each edge is not handled as a pair of reciprocal edges. > - Backends may provide additional constraints.  Looking for inputs regarding this. @dschult @hagberg @jtorrents @jfinkels @chebee7i @ysitu  
issue
Added dijkstra version with node weights Fixes #1345#TITLE_END#@dschult Looking forward to your views and suggestions.  
issue
EdgeDataView output for more than one node arguments in G.edges()#TITLE_END#@dschult Is this expected behaviour for `` G.edges(0, 1, 'foo')`` and `` G.edges(0, 1)`` ? ``` python In [5]: G.edges() Out[5]: EdgeView([(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])  In [6]: G.edges(0) Out[6]: EdgeDataView([(0, 1), (0, 2), (0, 3), (0, 4)])  In [7]: G.edges(0, 1) Out[7]: EdgeDataView([(0, 1, None), (0, 2, None), (0, 3, None), (0, 4, None)])  In [8]: G.edges(0, 1, 'foo') Out[8]: EdgeDataView([(0, 1, 'foo'), (0, 2, 'foo'), (0, 3, 'foo'), (0, 4, 'foo')]) ```
issue
NetworkX sprints at SciPy 2017?#TITLE_END#SciPy 2017 is in Austin (10-16 July), we could have a networkx sprint and I guess it will be great way to finish up the work on 2.0 (if 2.0 isn't still released).  The last date to apply is 31st May.  Google form: https://docs.google.com/forms/d/e/1FAIpQLSeAIbbcw0xPZzR8k20MovLpBdhQ5CSSpWYjvyvqxiimfjJQ0A/viewform  @hagberg @dschult @jtorrents @chebee7i 
issue
example notebooks on try.jupyter.org#TITLE_END#There is a subfolder `communities` at https://github.com/jupyter/docker-demo-images for organisations to publish example notebooks.  We can add networkx/notebooks repo to `notebooks/communities/networkx`. 
issue
list optional dependencies in setup.py#TITLE_END#https://github.com/networkx/networkx/issues/2147
issue
correct logic in GEXFWriter#TITLE_END#fixes https://github.com/networkx/networkx/issues/2336
issue
Fix broken links#TITLE_END#Fixes https://github.com/networkx/networkx/issues/2392
issue
[Fixes #2342] remove calls to plt.hold(), deprecated in mpl2.0#TITLE_END#hold() has been removed from matplotlib  https://github.com/matplotlib/matplotlib/issues/3070, it will be `True` by default. should we introduce our own `hold` logic which basically calls `plt.cla()` and `plt.clf()` when `hold=False`  @hagberg   
issue
add example of node weights#TITLE_END#https://github.com/networkx/networkx/issues/1345 and https://github.com/networkx/networkx/pull/1350  We can add node weight functionality by updating `_weight_function` to include `node_weight` as an argument  @jfinkels @dschult @hagberg  Thoughts? 
issue
[WIP] Update exception classes#TITLE_END#@jfinkels  
issue
Google Summer of Code 2016 participation?#TITLE_END#@dschult @hagberg @chebee7i @jfinkels @ysitu @bjedwards @jtorrents and anyone who is interested.   PSF will be applying as a mentor org https://wiki.python.org/moin/SummerOfCode/2016. We can participate again as a suborg. If we have three or four mentors on board we can work on a couple of projects (like last year). Deadline to contact PSF is 7 March, 2016 (nice one and half months to build up on ideas page)  Various ideas were proposed and discussed https://github.com/networkx/networkx/issues/1341 last year.  Some more ideas - I think https://github.com/networkx/networkx/issues/1076 can be a good summer project.  - Extending last year's project, https://github.com/networkx/networkx/issues/1632 and https://github.com/networkx/networkx/issues/1738. - More work on  https://github.com/networkx/networkx-metis. 
issue
PyPy Travis Failures due to unordered dicts#TITLE_END#Encountered in #1350. I think travis failures have something to do with the pypy update to 2.5. After going through http://morepypy.blogspot.in/2015/01/faster-more-memory-efficient-and-more.html and http://bugs.python.org/issue3332 I think this means that dicts that are key-value consistent are not equlivalent due to ordering, and hence the travis fail.  @chebee7i 
issue
Update readme#TITLE_END#Any more suggestions? 
issue
Update deprecation warning#TITLE_END#@jfinkels  
issue
JIT JSON writer, updates #881#TITLE_END#Added tests, implemented `jit_graph`.  
issue
Setting up appveyor#TITLE_END#Travis is capable of running tests for Linux, but we also support Windows. So should we use something like https://ci.appveyor.com for testing the package over windows. @OrkoHunter did this for `networkx-metis` 
issue
add option to view specific attributes in G.nodes()#TITLE_END#This is now consistent with the behaviour of the data parameter of `G.edges()`. We can interact in the same way and get an iterator over (nodes, value of attribute) by `G.nodes(data='attribute')`.  ``` python >>> G = nx.Graph() >>> G.add_nodes_from([0, 1 ,2]) >>> G.add_node(1, time='5pm') >>> G.node[0]['foo'] = 'bar' >>> list(G.nodes(data=True)) [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})] >>> list(G.nodes(data='foo')) [(0, 'bar'), (1, None), (2, None)] >>> list(G.nodes(data='time')) [(0, None), (1, '5pm'), (2, None)]  >>> list(G.nodes(data='time', default='Not Available')) [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')] ``` 
issue
Update community/quality to use quotient_graph instead of blockmodel#TITLE_END#https://github.com/networkx/networkx/pull/1845, https://github.com/networkx/networkx/pull/1771 
issue
Update copyrights#TITLE_END#Updated the copyrights to `...-2016` Happy new year :) 
issue
Algorithms.centrality not rendered in documentation#TITLE_END#https://networkx.readthedocs.org/en/latest/reference/algorithms.centrality.html  The page is not rendered. 
issue
Update install documentation#TITLE_END#Add conda update/conda install to install documentation 
issue
Update all_pairs_dijkstra_path_length and single_source_dijkstra_path_length#TITLE_END#https://github.com/networkx/networkx/issues/1765 
issue
Change file permission and update random graph generator with iter changes#TITLE_END#After some head scratching I found the solution of this bug.  The bug:  `nosetests` skips executable files by default and for some reason `networkx/generators/tests/test_random_graphs.py` had `755` file permission hence nosetests skipped this test on travis.  To reproduce this bug run this command `nosetests --verbosity=3 networkx/generators/tests/`and there will be something like this `nose.selector: INFO: /Users/mridul/dev/nx/networkx/networkx/generators/tests/test_random_graphs.py is executable; skipped` in the output. ~~This will fail travis as I haven't updated the file with `iter` changes.~~ 
issue
Update/discussion of design specification for NX 2.0 #TITLE_END#As suggested in https://github.com/networkx/networkx/pull/1344 , I think we should update/further discuss the design specification accordingly.  @hagberg @dschult @chebee7i  
issue
IPython Notebooks based networkx tutorials #TITLE_END#I have started writing tutorials using IPython notebooks for NetworkX at https://github.com/MridulS/NetworkX-Tutorial .  Please feel free to correct me and contribute to it :) 
issue
Removal of adjacency_list() #TITLE_END#Currently we have two ways to report adjacency, by `adjacency_list()` and `adjacency_iter()`. It seems that no algorithm uses `adjacency_list()`. Is there any specific reason of keeping `adjacency_list()` , should we remove it from the base classes and go forward with `adjacency_iter()` only?  @hagberg @ysitu @dschult @chebee7i @jfinkels  
issue
Update single_source_shortest_path_length and all_pairs_shortest_path_length to return iterators#TITLE_END#https://github.com/networkx/networkx/pull/1715 
issue
Remove __author__ from existing files#TITLE_END#https://github.com/networkx/networkx/issues/1728 
issue
Add iterlen() to utils/misc.py#TITLE_END#As we move towards a more iterators heavy codebase, `iterlen()` could come in handy. Makes it more readable than `sum(1 for _ in iterator)`. 
issue
Update 2.0 notes#TITLE_END#This adds a note regarding the work in iter_refactor branch 
issue
Update shortest_path_length#TITLE_END#I was messing around with `single_source_shortest_path_length` and `all_pairs_shortest_path_length`. Now `single_source_shortest_path_length` returns a (node, distance) two tuple iterator and `all_pairs_shortest_path_length` returns a (node, dict) two tuple iterator. This is a messy PR. I have just added a dict() in front of required code. This PR will fail Travis as there are few things I need to work out.  I am just looking for opinion on the `shortest_paths` algorithms, and what should they return. 
issue
Port tutorial to ipython notebook#TITLE_END#The internal links are broken, I need to fix them 
issue
Update doc with changes in iter_refactor and update iter_refactor branch#TITLE_END#Update doc fa82e79.  Update iter_refactor branch with recent commits in the master branch. 
issue
Travis build failing for approximation/kcomponents#TITLE_END#https://travis-ci.org/networkx/networkx/jobs/69143172#L3006 https://travis-ci.org/networkx/networkx/jobs/67124137#L3417 https://travis-ci.org/networkx/networkx/jobs/66950067#L2992  EDIT: These links are redundant now because they have been restarted The output for the failed test.  ``` python FAIL: test_kcomponents.test_configuration ---------------------------------------------------------------------- Traceback (most recent call last):   File "/home/travis/virtualenv/python3.3.5/lib/python3.3/site-packages/nose/case.py", line 198, in runTest     self.test(*self.arg)   File "/home/travis/virtualenv/python3.3.5/lib/python3.3/site-packages/networkx/algorithms/approximation/tests/test_kcomponents.py", line 148, in test_configuration     _check_connectivity(G)   File "/home/travis/virtualenv/python3.3.5/lib/python3.3/site-packages/networkx/algorithms/approximation/tests/test_kcomponents.py", line 125, in _check_connectivity     assert_true(K >= k) nose.proxy.AssertionError: False is not true     'False is not true' = self._formatMessage('False is not true', "%s is not true" % safe_repr(False)) >>  raise self.failureException('False is not true') ``` 
issue
Make selfloop methods return iterator instead of list in graph class#TITLE_END#This PR updates the methods `nodes_with_selfloops`, `selfloop_edges`, `number_of_selfloops` in `network/classes/graph.py` and `network/classes/multigraph.py`. These functions now return an iterator instead of lists. 
issue
Removal of degree()#TITLE_END#`degree()` returns a dictionary with nodes as keys and degree as values or a number if a single node is specified and `degree_iter()` returns a two-tuples iterator of (node, degree). What should the new `degree()` function in 2.0 return?  IMO we should go with the current two-tuples iterator of (node, degree). 
issue
Update examples directory#TITLE_END#The example in the the `networkx/examples` directory are updated. They follow the recent changes made in core classes and the subclass `AntiGraph`. 
issue
Update assortativity/connectivity.py, target_degree to take in iterator instead of list#TITLE_END##1589 
issue
Pypy Travis time out failure#TITLE_END#The pypy job on Travis is taking more than 50 minutes to complete, and Travis marks it as an error. This has been repeatedly faced in many pull requests. One solution can be to reduce the number of tests for pypy, I can think of removing doctests testing from the pypy module. If something goes wrong in them other tests will catch them. It is better than ignoring pypy all together. 
issue
Makes Graph.nodes() return iterator instead of list#TITLE_END#This was done by @jfinkels in https://github.com/networkx/networkx/pull/1537 .  Related issues: https://github.com/networkx/networkx/issues/572, https://github.com/networkx/networkx/pull/1546 
issue
Remove *iter functions#TITLE_END#This PR builds up on https://github.com/networkx/networkx/pull/1537 by @jfinkels . In this PR I have removed - `edges_iter` for Di/Multi/Graphs - `out_edges_iter` and `in_edges_iter` for Multi/Digraphs - `neighbors_iter` for Di/Multi/Graphs [UPDATE 1]  - `predecessors_iter` and `successors_iter` for Multi/DiGraphs [UPDATE 2]  Now `edges`, `out_edges`, `in_edges` , `neighbors` return iterators instead of lists. @dschult @hagberg @ysitu  Related issues: https://github.com/networkx/networkx/issues/1485 https://github.com/networkx/networkx/issues/572 NOTE: To be merged after release of 1.10 
issue
Update documentation of networkx.algorithms.matching to include reference to networkx.algorithms.bipartite.matching for bipartite graphs#TITLE_END#https://github.com/networkx/networkx/issues/1564 
issue
Update api_2.0.rst to api_1.10.rst and deprecate *iter functions#TITLE_END#@hagberg @dschult @ysitu  
issue
Added power function for simple graphs#TITLE_END#Discussion in #1307  
issue
Added longest_path and longest_path_length for DAG#TITLE_END#As suggested by @hagberg in https://github.com/networkx/networkx/pull/847 and http://stackoverflow.com/questions/17985202/networkx-efficiently-find-absolute-longest-path-in-digraph .  Looking forward for views and suggestions. :) 
issue
Non Isomorphic Trees generator#TITLE_END#Added a generator for non isomorphic trees as suggested by @hagberg in https://github.com/networkx/networkx/issues/1034. - should we keep `_layout_to_matrix`? 
issue
Expose transitive_clousure and antichains in the public API#TITLE_END#@jtorrents #1412  
issue
Fix doc for from_numpy_matrix and to_numpy_matrix#TITLE_END#https://github.com/networkx/networkx/issues/1423 
issue
Documentation Error#TITLE_END#Was going through the documentation for `from_numpy_matrix`  ![screen shot 2015-03-22 at 4 22 50 pm](https://cloud.githubusercontent.com/assets/5363860/6769038/204093ea-d0b0-11e4-910e-34bea61cf8cb.png)  create_using and parallel_edges are surrounded by single backticks, they should be surrounded by double backticks, I presume this will be in a lot of places in the documentation. 
issue
Added node strength for graphs and multigraphs#TITLE_END#I don't know the exact place to put this. Should this be implemented in the algorithms class?  TODO: tests and for directed graphs. 
issue
Using `not_implemented_for` decorator vs G.is_directed() or G.is_multigraph()#TITLE_END#There are many algorithms which are defined only for certain kind of graphs. We can either check the type of graph in the algorithm itself by doing something like  ``` python if G.is_directed():     raise some error ```  but a NetworkXNotImplemented error can also be raised by the decorator `not_implemented_for` by doing something like  ``` python @not_implemented_for('directed') def func(arg1,arg2):     .... ```  Which method is preferable? 
issue
Convert MultiGraph to Graph#TITLE_END#``` python In [2]: G = nx.MultiGraph()  In [3]: G.add_edge(1,2,weight=1)  In [4]: G.add_edge(1,2,weight=2)  In [5]: G.add_edge(3,2,weight=1)  In [6]: H= nx.Graph(G)  In [9]: H.edges(data=True) Out[9]: [(1, 2, {'weight': 2}), (2, 3, {'weight': 1})] ```  nx.Graph(G) should add the weights of all the multiedges instead of just assigning the weight of the latest edge.  I guess the most obvious solution would be to add the edges and it is possible that user wants to convert a multigraph to graph.  @hagberg gave a way to do this in http://stackoverflow.com/questions/15590812/networkx-convert-multigraph-into-simple-graph-with-weighted-edges. 
issue
Added data keyword in G.neighbors#TITLE_END#@dschult  Hey, I am new to networkx and interested in contributing to it.  As mentioned in #1246. I have tried implementing a API 2.0 feature on G.neighbor  neighbors(n, data=None) - iterator over neighbors of n.        If data is True: iterator over (nbr, eattr_dict)        if data not in (None,True): iterator over (nbr, eattr_dict[data])  Please have a look. Needs Review. 
issue
Number of graphs on n unlabelled nodes#TITLE_END#Is it possible to calculate the number of graphs on n unlabelled nodes? Something like:   ``` python >>> import networkx as nx >>> nx.number_of_graphs(3) >>> 4 >>> nx.number_of_graphs(4) >>> 11 ```  And it would be nice if it can return a list of graphs with the possible graphs. http://reference.wolfram.com/language/Combinatorica/ref/ListGraphs.html https://oeis.org/A000088 
comment
`spectral_modularity_partition` and ` greedy_max_modularity_partition` needs to be extracted from this PR to a new one for a quick review and merge :)
comment
Just my opinions (nothing new in here, all of this has been debated a lot already), putting it down as a ~counter~ caution point against inline types:  Inline typing makes the code less readable (I know nothing new but I really want to stress this point again) and I believe a lot of people who are using networkx are not exactly computer science/programming folks, which makes it harder for them to just go in follow along the code. I feel there is a big divide between our users who are developers of downstream libraries and a first year undergrad doing Graph Theory 101 and we would like to help both of them. In my head .pyi files should solve both of these problems.  I understand the idea behind use types to help IDEs but well I don't even use a IDE so not sure if that is a plus point for me personally ðŸ¤·â€â™‚ï¸   Stubs (.pyi files) is what other projects in the ecosystem use (numpy and scipy) and this is what I would vote for to go forward with typing.  > However, the Python world has moved on. Many, if not most, mature Python projects now use inline annotations. In my opinion, it's too late to say "you haven't bought into annotations and types".  I wouldn't be too sure about that! There is a big disconnect between people who use python/JAX **and** read CPython/JAX source code vs people who use networkx **and** read NetworkX source code. I **want** people to read source code of networkx! I want it to make it as easy as possible for non programmers to understand our codebase and things like `Optional[Union[G, Callable[[], G]]]` wouldn't help there.  If there comes a time where we realize that we have to go to inline typing from pyi stubs that's fine by me too! I would rather take a slow inefficient way than a quick way that makes our code "scary" for beginners. We already give up on performance in our codebase vs making it readable.  
comment
node2vec implementation from the authors of the paper https://github.com/aditya-grover/node2vec 
comment
https://github.com/chihming/awesome-network-embedding is a nice resource to find  implementations of network embedding algorithms.
comment
@itsshavar It doesn't depend on deep learning but node2vec builds on top of word2vec, it's still a learning algorithm.  
comment
@dschult do you envision adding graph learning algorithms in networkx? I know of atleast one library which builds on top of networkx with graph learning algorithms, https://github.com/benedekrozemberczki/karateclub 
comment
@kpetridis24 for networkx we need to work under the constraints of the pure-python plus not-too-many dependencies for the parallelization plan. We need to come up with a design where we keep the ethos the project (easy to read code) AND make these speed ups. So this *may* involve something like joblib or a high level interface where we can dispatch the computations.  For MPI there is graph-tool and for CUDA there is CuGraph.
comment
For folks who do end up on this issue, there are more developments going on in the https://github.com/networkx/nx_parallel repository. 
comment
@juanis2112 Thanks for the PR! Do you still have interest and bandwidth to work on this? No worries if not :)
comment
Great! Feel free to open a new one when the time comes :)
comment
I do think that maybe here it is better just to have the not-so-pretty-URLs in the text source vs sphinx friendly wiki links. Even browsing the comment blocks in vim in my terminal lights up the URLs and I can open them in the browser.  https://github.com/user-attachments/assets/f3b019ca-62ea-4b56-945c-a4104b002e9c  I think making the humans happier is a better than making the machines happy here :D 
comment
@dschult is this ready for review? I guess this has some conflicts after https://github.com/networkx/networkx/pull/6334 ?
comment
Is this still relevant @dschult ?
comment
Thanks for the PR @thanosgiap! I'll close this PR for now as it hasn't been touched in a while, feel free to create a new PR with the comments addressed. Thanks!
comment
I'll go ahead and close this as this hasn't been touched in a while, thanks again for the PR!
comment
this was fixed in https://github.com/networkx/networkx/pull/8332
comment
@Astroakanksha24 sorry for the delay in review! If you still have the bandwidth to work on this could you fix merge conflicts? I don't want to push a commit to your `main` branch directly :)
comment
@maksim-melaxtech thanks for your contribution! This hasn't been touched in a while, let me know if you still have the bandwidth to address the comments. No worries if not! Thanks again!
comment
Thanks for the PR!  This hasn't been touched in a while, I'll go ahead and close this PR. Please do checkout the new contributor guide https://networkx.org/documentation/latest/developer/contribute.html to get a local developer environment setup :)
comment
We have added a section to our tutorial so users are careful while using floats as edge attribute values https://networkx.org/documentation/latest/tutorial.html#floating-point-considerations
comment
@acarbonetto thanks for this! It's nice to see more backends implemented in the wild :)  NetworkX has weekly community meetings and I think it would be great to get a quick demo of this if possible! We meet 9am Vancouver time weekly on Thursdays. Link to the .ics https://scientific-python.org/calendars/networkx.ics. It's okay if you can't make it, no pressure :) I would just need to go fiddle around with AWS then.   
comment
The linters are happy with the whitespace. I press merge.
comment
Let's try ðŸš€ 
comment
I tried out with vscode and pycharm in a fresh conda env with python 3.13.5 and networkx 3.2.1.  I get all the fun pop ups without any errors?  <img width="804" height="553" alt="Image" src="https://github.com/user-attachments/assets/523366f2-cb28-4644-b8a7-45722d322363" />   <img width="1246" height="377" alt="Image" src="https://github.com/user-attachments/assets/bf44b071-c76c-4d84-9a48-d118c78c8888" />  I don't know enough about pycharm but maybe it's not running in the right environment?
comment
Closing this for now - see https://github.com/networkx/networkx/pull/7965#issuecomment-3240146150 
comment
Closing this for now - see https://github.com/networkx/networkx/pull/7965#issuecomment-3240146150 
comment
Closing this for now - see https://github.com/networkx/networkx/pull/7965#issuecomment-3240146150 
comment
Closing this for now - see https://github.com/networkx/networkx/pull/7965#issuecomment-3240146150 
comment
I'll go ahead and close these PRs, and just to reiterate @rossbar [comment](https://github.com/networkx/networkx/pull/7965#issuecomment-3053379335) that this is *not* about the code in the PRs or any value judgements about the algorithms. It's just a lot of new algorithms without any dedicated champions on the networkx community/maintainer side ðŸ˜…  I would also suggest to package all the variants up in a new package that depends on networkx and that can be distributed via github/pypi. The scientific python cookie project should take care of all the templating https://github.com/scientific-python/cookie for a new python library! Feel free to ping/tag us if you need any help with this :)
comment
circleci cleans up old builds, I have re triggered the doc build. 
comment
The right place for the generated notebook is https://networkx.org/nx-guides/content/algorithms/lca/LCA.html :)
comment
Thanks for the update! I tried reproducing this with python 3.10 and networkx 3.4.2, and couple of backends but couldn't. I didn't try with nx-cugraph (I don't have a nvidia gpu) but that could be the reason. 
comment
Thanks for the update! I think we can close this issue for now, we aren't able to reproduce this.
comment
From the trace it looks like it's tripping up some parts of dataclasses in python 3.10, and I guess if we can find where it's coming from then yes we can place something to fix the crash :) Not able to reproduce this.
comment
Also didn't we decide to stop using codecov after https://about.codecov.io/security-update/?
comment
@Peiffap I have created #8157, thanks for the PR!
comment
> I wonder if we should make _adj "public" at this point  One of the reasons `_adj` isn't really public is that it's too easy to break your graph object!  ```python In [1]: import networkx as nx  In [2]: G = nx.path_graph(4)  In [3]: G.adj[1] = 2 --------------------------------------------------------------------------- TypeError                                 Traceback (most recent call last) Cell In[3], line 1 ----> 1 G.adj[1] = 2  TypeError: 'AdjacencyView' object does not support item assignment  In [4]: G._adj[1] = 2  In [5]: print(G) --------------------------------------------------------------------------- TypeError                                 Traceback (most recent call last) Cell In[5], line 1 ----> 1 print(G) ..... .....  TypeError: object of type 'int' has no len() ``` If required you can always use it, but `_` by convention basically tells the users to play with this dictionary at your own risk!  What we could do is probably document this speed up if we haven't already!
comment
Maybe we should revisit the implementation and try using `G._adj` instead of `G[...]`? https://github.com/networkx/networkx/blob/2a03462ea94b1ca70b8ab9cb5e04b85b2a146833/networkx/algorithms/bipartite/matching.py#L145
comment
@jangwon-yie just started reviewing this one, a bunch has changed in networkx over 4 years :) Let me know if you still have the interest and bandwidth in getting this in! No worries if not. Thanks for you work on this!
comment
Thanks for the PR @mgorny, I'll close this :)
comment
Just to confirm the pop up only comes in after https://github.com/networkx/networkx/pull/7690 right?
comment
> Presumably ;) (I have tested this locally). Should we go ahead and merge https://github.com/rapidsai/nx-cugraph/pull/50 so we can test that part of the generated admonition? It's ready, but we were holding off in case the API for leiden changed, but it seems like the current API is probably good for now, right?  Yes, I think it's good to go!
comment
Feel free to merge this @Schefflera-Arboricola as is right now, I won't be around much for GSoC mentoring this summer.
comment
> Am I reading this backwards? It looks like square clustering is slower after the changes... Maybe the headings are switched?  Yeah the compare command should be `asv compare main 2d1ad6b1`
comment
Please do update the references :) And we can always keep multiple references too!
comment
> set a fixed seed that works  That's what we usually do.
comment
We can turn on `E501` ruff rule to test this out. We have pycodestyle turned off right now. https://github.com/networkx/networkx/blob/af0d087aef33f8623259421634e213de9f59aed4/pyproject.toml#L218
comment
> To summarize - I think we're then in the state we want to be: users can control whether or not actions run on their fork.  I'll go ahead and close this! 
comment
Putting this here from https://github.com/networkx/networkx/pull/6688/files#issuecomment-1652314158  - [x]  add `preserve_all_attrs=True` argument to `_dispatch` and `convert_from_nx` that is equivalent to `preserve_edge_attrs=True, preserve_node_attrs=True, preserve_graph_attrs=True`.
comment
>  If they are unexpected, I will create a PR to fix it by returning a single 0 if the graph contains only one node.  Yeah we should be catching this corner case. Thanks for your work on this!! Please do send a PR :)
comment
Looking at this one again a code comment explicitly states that for the corner case of isolated nodes while using Borgatti's formula it should be undefined (`nan`)  https://github.com/networkx/networkx/blob/f35e034d33864201e30d53edc37f55f38b384d94/networkx/algorithms/structuralholes.py#L147-L149  But the other case is where I guess we need to make a choice. I think for consistency we put in undefined behavior for isolated nodes but according to the reference it should be zero. https://github.com/networkx/networkx/blob/f35e034d33864201e30d53edc37f55f38b384d94/networkx/algorithms/structuralholes.py#L155-L157  Also the ZeroDivisionError is popping up because of the self loop which makes the node `0` **not** isolated and hence the zero division error isn't caught early on, well I guess the question is does a node with a self loop and no other connection an isolated node? 
comment
The minimum supported version of pydot is `3.0.1` https://github.com/networkx/networkx/blob/44aab23f18f635153c63486e5ba821a8cbba835f/pyproject.toml#L89 Could you bump up pydot in your environment and try it out again?
comment
@hagberg what do you think about an implementation like this for unweighted graphs? [untested] where `mustpass` is a list of mustpass nodes.  ``` python import networkx as nx  def shortest_path_mustpass(G, source, target, mustpass):     paths = list(nx.all_simple_paths(G, source, target))     for i in range(len(paths)):         if len(set(paths[i]).intersection(mustpass)) == len(mustpass):             min = paths[i]             if len(paths[i]) < min:                 min_path = paths[i]     return min_path  if __name__ == '__main__':     G = nx.MultiGraph()     G.add_edge(1,2)     G.add_edge(1,2)     G.add_edge(2,3)     G.add_edge(3,4)     G.add_edge(1,3)     G.add_edge(1,4)     mustpass = [2,3]     print shortest_path_mustpass(G, 1, 4, mustpass)     print shortest_path_mustpass(G, 1, 4, [1,3])  ``` 
comment
One more way could be copying the graph and then deleting the edges as already suggested in the original post. What do you suggest? 
comment
Just thinking out loud.... What if we divide it into a segmented dijkstra and a TSP problem? TSP for nodes in `mustpass` and then find the shortest way from source to a node in `mustpass` nodes and the shortest way from a node in `mustpass` to the target using dijkstra as you suggested? 
comment
@ysitu But will the TSP solver be more efficient than what I have implemented above? 
comment
@ysitu This is a very crude implementation  ``` python import networkx as nx  def shortest_path_mustpass(G, source, target, mustpass=[]):     paths = list(nx.all_simple_paths(G, source, target))     min_path=[]     maximum=0     for i in paths:         if len(i) > maximum:             maximum = len(i)     min_length=maximum     for i in range(len(paths)):         if len(set(paths[i]).intersection(mustpass)) == len(mustpass):             if len(paths[i]) <= min_length:                 min_path = paths[i]                 min_length = len(paths[i])     return min_path  if __name__ == '__main__':     G = nx.DiGraph()     G.add_edge(1,2)     G.add_edge(1,2)     G.add_edge(2,3)     G.add_edge(3,4)     G.add_edge(1,3)     G.add_edge(1,4)     mustpass = [2,3]     print shortest_path_mustpass(G, 1, 4, mustpass)     print shortest_path_mustpass(G, 1, 3, [1,2,3])     print shortest_path_mustpass(G, 1, 4) ``` 
comment
@hagberg @ysitu I have got it wrong, this implementation misses a lot of corner cases. Would like to know your views on the following algorithm.  Basically this is dijkstra of dijkstra algorithm, we start with the nodes: V = source, target, mustpass. And we run a dijkstra on this while an underlying dijkstra is running to find shortest paths from source to find the next node in V. Example:  ``` source = 1 target = 5 edges = (1,4), (1,2), (1,3), (2,3), (2,4), (3,4), (4,5) mustpass = [2,3]  We consider the graph with only 1,2, 3 and 5 as nodes. We use dijkstra to find the shortest path from 1 to 5 which only passes through 2 and 3,  and to travel between these nodes we find the shortest path by running dijkstra  between respective nodes. ```  Looks interesting to me, although it seems inefficient. 
comment
But we want to keep the API design within networkx right? The docs, and function signature needs to be in networkx codebase to make the dispatch work this way.
comment
(Just putting in a comment here to not forget about the conversation with @dschult)  I think it may make sense to bump up the deprecation release cycle to something like 3 or 4 instead of standard 2 cycles in the broader context of the new draw API. It should give us extra time to flush out the new API changes.
comment
Can you also share the logs from the browser console? I assume this hasn't anything to do with your lab network right?
comment
Where are you hitting these issues? They should be resolved in https://github.com/networkx/networkx/pull/7374 and https://github.com/networkx/networkx/pull/7282
comment
Let's merge this for now, we can take care of the action in a new PR :)
comment
This behavior was introduced in https://github.com/networkx/networkx/pull/7570, maybe @mjschwenne can review this?
comment
Hmm, I am not able to reproduce the issue.  I don't have access to databricks and I'm not sure if that could trip up this behavior.  ```python import sys import networkx as nx import matplotlib.pyplot as plt  #####Create a directed graph G = nx.DiGraph()  #####Add nodes G.add_nodes_from(['A', 'B', 'C', 'D'])  #####Add edges G.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'A')])  #####Set node sizes node_size = 400  #####Set edge labels edge_labels = {('A', 'B'): '10%', ('B', 'C'): '20%', ('C', 'D'): '30%', ('D', 'A'): '40%'}  #####Draw the graph pos = nx.spring_layout(G) nx.draw_networkx_nodes(G, pos, node_size=node_size) nx.draw_networkx_edges(G, pos) nx.draw_networkx_labels(G, pos) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, node_size=node_size)  plt.axis('off') plt.show() print(f'NetworkX: {nx.__version__}') print(f'Python: {sys.version_info.major}.{sys.version_info.minor}') ```  gives me  ![Screenshot 2024-10-16 at 7 02 50â€¯PM](https://github.com/user-attachments/assets/e7c7e0c7-c2a2-42b8-b1d0-c9eebf4e6d8c)  
comment
This was fixed in https://github.com/networkx/networkx/pull/7644
comment
Closing the PR as this should be changed upstream :)
comment
Thanks for the contribution! But we already have an open PR which is working on fixing this https://github.com/networkx/networkx/pull/7347 :) 
comment
There is an error with the benchmark action, complaining about `libmambapy`. But that's not the blocker here :) 
comment
Thanks @mohamedrezk122 !
comment
Should we wait for a libpysal release? Or we can skip this particular example for now?
comment
Thanks for the catch @mjschwenne !
comment
Maybe we should also make sure that the parallel implementation is also linked with the docs of these functions here.
comment
@wsh2836741 the quickest way here would be to pip install this branch in your python environment.  ``` pip install https://github.com/dzy49/networkx/archive/feature-for-issue-5949.zip ```
comment
I think I have seen something similar before, not sure about the `segfault` but maybe we need to use `threadpoolctl` here? Maybe tangential but scipy ran into something that could be helpful (?) https://github.com/scipy/scipy/pull/14441
comment
Hmm, rebasing the PR also didn't fix the benchmark unknown commit error. I'll have a look at the benchmark bits later. Merging this in for now! Thanks everyone!!
comment
continued in https://github.com/networkx/networkx/pull/7345
comment
Sorry for the delay in the review @still-n0thing.  Could you update this deprecation notice and also add this to https://github.com/networkx/networkx/blob/main/doc/developer/deprecations.rst so we can keep a track of what to remove when 3.2 comes around :)  Thanks!
comment
Are you using Python 3.9 from the RHEL by any chance? there is indeed some buggy behavior in py3.9 https://github.com/networkx/networkx/issues/7101
comment
Hmm, thanks for the update!  I guess this indeed comes from upstream py3.9 import machinery (https://github.com/python/importlib_metadata/pull/281) which is fixed in py3.10.  The next release will drop py3.9 (https://github.com/networkx/networkx/releases/tag/networkx-3.3rc0) and I'm not sure if it's worth the effort to make a patch release just to get rid of this runtime warning. This is just boilerplate infrastructure around the code, it shouldn't have any functional affect on the main networkx code.  Maybe just ignore this in your pytest run commands? Something like: ``` pytest --pyargs myproject -W error -W ignore::RuntimeWarning ``` I know this isn't an elegant solution but ðŸ¤·   
comment
@eriknw here is a proposal to update the variable names for passing the documentation information from the backend to networkx. What do you think?
comment
Thanks for the detailed report @matthewfeickert!  Yeah this is weird. For RHEL the `nx-loopback` entry point is registered twice during the pip install. Inside the RHEL container: ``` python >>> from importlib.metadata import entry_points >>> entry_points()["networkx.backends"] (EntryPoint(name='nx-loopback', value='networkx.classes.tests.dispatch_interface:dispatcher', group='networkx.backends'), EntryPoint(name='nx-loopback', value='networkx.classes.tests.dispatch_interface:dispatcher', group='networkx.backends')) ```  For the debian one it register the entry point only once as expected: ```python >>> from importlib.metadata import entry_points >>> entry_points()["networkx.backends"] (EntryPoint(name='nx-loopback', value='networkx.classes.tests.dispatch_interface:dispatcher', group='networkx.backends'),) ```  Need to investigate this more.
comment
Just circling back on this, I'm no RHEL expert but I can't reproduce this with python3.11 in the same container btw. (`python3.9.16` issue still persists) ``` $ dnf install -y python3.11-pip $ python3.11 -m venv venv && . venv/bin/activate && python3.11 -m pip --quiet install --upgrade pip setuptools wheel $ python -m pip --quiet install --upgrade 'networkx' && python -m pip freeze | grep networkx && python -c 'import networkx' networkx==3.2.1 ```  and pip registers the entry point properly (only once)  ``` python >>> from importlib.metadata import entry_points >>> entry_points()["networkx.backends"] <stdin>:1: DeprecationWarning: SelectableGroups dict interface is deprecated. Use select. [EntryPoint(name='nx-loopback', value='networkx.classes.tests.dispatch_interface:dispatcher', group='networkx.backends')] ```  Is it possible the packaged python3.9/pip in RHEL 9.2 is buggy itself?
comment
> Redhat will not fix this. > https://issues.redhat.com/browse/RHEL-26149  Not sure what we can do here, py3.9 will be dropped soon in networkx in the next release and seems like there is a quick solution here https://github.com/networkx/networkx/issues/7101#issuecomment-1919737867 if you do plan on using the old versions :)
comment
Thanks!!
comment
I am able to get these errors locally, with a clean environment install of networkx with python3.10
comment
It seems to be erroring out because of a deprecation warning raised in Pandas (@dschult can you update your pandas version locally and try this out?), and it seems like it's transported up to the lazy_import chain.  My local traceback: ``` python File ~/miniconda3/envs/nx5280/lib/python3.10/site-packages/pandas/core/frame.py:9020, in DataFrame.append(self, other, ignore_index, verify_integrity, sort)    8917 def append(    8918     self,    8919     other,    (...)    8922     sort: bool = False,    8923 ) -> DataFrame:    8924     """    8925     Append rows of `other` to the end of caller, returning a new object.    8926    (...)    9013     4  4    9014     """    9015     warnings.warn(    9016         "The frame.append method is deprecated "    9017         "and will be removed from pandas in a future version. "    9018         "Use pandas.concat instead.",    9019         FutureWarning, -> 9020         stacklevel=find_stack_level(),    9021     )    9023     return self._append(other, ignore_index, verify_integrity, sort)  File ~/miniconda3/envs/nx5280/lib/python3.10/site-packages/pandas/util/_exceptions.py:32, in find_stack_level()      27 def find_stack_level() -> int:      28     """      29     Find the first place in the stack that is not inside pandas      30     (tests notwithstanding).      31     """ ---> 32     stack = inspect.stack()      34     import pandas as pd      36     pkg_dir = os.path.dirname(pd.__file__)  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1678, in stack(context)    1676 def stack(context=1):    1677     """Return a list of records for the stack above the caller's frame.""" -> 1678     return getouterframes(sys._getframe(1), context)  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1655, in getouterframes(frame, context)    1653 framelist = []    1654 while frame: -> 1655     frameinfo = (frame,) + getframeinfo(frame, context)    1656     framelist.append(FrameInfo(*frameinfo))    1657     frame = frame.f_back  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1629, in getframeinfo(frame, context)    1627 start = lineno - 1 - context//2    1628 try: -> 1629     lines, lnum = findsource(frame)    1630 except OSError:    1631     lines = index = None  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:952, in findsource(object)     949     if not (file.startswith('<') and file.endswith('>')):     950         raise OSError('source code not available') --> 952 module = getmodule(object, file)     953 if module:     954     lines = linecache.getlines(file, module.__dict__)  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:869, in getmodule(object, _filename)     866 # Update the filename to module name cache and check yet again     867 # Copy sys.modules in order to cope with changes while iterating     868 for modname, module in sys.modules.copy().items(): --> 869     if ismodule(module) and hasattr(module, '__file__'):     870         f = module.__file__     871         if f == _filesbymodname.get(modname, None):     872             # Have already mapped this module, so skip it  File ~/dev/networkx/networkx/lazy_imports.py:202, in DelayedImportErrorModule.__getattribute__(self, attr)     199 except AttributeError:     200     pass --> 202 raise ModuleNotFoundError(     203     f"Delayed Report: module named '{spec.name}' not found.\n"     204     "Reporting was Lazy -- delayed until module attributes accessed.\n"     205     f"Most likely, {spec.name} is not installed"     206 )  ModuleNotFoundError: Delayed Report: module named 'pydot' not found. Reporting was Lazy -- delayed until module attributes accessed. Most likely, pydot is not installed ```
comment
[Disclaimer: this is the first time I'm doing a deep dive into the lazy_import module!]  Hmm, I'm not sure what's going on here:  I don't think it has anything to do with scipy or any other package.  This issue pops up from [a line in pandas `find_stack_level`]( https://github.com/pandas-dev/pandas/blob/c0bdeb4c10a74b7837820e564ed9cad406a83c5a/pandas/util/_exceptions.py#L32 ), where it's inspects the stack. (that bit of code has been removed in https://github.com/pandas-dev/pandas/pull/45247)  If I try to inspect the stack after just importing `networkx` (assuming one of the `lazy_import`s module isn't present in the env) ``` python In [1]: import networkx as nx  In [2]: import inspect  In [3]: inspect.stack() --------------------------------------------------------------------------- ModuleNotFoundError                       Traceback (most recent call last) Input In [3], in <module> ----> 1 inspect.stack()  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1678, in stack(context)    1676 def stack(context=1):    1677     """Return a list of records for the stack above the caller's frame.""" -> 1678     return getouterframes(sys._getframe(1), context)  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1655, in getouterframes(frame, context)    1653 framelist = []    1654 while frame: -> 1655     frameinfo = (frame,) + getframeinfo(frame, context)    1656     framelist.append(FrameInfo(*frameinfo))    1657     frame = frame.f_back  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1625, in getframeinfo(frame, context)    1622 if not isframe(frame):    1623     raise TypeError('{!r} is not a frame or traceback object'.format(frame)) -> 1625 filename = getsourcefile(frame) or getfile(frame)    1626 if context > 0:    1627     start = lineno - 1 - context//2  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:829, in getsourcefile(object)     827     return filename     828 # only return a non-existent filename if the module has a PEP 302 loader --> 829 module = getmodule(object, filename)     830 if getattr(module, '__loader__', None) is not None:     831     return filename  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:869, in getmodule(object, _filename)     866 # Update the filename to module name cache and check yet again     867 # Copy sys.modules in order to cope with changes while iterating     868 for modname, module in sys.modules.copy().items(): --> 869     if ismodule(module) and hasattr(module, '__file__'):     870         f = module.__file__     871         if f == _filesbymodname.get(modname, None):     872             # Have already mapped this module, so skip it  File ~/dev/networkx/networkx/lazy_imports.py:202, in DelayedImportErrorModule.__getattribute__(self, attr)     199 except AttributeError:     200     pass --> 202 raise ModuleNotFoundError(     203     f"Delayed Report: module named '{spec.name}' not found.\n"     204     "Reporting was Lazy -- delayed until module attributes accessed.\n"     205     f"Most likely, {spec.name} is not installed"     206 )  ModuleNotFoundError: Delayed Report: module named 'pydot' not found. Reporting was Lazy -- delayed until module attributes accessed. Most likely, pydot is not installed ```  as soon as `pydot` is installed, everyone seem to be happy. I'm not sure if this is intended behavior.
comment
Also the `inspect.stack()` doesn't throw any error on the `main` branch, so it's coming in from some code in this PR
comment
It's not just pydot, if I remove scipy, numpy it starts complaining about that too. After removing `scipy` from the env ``` python In [1]: import inspect  In [2]: import networkx as nx  In [3]: inspect.stack() --------------------------------------------------------------------------- ModuleNotFoundError                       Traceback (most recent call last) Input In [3], in <module> ----> 1 inspect.stack()  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1678, in stack(context)    1676 def stack(context=1):    1677     """Return a list of records for the stack above the caller's frame.""" -> 1678     return getouterframes(sys._getframe(1), context)  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1655, in getouterframes(frame, context)    1653 framelist = []    1654 while frame: -> 1655     frameinfo = (frame,) + getframeinfo(frame, context)    1656     framelist.append(FrameInfo(*frameinfo))    1657     frame = frame.f_back  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:1625, in getframeinfo(frame, context)    1622 if not isframe(frame):    1623     raise TypeError('{!r} is not a frame or traceback object'.format(frame)) -> 1625 filename = getsourcefile(frame) or getfile(frame)    1626 if context > 0:    1627     start = lineno - 1 - context//2  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:829, in getsourcefile(object)     827     return filename     828 # only return a non-existent filename if the module has a PEP 302 loader --> 829 module = getmodule(object, filename)     830 if getattr(module, '__loader__', None) is not None:     831     return filename  File ~/miniconda3/envs/nx5280/lib/python3.10/inspect.py:869, in getmodule(object, _filename)     866 # Update the filename to module name cache and check yet again     867 # Copy sys.modules in order to cope with changes while iterating     868 for modname, module in sys.modules.copy().items(): --> 869     if ismodule(module) and hasattr(module, '__file__'):     870         f = module.__file__     871         if f == _filesbymodname.get(modname, None):     872             # Have already mapped this module, so skip it  File ~/dev/networkx/networkx/lazy_imports.py:202, in DelayedImportErrorModule.__getattribute__(self, attr)     199 except AttributeError:     200     pass --> 202 raise ModuleNotFoundError(     203     f"Delayed Report: module named '{spec.name}' not found.\n"     204     "Reporting was Lazy -- delayed until module attributes accessed.\n"     205     f"Most likely, {spec.name} is not installed"     206 )  ModuleNotFoundError: Delayed Report: module named 'scipy' not found. Reporting was Lazy -- delayed until module attributes accessed. Most likely, scipy is not installed ``
comment
> The cost of doing this is a small pollution of sys.modules!!!  I'm not a 100% sure but I think this is the issue! By polluting sys.modules, this seems to have broken a bunch of internal tooling in the python language itself. The module generated via `make_delayed_import_error_module` doesn't seem to be setting the module in `sys.modules` properly.
comment
It's locally giving the stack error for me on py3.9 too :/ (I'm using MacOS btw)  In a clean python 3.9 env with nothing installed and running this bit of code inside networkx directory ``` python Python 3.9.10 | packaged by conda-forge | (main, Feb  1 2022, 21:27:48) [Clang 11.1.0 ] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import inspect >>> import networkx as nx >>> inspect.stack() Traceback (most recent call last):   File "<stdin>", line 1, in <module>   File "/Users/ms/miniconda3/envs/nx5280-py39/lib/python3.9/inspect.py", line 1554, in stack     return getouterframes(sys._getframe(1), context)   File "/Users/ms/miniconda3/envs/nx5280-py39/lib/python3.9/inspect.py", line 1531, in getouterframes     frameinfo = (frame,) + getframeinfo(frame, context)   File "/Users/ms/miniconda3/envs/nx5280-py39/lib/python3.9/inspect.py", line 1501, in getframeinfo     filename = getsourcefile(frame) or getfile(frame)   File "/Users/ms/miniconda3/envs/nx5280-py39/lib/python3.9/inspect.py", line 709, in getsourcefile     if getattr(getmodule(object, filename), '__loader__', None) is not None:   File "/Users/ms/miniconda3/envs/nx5280-py39/lib/python3.9/inspect.py", line 746, in getmodule     if ismodule(module) and hasattr(module, '__file__'):   File "/Users/ms/dev/networkx/networkx/lazy_imports.py", line 202, in __getattribute__     raise ModuleNotFoundError( ModuleNotFoundError: Delayed Report: module named 'numpy' not found. Reporting was Lazy -- delayed until module attributes accessed. Most likely, numpy is not installed ```  This error goes away if all the lazy_imports are installed in the environment.  ``` python Python 3.9.10 | packaged by conda-forge | (main, Feb  1 2022, 21:27:48) [Clang 11.1.0 ] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import inspect >>> import networkx as nx >>> inspect.stack() [FrameInfo(frame=<frame at 0x10f6fb040, file '<stdin>', line 1, code <module>>, filename='<stdin>', lineno=1, function='<module>', code_context=None, index=None)] ``` 
comment
There is indeed a rule https://docs.astral.sh/ruff/rules/is-literal/ that should catch this.
comment
Could you also give an exact traceback of the error? This error is probably coming from one of the many dependencies in the `requirements/default.txt`, `requirements/test.txt`, `requirements/developer.txt` that are being installed with that command.
comment
I'm not even sure if `python3.10 -m pip install -e . 3.2.1` should work?  Maybe you could try git check out the 3.2.1 tag and then install? ``` $ git checkout networkx-3.2.1 $ python3.10 -m pip install -e . ```
comment
woops sorry for the mess @rossbar, I would love to see this move forward, fixed the conflicts to get the CI working again.  I also wanted to see if it's possible to start using jupyterlite to setup our tutorial with in browser interactivity. It still requires a .ipynb notebook for now but myst-nb is closer to a notebook (in my head) than nb2plots.  Plus well I personally like .md more than .rst :)
comment
Closing this as https://github.com/networkx/networkx/pull/7221 uses the pytest native fixture to remove tempfile. Thanks for your work on this @danieleades !
comment
The test failures are fixed by https://github.com/networkx/networkx/pull/7203
comment
Let's keep only one pull request open https://github.com/networkx/networkx/pull/7177 :)
comment
There is already https://github.com/networkx/networkx/pull/7155? Is this supposed to be a different algorithm?
comment
@navyagarwal if you still have the bandwidth could you add the deprecation warnings so we can push this as part of v3.3. Thanks!
comment
thanks @dschult @navyagarwal !
comment
> Please let me know if I should add any tests for these new NodeNotFound exceptions or mention them in the Raises sections. I didn't add any because it seemed excessive.  Please do! It's generally a good idea to cover these exceptions in tests to make sure you can atleast hit the codeblocks. This may not seem that useful right now, but 10 years from now if someone is refactoring the code it should help them :)
comment
Hmm, which package manager is this? We only package pypi and conda-forge.
comment
Yeah thanks for the report! It's just weird our tests (or us) didn't catch this, we had similar issues https://github.com/networkx/networkx/issues/7064, https://github.com/networkx/networkx/issues/7032 before which were fixed.  Which linux distribution is this? How did you arrive at this step? (just trying to debug this)
comment
This was annoying to debug, but the reason of failure is because of the explicit type checks of the graph objects.  > Use G.is_multigraph() instead of using type(G).  Using this should fix the dispatch tests :)
comment
@lovre the link is updated now on the latest branch doc build. The "stable" docs are updated only when we make a release :)  https://networkx.org/documentation/latest/reference/algorithms/community.html#module-networkx.algorithms.community.label_propagation 
comment
> This change can't be made quite yet however as itertools.pairwise [was only added in Python 3.10](https://docs.python.org/3/library/itertools.html#itertools.pairwise), so NX needs to wait until 3.10 is the minimum supported version.  Well that's going to be [atleast April 2024](https://numpy.org/neps/nep-0029-deprecation_policy.html) :)  PS: While typing this I thought ah 4 years away but well ðŸ˜… 
comment
BTW it looks like the stdlib `pairwise` doesn't do the cyclic bit and our implementation does. So I think we still need to keep this around :/
comment
I think we need to keep our util function around as our `pairwise` also implements cyclic version. We would need a utility function in any case.
comment
I agree with @dschult we shouldn't really expose every little knob of matplotlib, it will be hard to manage that. The above code example should achieve the same end output. I'll close this PR. Thanks!
comment
Hi @IlanaShukhman, Thanks for your contribution! And welcome to NetworkX :)  > Take a look at the CONTRIBUTING.rst guide for basics. You will need doc_strings to match the sphinx format that our other functions do, an entry in the networkx docs to point to your function (once we figure out where it should be). It's be good to have examples in the doc_strings. You should separate the tests into another testing module. Your code should have the typing removed. You should make helper functions names start with an underscore (they are private functions) and you should list the functions you want as public functions in a variable called __all__. See the other modules to use as a template.  If you need any help with any of this please feel free to ping me, we can do a pair programming session over zoom/google hangouts if that helps you :)
comment
This hasn't been touched in a while, thanks for your work on this @IlanaShukhman! I'll go ahead and close this for now. Please feel free to submit a new PR by following the guidelines at https://networkx.org/documentation/latest/developer/contribute.html, thanks!
comment
Made the changes in https://github.com/networkx/networkx/pull/7162, thanks for opening this @ekohilas !
comment
Make sure to update your networkx version :) 
comment
This hasn't been touched in a while. Thanks for your work @EricPostMaster ! :) I'll close the PR for now.
comment
I'll go ahead and close this PR for now, I don't think we have consensus about the best way of implementing this just yet (or if we should even implement this). Thanks for your work @james-sherrell!
comment
@sharwinbobde is this ready to be reviewed? It's still in "Draft" mode :)
comment
This is indeed probably an upstream issue, a quick fix here is to use a properly ASCII encoded url like  https://github.com/networkx/networkx/blob/9cc8b422a512e7e7819238d597fd6815ec9c1c8e/networkx/algorithms/connectivity/edge_kcomponents.py#L84 or make sphinx links like `` `Wikipedia: Matching <https://en.wikipedia.org/wiki/Matching_(graph_theory)>`_ ``  
comment
Closing this as this isn't networkx specific.
comment
Hmm, the random [test suite cron job is failing](https://github.com/networkx/networkx/actions/runs/7121976155/job/19392211394) as the seed is tripping up `UNEXPECTED EXCEPTION: NetworkXError('Too many iterations in maybe_regular_expander')` error. Should we set a seed that we know will pass?
comment
Thanks for your work on this @vadyushkins !  Do we still want to push this in? @dschult @rossbar 
comment
I'll close this for now, if someone from ETE wants to take this over we can revisit this :)
comment
@LuigiSciarretta a reviewer needs to a label there (I have added one), nothing for you to do there :)
comment
Nope, this needs to be done by the reviewer.  
comment
This looks great! Thanks @lobpcg :)
comment
This hasn't been touched in a while, I'll go ahead and close this. @neocsbee feel free to open a new issue with more details :)
comment
`create_using` is here to stay :) I'll close this issue for now, more conversations can happen in NXEP 3.
comment
There doesn't seem to much detail here about what and how this is failing. Could you turn on logging in the dask cluster to get some more information here? It does seem like the all the processes will try to read the same graph object and that seems to be causing the issue. Dask doesn't really play well with global state (from what I remember) and in the code provided the graph object `G` is in the global state. One other thing you can try is to wrap the graph object with a delayed call to make it "dask aware" https://docs.dask.org/en/stable/delayed-best-practices.html#avoid-repeatedly-putting-large-inputs-into-delayed-calls and then pass that around to dask for computation  > It may also be worth noting that 6 GB seems fairly excessive for my graph object, considering that it "only" has about 1.6 million nodes and 2.4 million edges, and its XML representation is about 300 MB.  It's not excessive as the graph data structure also holds a lot of empty dictionaries if you haven't put in edge attributes. One way of decreasing the memory usage is to use something like `ThinGraph` (search for it in the [documentation here](https://networkx.org/documentation/latest/reference/classes/graph.html)).
comment
I'll go ahead and close this as we don't really have anything particularly actionable from networkx side. Thanks for opening the discussion @ischmidt20 !
comment
The discussion has moved to https://github.com/networkx/nx-parallel/pull/14.
comment
Could you please provide more information here? What's in `net`? There is no way anyone can debug what's going wrong with just `ValueError: too many values to unpack (expected 2)` :)
comment
Yes. I did get that, hmm it's testing on the push commit to main too. 
comment
Thanks for raising the issue, and this will indeed be an issue as the underlying attributes are shallow copies rather than deep copies (which is an expensive operation). This is also the reason networkx usually recommends not touching the graph data structure dictionaries directly with operations like `remove`/`add`. One quick way of fixing this is to use `nx.set_node_attributes` to explicitly state the node attributes. So in the given example if you change the last line from ``` python H.nodes['l2foo']['unconn'].remove('a') ``` to ``` python nx.set_node_attributes(H, {'l2foo': {'unconn': ['b', 'c']}}) ``` it should work as intended.  I'm not too sure if we should be exposing these things via the API or not (like making deepcopy an argument through `union` and other operators). Maybe we should be doing a better job to document usage of  `set_node_attributes`/`set_edge_attributes` more prominently? 
comment
Yeah, this particular issue isn't actionable but we still probably need to have the shallow/deep copy discussion somewhere.
comment
We are almost at the 10 year anniversary of this PR! Thanks for your work on this @francis-shuoch   Sorry about never getting back to this. A lot has changed in networkx in the last 10 years and it would require some effort to make this work and review with the current main branch. Let me know if you are still interested in getting this in! It's totally fine if you don't have the bandwidth. Thanks again for your contribution! 
comment
Thanks for this @joaquincabezas, this should close https://github.com/networkx/networkx/issues/3931 right?
comment
@akshayamadhuri thanks for working on this! Could you please install `pre-commit` on your machine as suggested in https://networkx.org/documentation/latest/developer/contribute.html#development-workflow ? This should fix the linting issues in your PRs :) Thanks!
comment
Thanks for your PRs @akshayamadhuri, could you add tests here? Whenever we add a new function to networkx it should have the corresponding tests. It also helps to have a more clear pull request title. `Update structuralholes.py` doesn't really help us quickly understand what is happening in the PR, something like `Implemented hierarchy metric for structuralholes` quickly gives the reviewers enough context about the changes. Also installing `pre-commit` should catch the linting issues. Thanks again for your work! Feel free to ping here if you have any questions about the development workflow setup :)
comment
You can add the tests to the test_structuralholes.py file in networkx/algorithms/test  
comment
Yes, sometimes PR's fall through the cracks :)  https://networkx.org/documentation/stable/reference/classes/generated/networkx.Graph.neighbors.html#networkx.Graph.neighbors has a better documentation of the `neighbors` function.  The `networkx.neighbors` function just uses `Graph.neighbors(n)`, anyway thanks for pointing this out! We will try to merge the updated docs asap :)
comment
Yeah I think instead of repeating the information we should just add a link to the base Graph class methods. Thanks for working on this @XiaobenYin !
comment
@rossbar this seems to work!, should we pushing to get this merged?
comment
Hmm, this doesn't [seem to work anymore](https://output.circle-artifacts.com/output/job/5690416a-ace0-4e92-94d4-7029761e22ae/artifacts/0/doc/build/html/reference/generated/networkx.generators.classic.complete_graph.html#networkx.generators.classic.complete_graph). Just shows a link to download a python script.
comment
Yup, that did the trick, thanks!
comment
Thanks for your work on this @U-238 but it seems this isn't necessarily the way forward for addressing the `nbunch` ambiguity.
comment
@rossbar I agree, I think we don't necessarily need to add the type information here, then we should be doing this all across the codebase ðŸ˜… I've reverted the commit that added the changes.
comment
@mingxuan-he thanks for the PR!  This hasn't been touched in a while. I'll go ahead and close this. Feel free to send a new PR :) Thanks!
comment
Thanks for the PR @akshayamadhuri, https://github.com/networkx/networkx/pull/6251 already implements this.
comment
This hasn't been updated in a while, I'll go ahead and close this PR. Thanks for your work on this @hector1618 !
comment
Thanks for this @joeleong!  This hasn't been touched in a while and bunch of things have changed inside networkx in the last 7 years! I'll go ahead and close this PR. Thanks again for your contribution!!
comment
Thanks for this @iaciac!  This PR hasn't been touched in a while and will need some effort to make it work with the `main` branch, it's py3.10+ and a bunch of things have changed in networkx over the last 5 years. I'll go ahead and close this PR, feel free to open a new one if you have the bandwidth. Thanks again!
comment
Thanks for your work @aweltsch!  This hasn't been touched in a while. I will go ahead and close this for now. Thanks again for your contributions!
comment
This hasn't been touched in a while and would probably need to be tested with the main branch(been 5 years!). I'll go ahead and close this for now. Please feel free to send in a new PR @dbrnz with the tests! Thanks for your contributions!!
comment
Looks like git has messed up things here ðŸ˜…   Feel free to send in a new PR with the changes if you still have the interest and bandwidth (no worries if you dont!) :) Thanks again for your contributions @harisbal!  
comment
Thanks for your work on this @Temigo!  Unfortunately we haven't reviewed this in a long time, sorry about that! A lot of things have changed in networkx in the last 7 years so we would need to put in some effort to make this PR mergeable.  I think we also need to be a bit conservative in adding new I/O formats in networkx, so the code can be maintainable. I have added this to #7099 that tracks future wishlist/good ideas/maybes and once we have a decision we can move forward with the implementation bits. Thanks again!
comment
Just wanted to revisit this, if we are planning on adding more planar algorithms we should look into this as part of our 4.0 roadmap. This could be one of the new base classes.
comment
> Perhaps that's not worth the tradeoff of adding back 9 more testing jobs!  I am +0 on this, we would be able to catch the `importorskip` error just with pypy right?
comment
I think this is "good enough" for docs for internal Views implementation. Anyone who is using this will have to jump into the codebase anyway. [This PR](https://output.circle-artifacts.com/output/job/10609413-1e77-4938-b3bb-2491c01d7744/artifacts/0/doc/build/html/reference/classes/generated/networkx.classes.coreviews.FilterMultiAdjacency.html#networkx.classes.coreviews.FilterMultiAdjacency) gives a good enough starting point (IMO) if someone ends up on the documentation page of `Filter*View`, definitely an improvement over a [blank doc page](https://networkx.org/documentation/stable/reference/classes/generated/networkx.classes.coreviews.FilterMultiAdjacency.html#networkx.classes.coreviews.FilterMultiAdjacency).
comment
Thanks @akshayamadhuri!
comment
This was addressed in https://github.com/networkx/networkx/pull/6973, thanks for the PR @khushishikhu 
comment
This is an API change. Should we do the deprecation workflow?
comment
This one was tricky to debug. At first I thought there was something going wrong with scopes of the `graph` variable but the problem here is that you are creating a graph copy `G` and `graph` and mixing up iterations over them. For example there is an edge between `P1020914_23503` and `P1020914_23502`. When you remove `P1020914_23502` from `graph`, the object `G` doesn't know that it should remove it too as it's an independent copy. This code will add back the node `P1020914_23502` through the code `graph.add_edge(eid, f'{node}_{i}_exploded')` as `eid` will be `P1020914_23502` when `P1020914_23503` is `node`.  If you want to debug locally add this:  ``` python         for _, eid in edges:             # add exploded edges             if 'P1020914_23502' == eid:                 print('P1020914_23502 in graph:', graph.has_node('P1020914_23502'))             graph.add_node(f'{node}_{i}_exploded', **node_attr)             graph.add_edge(eid, f'{node}_{i}_exploded')             if 'P1020914_23502' == eid:                 print('P1020914_23502 in graph:', graph.has_node('P1020914_23502'))             relabel_mapping.update({f'{node}_{i}_exploded': f'{node}'})             i += 1         # delte the node ```
comment
Should we wait to merge this till we have made a decision on a 3.2 patch release?
comment
Setting the env var `PYTHONWARNINGS=error` reproduces this on the `3.2` tagged commit, I haven't looked deep into non-pip/conda build processes but I think we should make a quick patch `3.2.1` release.  ```python (play3.12) âžœ  networkx git:(networkx-3.2) PYTHONWARNINGS=error python Python 3.12.0 | packaged by conda-forge | (main, Oct  3 2023, 08:36:57) [Clang 15.0.7 ] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import networkx Traceback (most recent call last):   File "<stdin>", line 1, in <module>   File "/Users/ms/dev/networkx/networkx/__init__.py", line 42, in <module>     from networkx import algorithms   File "/Users/ms/dev/networkx/networkx/algorithms/__init__.py", line 37, in <module>     from networkx.algorithms.operators import *   File "/Users/ms/dev/networkx/networkx/algorithms/operators/__init__.py", line 3, in <module>     from networkx.algorithms.operators.product import *   File "/Users/ms/dev/networkx/networkx/algorithms/operators/product.py", line 347     """Returns the specified power of a graph.     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SyntaxError: invalid escape sequence '\ ' >>>  ```  
comment
+1 on including everything but the 3.9 support drop.
comment
The tests have passed, I guess we can tag the last commit on https://github.com/networkx/networkx/tree/v3.2 as `networkx-3.2.1` and pypi publish action should take care of it right?
comment
I fixed the min python versions https://github.com/conda-forge/networkx-feedstock/pull/52, but I still need to patch the repo-feedstocks so this doesn't show up. I'll send in a PR later today. We need to turn off auto-merges on networkx conda-forge feedstocks.
comment
I have created a repo-data-patch https://github.com/conda-forge/conda-forge-repodata-patches-feedstock/pull/578 which should fix this issue. Thanks for the detailed report @jeremyleung521!
comment
>  The problem is in networkx/readwrite/adjlist.py -> parse_adjlist  `parse_adjlist` is supposed to read graph adjacency list representation. I'm not sure if we should be supporting single isolated nodes.  > I want to add a PR for replacing line with line.strip(), but I dont have permission.  You don't need permission to send a PR :) You can setup a local environment using the contributor guide: https://networkx.org/documentation/latest/developer/contribute.html
comment
Looks interesting @hagberg will be happy to take this up. :) 
comment
@hagberg Should we return self loops in the graph power operation. 
comment
@jfinkels While calculating the power graph, the kth power of G has vertices adjacent if the **distance** between them is less than equal to k. And **distance** is the shortest path between two vertices. While calculating number of walks this implementation has considered a walk from 0->1->0 having a distance of 2, but the shortest distance from the vertex 0 to vertex 0 is zero.  For example  ``` python G=nx.path_graph(4) pow(G,2).edges() should return [(0,0),(1,1),(2,2),(3,3),(0,1),(1,2),(2,3),(0,2),(1,3)]  pow(G,3).edges() should return [(0,0),(1,1),(2,2),(3,3),(0,1),(1,2),(2,3),(0,2),(1,3),(0,3)] ```  http://en.wikipedia.org/wiki/Graph_power http://en.wikipedia.org/wiki/Distance_(graph_theory) 
comment
The code suggested by @hagberg works perfectly fine for Graphs, I am working on modifying the single_source_shortest_path for taking into account MultiGraphs. 
comment
@jfinkels Your implementation considers a walk from node 0->1->0 as walk of length 2, but the distance between a node to itself is always zero. Thus you have a self loop even though you are checking for nodes at a distance of only two. d(u,v) = 0 if u==v 
comment
@jfinkels I found this on wikipedia: If A is an adjacency matrix for the graph, **modified to have nonzero entries on its main diagonal**, then the nonzero entries of Ak give the adjacency matrix of the kth power of the graph, from which it follows that constructing kth powers may be performed in an amount of time that is within a logarithmic factor of the time for matrix multiplication.  Can you point me towards the definition you are using? 
comment
@dschult In all definitions I read, it explicitly states that it is the distance not the number of walks :/  I agree with @jfinkels for using matrix operations but it is on the modified adjacency matrix.   
comment
Should we include a power function for MultiGraphs, I couldn't find any literature on power of MultiGraphs.  @dschult For excluding self loops we can modify @hagberg code to:  ``` python import networkx as nx from itertools import izip_longest def pow(G,k):     H = nx.Graph()     for n in G:         p = nx.single_source_shortest_path_length(G,n,cutoff=k)         for key,value in p.items():       #remove self loops              if value == 0:                  del p[key]         H.add_edges_from(izip_longest([n],p,fillvalue=n))     return H  if __name__=='__main__': #    G = nx.cycle_graph(5)     G = nx.grid_2d_graph(5,3)     H = pow(G,2)     print H.edges() ```  Should I send in a patch with tests and documentation? 
comment
@dschult I could't find anything on power of MultiGraphs, so I think that self loops should be ignored along with MultiGraphs (power should only be defined for graphs) . And @jfinkels has renamed the function to `walk_power` instead of `pow`. 
comment
@dschult @jfinkels #1399  
comment
Hmmm. Shouldn't ruff be doing this already? It also implements pyupgrade rules. 
comment
I am not able to reproduce this (tried both pip and conda). How exactly are you setting up the environment?
comment
I'm able to confirm that pycodestyle does catch this `SyntaxWarning` ``` $ pycodestyle --select W605 $(find /Users/ms/mambaforge/envs/play3.12/lib/python3.12/site-packages/networkx/ -name "*.py")  /Users/ms/mambaforge/envs/play3.12/lib/python3.12/site-packages/networkx//algorithms/operators/product.py:386:12: W605 invalid escape sequence '\ ' ```  It is weird none of our tests is able to catch this and I can't reproduce this locally.
comment
Another data point: this warning pops up if I try with pixi too.
comment
Networkx 3.2 requires python 3.9+. Please update your python version before installing networkx 3.2 :) 
comment
Just in case you haven't seen it before https://ericmjl.github.io/nxviz/ also implements hive and arc plots.
comment
> though I'm not sure whether a lot of attention has been paid to 3.12 yet.  Currently ASV with conda isn't setup to test against python pre releases. They aren't uploaded to conda-forge so we probably need to built them first while running the test. I'll try to look into this.
comment
Interestingly I wasn't able to catch this in the asv run: http://146.190.175.223:8080/#benchmark_classes.GraphBenchmark.time_add_edges_from?p-graph_type='DiGraph'  python3.12 doesn't seem too out of the ordinary. I'll look a bit more into this. 
comment
I think we can go ahead and close this issue, it's captured upstream on the cpython issue tracker. Thanks for bringing this up @chrisgmorton!
comment
continued in https://github.com/networkx/networkx/pull/7019 
comment
For the style/format test we use `black` to format the file. So you install it locally and It will automatically reformat the file accordingly to make the CI happy.  You can install black with `pip install black` and and then execute `$ black networkx/algorithms/bipartite`. This will reformat the files and then push the changes to GitHub.
comment
You can add that in the parameters section, something like https://github.com/networkx/networkx/blob/c08ae3af1656a449c803565924669299bd308272/networkx/algorithms/non_randomness.py#L30-L31
comment
> Interesting idea. What would you want the linked docs to show? Implementation? So far, the only docs that backends have are the repositories and now the networkx docs.  I'm not too sure how we should bring these things together. Should the backends really have sphinx docs? Like graphblas, and cugraph themselves yes should have docs, but should the translation layer `nx-*` too?
comment
@rossbar could you add this to https://github.com/networkx/networkx/blob/main/doc/release/release_dev.rst too? 
comment
Thanks @dschult!
comment
Yes, I guess we should just straight out remove this function? We can raise an informative error which tells the user about the buggy behavior?
comment
Shouldn't we also install no deps cugraph or graphblas to test out the doc building? This also means the change needs to happen on the backend side first 
comment
Hmm that looks nice but would sphinx be happy rendering these custom numpy doc strings blocks? Maybe we could add admonitions https://pydata-sphinx-theme.readthedocs.io/en/stable/examples/kitchen-sink/admonitions.html to make them pop on the rendered doc site? 
comment
> I got the idea looking at sympy discussions around this; see the changed linked to here: https://github.com/sympy/sympy/issues/15370#issuecomment-428731466  lol
comment
I agree we should let users decide this bit. We should also update the error raised in line 106-108, there is no default datetime type anymore.
comment
The button should work on the latest version https://networkx.org/documentation/latest/index.html to move between the latest and stable release.  As soon as 3.2 is released it will work on the stable release too.
comment
(not an expert on this) Don't we also need to tell sphinx to look for this json file https://pydata-sphinx-theme.readthedocs.io/en/stable/user_guide/version-dropdown.html#configure-switcher-json-url ?
comment
Sounds good, merging this as CI failures are unrelated.
comment
Should we add this information to the deprecation warning of `join` too? or maybe it's TMI.
comment
There is no need to assign issues, please open a pull request whenever you are ready :)
comment
Thanks for opening this up @joyemang33! This is making NetworkX more robust :)
comment
> Should I create a PR for this potential issue and let it return a good exception?  Yes please!! Keep these issues coming :)
comment
> But that doesn't help figure out why this is working on Ubuntu and working on Python 3.11 but not working on Ubuntu with Python 3.11.  The failing test is coming from the dispatching test case, not the usual pytest case.  Before the last commit, the function was called with just `nx.kemeny_constant(G)` in the test suite and the current setup will only copy over the "weight" attributes to the `LoopbackGraph` if the weight attribute is specifically passed in the function call `nx.kemeny_constant(G, weight='weight')`. The error was fixed because the function signature was changed in the last commit.  One way to make sure that all edge attributes are preserved is to use  `preserve_edge_attrs` with the dispatch decorator. ``@nx._dispatch(edge_attrs="weight", preserve_edge_attrs=True)`` but we shouldn't really need to.  But anyway I think the dispatching test was able to find this (yay!) even though it's not super straight forward to debug. I'm not sure how exactly we should be making it easier for new contributors to understand this bit ðŸ˜…
comment
> But why did only the Ubuntu test with Python 3.11 fail? If that test handles the loopback differently, maybe we can name the test somehow to indicate that it is testing the loopback feature. ??  We only test with py3.11 + ubuntu for dispatch ðŸ™ƒ
comment
> But it would already be a great help if networkx.release would not require this attribute.  This file doesn't exist anymore. Would this fix the issue already with [PyOxidizer](https://pyoxidizer.readthedocs.io/en/stable/)?  I have also created https://github.com/networkx/networkx/pull/6936 which removes use of `__file__` from other places in our codebase.
comment
@Lukong123 just a gentle ping, let me know if you have the time to add the non graphical sequence examples in this PR. If not, no worries we can do a new PR with those examples :)
comment
> Hello, please is it still open to to work on this.  Yes! Please feel free to add more examples here.
comment
@dschult Let's create a good first issue out of it :)
comment
Thanks @Lukong123!
comment
@navyagarwal do you think this accurately covers the cases you brought up in https://github.com/networkx/networkx/issues/6626#issue-1659434109?
comment
> Could this please be reviewed before it goes stale and is automatically closed?  BTW we don't do that, it just stays on and on and on in the back log. Not sure if that's better ðŸ™ƒ
comment
> It's the minimal change that makes graphs_equal(adjacency_graph(adjacency_data(G)), G) true, which I am strongly opinionated in favour of.  Sorry for the delay in getting this reviewed! I agree we should preserve this round trip. Thanks!
comment
@haricash please go ahead!  The examples section can be improved by adding more examples which show the use of other arguments like `dtype`, `weight`, `nonedge`. We don't necessarily need to explain what adjacency matrix is and why it is useful in the examples section of  `to_numpy_array`. Just examples of how to convert a NetworkX graph to numpy array.  Do let us know if you have any other questions about this :)  You can read more about our development processes and some FAQs on the` Developer` page of our website:  [New Contributor FAQ](https://networkx.org/documentation/latest/developer/new_contributor_faq.html) [Contributor Guide](https://networkx.org/documentation/latest/developer/contribute.html) 
comment
Here we are talking about https://networkx.org/documentation/stable/reference/generated/networkx.convert_matrix.to_numpy_array.html, if you go down to the examples section you will see that the example which is uses a `MultiGraph` doesn't use other available arguments like `multigraph_weight`, `dtype`, etc. The example for MultiGraph should be improved by adding the other arguments.  It shouldn't be a jupyter notebook, the example needs to be added to the function documentation  of `to_numpy_array`.  https://github.com/networkx/networkx/blob/fd52aa52ada0c08dfc25fc749f08589d7b734c00/networkx/convert_matrix.py#L1368-L1390
comment
The docs were improved in https://github.com/networkx/networkx/pull/5451 thanks everyone!
comment
You need to add `is_tournament` to the main namespace. That means if someone does `import networkx as nx`, and then they do `nx.is_` and hit a tab for autocomplete, `nx.is_tournament` should show up.  Currently someone needs to first import the `tournament` subpackage and then they will be able to use the `is_tournament` function. To fix this you need to go look at the `__init__.py` files in `networkx/__init__.py` and `tournament/__init__.py` 
comment
I think we can close this one as we dropped py3.6 a long time back.
comment
> BTW - Should I click the "resolve" button on the above comments?  Yes please!  > (This is my first PR in GitHub... I guess my newbieness is showing... :-))  No worries. Hopefully many more to come :)
comment
@erivlis I made some cosmetic changes https://github.com/erivlis/networkx/pull/1 could you review that? I think the code changes should be fine (they are passing the tests at least.
comment
Thanks for this @joyemang33!  `percolation_centrality` indeed only works if all the nodes have the right node attribute (default is `percolation`). We should catch this and have a better default behavior. Maybe we can just set the same percolation state for all the nodes by default (in which case I think this just becomes betweenness centrality).  In your example if you set the node attribute `percolation` to `1.0` before calling `percolation_centrality` ```python nx.set_node_attributes(G, 1.0, 'percolation') ``` it should work (but this is just betweenness centrality)  Or we should raise an error if the user doesn't provide either a starting `state` or an explicit node attribute?  
comment
``` ssg = nx.subgraph_view(sg, filter_edge=ff) ``` should fix it, python will try to map `ff` to `filter_node` so we need to be explicit.
comment
I think we should look into this API again. Should we force keyword only for `subgraph_view` with a deprecation cycle? We can probably get that in 3.2 @dschult 
comment
`combinatorial_embedding_to_pos` takes in a `nx.PlanarEmbedding` object not a standard graph object. I'm not sure if we should be doing a type check and raising an error? It says in the doc strings that `embedding` should be a `nx.PlanarEmbedding`.
comment
Yeah this one is tricky. It is a directed graph and when you add a self loop to a directed graph it kind of breaks some of the assumptions. Like in the following example it will duplicate the edge `(1, 1)` when we try to go through `out_edges` and `in_edges` of a directed graph.  ``` python In [1]: import networkx as nx  In [2]: G = nx.DiGraph()  In [3]: G.add_edge(1, 1)  In [4]: G.out_edges() Out[4]: OutEdgeView([(1, 1)])  In [5]: G.in_edges() Out[5]: InEdgeView([(1, 1)])  In [6]: G.number_of_edges() Out[6]: 1 ```  I'm not sure what should be the right answer here. @dschult maybe?  PS: this will break even for `copy=True`.  ``` python >>> nx.contracted_nodes(G1, 2, 1, copy=True).number_of_edges() 2 ```
comment
Yeah, I think the only "bug" (or a "feature") here is how we treat selfloop edges for contracted nodes. Maybe we can just add that bit of info in the docs?
comment
Thanks @Carreau !
comment
@dschult  I pushed a commit that uses set of comparison. 
comment
I've created https://github.com/networkx/networkx/issues/6906 to work further on this, I think we can merge this in :)
comment
> I see. But node labels starting from 0 is not the convention in most math books, including [Wikipedia](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence).  fwiw, the paper cited in the references of the implementation (https://www.scirp.org/journal/paperinformation.aspx?paperid=532) does use 0 to n - 1. Should be print a warning/error about this? Maybe catch the error when looking for orphans.
comment
Hmm, it was commented out 12 years back https://github.com/networkx/networkx/commit/bccd58d70a985f6c25c6b32c209b6497a5f43828 ðŸ˜…  I guess we can remove the kwarg outright.
comment
I think we can close this issue on the networkx issue tracker. If this does happen this needs to happen in ipython.  Feel free to re-open this if anyone feels strongly about it :)
comment
The graph above does have `:`. The `contracted_nodes` function creates a `contraction` attribute which has a dictionary inside of it  ``` python In [14]: G.nodes[10] Out[14]: {'id': 10,  'text': 'Food and Agriculture Organization',  'lemma': 'Food and Agriculture Organization-ORG',  'upos': 'ORG',  'xpos': 'SP',  'head': 7,  'deprel': 'nmod',  'start_char': 59,  'end_char': 92,  'contraction': {13: {'id': 13,    'text': 'Organization',    'lemma': 'Organization',    'upos': 'PROPN',    'xpos': 'SP',    'head': 12,    'deprel': 'flatname',    'start_char': 80,    'end_char': 92},   12: {'id': 12,    'text': 'Agriculture',    'lemma': 'Agriculture',    'upos': 'PROPN',    'xpos': 'SP',    'head': 10,    'deprel': 'conj',    'start_char': 68,    'end_char': 79}},  'custcol': 'palegreen'} ```  and when we try to stringify it https://github.com/networkx/networkx/blob/9256ef670730b741105a9264197353004bd6719f/networkx/drawing/nx_pydot.py#L253 it creates a string with the value `{13: {'id': 13, 'text': 'Organization', 'lemma': 'Organization', 'upos': 'PROPN', 'xpos': 'SP', 'head': 12, 'deprel': 'flatname', 'start_char': 80, 'end_char': 92}, 12: {'id': 12, 'text': 'Agriculture', 'lemma': 'Agriculture', 'upos': 'PROPN', 'xpos': 'SP', 'head': 10, 'deprel': 'conj', 'start_char': 68, 'end_char': 79}}` as a string.  I'm not sure what's the right thing to do here. Should we allow users to have a node/edge attributes with no limit on what goes in the attribute dictionary? I am not a 100% sure if there is a direct translation from `{'attribute' : {'internal_dict_of_attribute`: .....}}` to GraphViz.
comment
`christofides` function should be linked to the function definition too now. Thanks @Transurgeon!
comment
BTW I was able to run these changes with grapblas as a backend with: ``` bash $ pytest --backend=graphblas networkx ... ... ==== 2263 passed, 11 skipped, 2955 xfailed, 3 warnings in 70.45s (0:01:10) ===== ```  ```bash $ pytest --backend=graphblas --fallback-to-nx networkx ... ... ====== 5197 passed, 11 skipped, 5 xfailed, 16 xpassed, 7 warnings in 64.02s (0:01:04) ===== ```
comment
Thanks @eriknw !!
comment
There seems to be unintended change by this PR. All the dispatched functions are picking up `<networkx.utils.backends._dispatch object>` in their sphinx docs now. You can check https://networkx.org/documentation/latest/search.html?q=networkx.utils.backends._dispatch+object  
comment
~~The issue seems to be coming from~~ https://github.com/networkx/networkx/blob/99a925f695080787d077f620972c6552c4b0b4ba/networkx/drawing/nx_pylab.py#L700 ~~when there are multiple edges between 2 nodes. The local copy of `edge_color` is overwritten by this line and it messes up the subsequent `edge_color`.~~  Ignore this, I was wrong here.
comment
Thanks for working on this @dtekinoglu!  I'll close this for now and we can use https://github.com/networkx/networkx/issues/3813 as the tracking issue.
comment
Thanks for your work on this @navyagarwal! I'll close this for now and we can use https://github.com/networkx/networkx/issues/3813 as the tracking issue.
comment
circleCI failure seems unrelated.
comment
Thanks for starting this up @aaronzo!!  Let's continue this in https://github.com/networkx/networkx/pull/6840 :)
comment
Let's continue this in https://github.com/networkx/networkx/pull/6840
comment
Currently nb2plots doesn't work with sphinx 7 https://github.com/matthew-brett/nb2plots/issues/26
comment
Hmm, maybe we should just run this in the .github/ directory https://github.com/networkx/networkx/blob/909c159fd52230ea597eadda21cc6111e062d02f/.github/dependabot.yml#L10 ?  @jarrodmillman 
comment
ah, sure.  That's sounds fine by me :)
comment
@rossbar we should also revert https://github.com/networkx/networkx/pull/6852 here probably.
comment
Should we keep the exclude pin on the "broken" scipy versions? It's possible for some reason the pip/conda solver resolves to 1.11.0 or 1.11.1 which will break networkx in users environment. We can remove that pin once we are scipy >1.12
comment
I would vote to keep 1.11.0 in there, it can still be downloaded from pypi/conda. We can clean it up all together once we are scipy>1.12
comment
This should be fixed by https://github.com/networkx/networkx/pull/6857
comment
`G1` and `G2` are isomorphic graphs as you are adding the same edges multiple times. Both `G1` and `G2` only has 2 edges. ``` python In [7]: G1.edges() Out[7]: EdgeView([(1, 1), (2, 2)])  In [8]: G2.edges() Out[8]: EdgeView([(1, 1), (2, 2)]) ``` Adding the same edge again just overwrites the previous edge, it doesn't add a new edge for a `Graph` object.  If you want to have multiple edges between 2 nodes in a graph you can use `MultiGraph`, and in that case `vf2pp_is_isomorphic` would give you `False` for this example.  ``` python In [9]: G1 = nx.MultiGraph()  In [10]:  G1.add_edges_from([(1, 1), (1, 1), (1, 1), (2, 2)]) Out[10]: [0, 1, 2, 0]  In [11]: G2 = nx.MultiGraph()  In [12]:  G2.add_edges_from([(1, 1), (1, 1), (2, 2), (2, 2)]) Out[12]: [0, 1, 0, 1]  In [13]: nx.vf2pp_is_isomorphic(G1, G2 ,node_label=None) Out[13]: False ```
comment
@j6k4m8 just wanted to check in regarding this :) Let me know if you have any bandwidth to finish this up, it's almost there!
comment
Hmm, for `number_of_walks` I don't think it make senses to add `weight` to it. The matrix power of a weighted adjacency matrix will just give the product of the weights on the path. Not sure if that means anything (it's definitively not number of walks).
comment
> Agreed. This was not done in https://github.com/networkx/networkx/pull/6814. It still needs done, so I unchecked this in the task list in the this issue.  That got in https://github.com/networkx/networkx/pull/6815 :)
comment
Thanks @kraktus for raising this. It should be removed soon.  But it would still be part of the 3.1 release docs as we would need to rebuild them and publish it.
comment
> Do you want this PR split into two: one that adds the @nx._dispatch decorator everywhere, and another that updates the def _dispatch function?  Fine by me too :)  Do you know if the mypy complain has anything to do with this PR?  To make the circleci happy could you also move https://github.com/networkx/networkx/blob/main/doc/reference/classes/index.rst#backends to utils?
comment
I think it's fine to merge this one, the CI fail is due to sphinx version mismatch with the main branch.
comment
We'll be moving to https://github.com/scientific-python/changelist/
comment
Looks like the FancyArrow class still doesn't really support 3d vectors. There does seem a way of creating a custom class to do this https://github.com/matplotlib/matplotlib/issues/22571#issuecomment-1377740045 but I don't think we should be adding this in networkx gallery. Thanks for working on this @cvanelteren!
comment
1.3 is out now https://gexf.net/schema.html plus 1.1 is deprecated.   @boofarzab let me know if you have the bandwidth to fix up this PR (merge conflicts and maybe also deprecate 1.1 support in networkx), if not I can build on top of your PR and get this into networkx :)  Thanks for you contribution!
comment
We need to make sure our gexf parser actually does conform with GEXF 1.3, I'll close this PR and keep #5597 as the tracking issue to check our compatibility with 1.3 
comment
Closing this for now, thanks for opening the PR @ManasviEmmadi!
comment
Thanks for working on this @dPys and getting the conversation started again! One recurrent theme with discussions about adding parallelization in networkx is not adding any dependencies which will make our codebase less readable. This approach really does help with that but in this case we will still need to maintain these parallel implementations inside networkx (like the one presented for `betweenness_centrality`).  I am not sure if you have seen this yet but we have added an experimental plugin backend system, where users can swap in a totally different backend for computations but keep using the networkx API. Some documentation is available at https://networkx.org/documentation/latest/reference/classes/index.html#backends, this was added in #6000. This is currently used with https://github.com/python-graphblas/graphblas-algorithms to dispatch a certain set of algorithms to GraphBLAS.  If we use this plugin infrastructure we can write a new package, let's call it `nx_parallel`. Now this package can have the implementations for parallel networkx code, and we don't even need to worry about the dictionary graph data structure of networkx, backends can have different data structures. They just need to follow certain guidelines like should be able to import and export from networkx graph object and have a `__networkx_plugin__` attribute. This opens up an opportunity to write a much more performant parallel implementation (if anyone fancies that :D )  Just an example of how this will work for a user: ``` python In [1]: import networkx as nx; import nx_parallel  In [2]: G = nx.erdos_renyi_graph(10, 0.5)  # You need to convert your networkx graph object specifically to a parallel graph object In [3]: H = nx_parallel.ParallelGraph(G)   # networkx can take a ParallelGraph object and dispatch it to the dask implementation of betweenness_centrality In [4]: nx.betweenness_centrality(H)   Out[4]:  {0: 0.0,  1: 0.0,  2: 0.0,  3: 0.0,  4: 0.0,  5: 0.0,  6: 0.0,  7: 0.0,  8: 0.0,  9: 0.0} ``` I have made a rough sketch of this package here https://github.com/MridulS/nx_parallel, let me know if this makes sense!  
comment
To test it out locally you can do:  ``` python $ git clone https://github.com/MridulS/nx_parallel $ cd nx_parallel $ pip install -e . ```  You can check if the plugin was installed correctly by inspecting the entry_points metadata withn (works for python3.10+) ``` $ python -c "from importlib.metadata import entry_points; print(entry_points(group='networkx.plugins'))"  ```
comment
Closing this as the discussion has moved to https://github.com/networkx/nx_parallel   Thanks @dPys! 
comment
fixed in https://github.com/networkx/networkx/pull/6791
comment
This is probably coming from our `prettier` pre-commit hook and nothing to do with black. There is indeed an issue that could have happen with Windows based systems https://github.com/pre-commit/mirrors-prettier/issues/18#issuecomment-1135071907 but I can't reproduce/debug this for a linux based one.  Could you please try manually removing prettier pre-commit hook from the .pre-commit-config.yml file in the root directory of networkx? After removing it should look something like this.   ``` repos:   - repo: https://github.com/psf/black     rev: 23.3.0     hooks:       - id: black   - repo: https://github.com/adamchainz/blacken-docs     rev: 1.13.0     hooks:       - id: blacken-docs   - repo: https://github.com/charliermarsh/ruff-pre-commit     rev: v0.0.258     hooks:       - id: ruff         args:           - --fix  ```  Does this bit run for you? 
comment
Also how recent is your OS distribution? Node 18+ prebuilt binaries need a new version of glibc. 
comment
> You have a point there as well. First (well, second) thing I tried was updating glibc. However, I (just now) checked and it turns out that the newest available version for Ubuntu 18.04 is version 2.27.  Yeah unfortunately the latest node versions depend on version 2.28+ https://github.com/nodejs/node/blob/main/BUILDING.md#platform-list, there is indeed a way of overriding the node version in pre-commit  https://pre-commit.com/#overriding-language-version but we shouldn't be doing this in the main networkx repo.   Also ubuntu 18.04 is pretty much EOL https://endoflife.date/ubuntu so I would recommend updating anyway :)  I'll close this issue, thanks for reporting!
comment
Closing this as this is not a CI issue, numpy isn't installed for every run https://github.com/networkx/networkx/pull/6755#issuecomment-1604543925
comment
Thanks for opening this issue!  This has been fixed in https://networkx.org/documentation/latest/reference/algorithms/generated/networkx.algorithms.structuralholes.effective_size.html#networkx.algorithms.structuralholes.effective_size  networkx 2.1 is a pretty old version and I don't think it's worth going and fixing these typos (I'm sure there are a lot more) in all the old published documentation :) 
comment
Just to put this here, the tests failures are unrelated for the prerelease part of the CI. It's failing as there seems to be something wrong with the new scipy rc https://github.com/scipy/scipy/issues/18603  
comment
Thanks @Qudirah!
comment
> But I am interested in having a conversation about why the Graph class in Networkx is allowed to have self-loops. In a lot of sources, particularly CLRS, I have read that self loops are forbidden in an undirected graph. It is also referred to as a simple graph. Whereas both self-loops and parallel edges are allowed in a Multigraph.  > Wouldn't it make more sense to have a graph class in Networkx that does not allow self-loops? Since this conversation has a much broader scope, maybe I can move it to the Discussions tab  A quick point here is that the networkx `Graph` is not a simple graph (and it doesn't really pretend to be one) and there are a lot of competing definitions specifically for self loops (especially for a lot of algorithms). If a user wants to have a simple graph class they can create a graph subclass that adds the constraints. Adding another base class expands the user API by a lot, so we need to be cautious about it :)  But yes, this does sound like a discussion topic :) 
comment
> @MridulS did I do it right? Also, this change will lead to little changes in docs. Would I need to open new PRs for that?  The best way to test that is to do it on you computer. Can you run the following code? ``` python import networkx as nx G = nx.path_graph(4) nx.is_tournament(G) ```  If yes, then you are in the right direction :)
comment
Thanks @Qudirah!
comment
No need to worry about that, there is a token issue affecting all our repos. Should be fixed soon :)
comment
yolo and let's see if it's fixed 
comment
https://github.com/networkx/networkx/commits/main seems to be fixed for now.
comment
For 337 - 341 you need to look at cases where `nan` weights are present in the graph. Have a look at https://github.com/networkx/networkx/blob/8b31e55d5232f5a6b8fe1adeb8c06e97eb3ed993/networkx/algorithms/tree/tests/test_mst.py#L86
comment
Thanks @Qudirah ! If you have time could you go through the other PRs with reviews? No worries if not!
comment
Thanks @salym! I committed the changes proposed by @dschult :)
comment
Yes! Thanks for looking into this and yes you are correct `G._adj[node].items()` will be faster than `G[node].items()`. Please feel free to send in a pull request :)
comment
In the given example it's a multi directed graph. There is no way of going from 0 to 3. Adding an edge from 3 to 0 doesn't mean you can go from 0 to 3 in a directed graph. 
comment
> A simple path only means there is no repeated vertex in the sequence.   Yes, but you can't take the path from 0 to 3 right?  <img width="642" alt="Screenshot 2023-05-24 at 11 36 34 PM" src="https://github.com/networkx/networkx/assets/5363860/43672f31-bde5-4732-9830-e00e6d0b3d57">  There is no way I can go from 0 to 3.  Now if you change your graph and add an edge `g.add_edge(0, 3)` then yes you would have a path from 0 ->3 -> 2.  Does this make sense or am I missing something? :) 
comment
Even the definition there doesn't really say anything about directionality in simple paths.  "For each two consecutive vertices (v_i, v_{i+1}), where (1 \leq i < k), there is an edge e = (v_i, v_{i+1}) that belongs to the set of edges E"  The edge (0, 3) doesn't belong in the edge set.  Is there a specific reference that explicitly state that this example should include 0->3->2 ?
comment
https://algs4.cs.princeton.edu/42digraph/ does state one definition of directed simple path. I can't really find anything on "simple path" for a directed graph, there is literature on directed simple path.  If you really want to ignore the directionality, you can just convert this graph to a MultiGraph and then run `all_simple_paths`.
comment
> nx.all_simple_paths currently outputs all simple directed paths, but not all simple paths.  Yes, and in my head there is no thing as simple path for directed graph. It should just be **simple directed paths**, unless there is a specific resource in literature that defines simple path in a directed graph ignoring directionality.  Even in this definition https://www.baeldung.com/cs/simple-paths-between-two-vertices, the edge (0, 3) is **not** in the edge set (so it doesn't satisfy the third condition). For a directed graph the edge set is an ordered pair. `(3, 0) != (0, 3)`
comment
> You can read here: https://en.wikipedia.org/wiki/Path_(graph_theory)#simple_path  Yeah, and according to this there is no such thing as simple path for directed graph? 
comment
I'll wait for someone else to have a look at this too :)  Thanks for opening the issue!
comment
The dictionary underneath is a node to node mapping, the edges are not added as a key in the dictionary. There is no guarantee that `.edges` would be sorted.   The only guarantee is that the same insertion order will give you the same result. 
comment
Thanks for this, you should be doing just `pre-commit install` in the networkx repo and it should take care of everything related to styling. 
comment
Shouldn't we documenting this for every function which operates on multiple graph like `union_all`, `compose_all`, `compose`, and I'm sure there are others. Doesn't sound that sustainable ðŸ˜…   Luckily in product operations we create new attributes and in some operators we don't even copy the attributes at all (like `nx.complement`). Maybe we should be leaving a lot of this part to the user ðŸ¤· 
comment
@Qudirah just wanted to bump this up :)  If you have the time could you please fix up the requested changes in the PR, so I can go through and review them? Thanks for your contributions!!
comment
I'm not able to view the changes on codecov https://app.codecov.io/github/networkx/networkx/pull/6483 could you please make an empty commit on this PR so we can restart the CI systems? Thanks!
comment
> So, maybe this function can be used for all undirected and directed graphs as well.  Finding the hamiltonian path is a hard problem and it's not trivial to generalize the hamiltonian function for a tournament graph to work with any general graph :)  But we should definitely catch the "G is not a tournament graph" error as users shouldn't really use a function from a sub-package namespace on general graph in networkx.
comment
Hello @cisan86! You are creating a multigraph (multiple edges between two nodes) and currently we don't natively support drawing those edges between two nodes. 
comment
Closing this issue as we don't need to keep new issues for test coverage improvements.
comment
fixed in https://github.com/networkx/networkx/pull/6131
comment
Thanks for bringing this up!  > A proposed fix would be to validate the filter func or/and validate the resulting output graph.  How do you plan to validate this? Currently it returns a view and the error would only show up if you actually compute the nodes/edges. If we compute them then we lose out on the flexibility of keeping the value lazily evaluated.   We do get a corrupted graph as an output but doing anything on that graph should pop up an error with enough information to the user about it, like the above example will give you the following error.  ```  python In [4]: nx.subgraph_view(graph, filter_func).nodes .... .... TypeError: filter_func() takes 0 positional arguments but 1 was given ``` 
comment
> For example when you use that corrupted graph in nx.bidirectional_dijkstra(corrupted_graph) it'll give a wrong outcome and go unnoticed.  Can you give a small code example to show this, as soon as any function which does any computation on the graph calls the subgraph_view graph it will error out and tell the user that the way `filter_func` is defined is wrong.  Like for `betweenness_centrality`:  ``` python In [27]: graph = nx.DiGraph()  In [28]: graph.add_edges_from([(0, 1), (1, 2), (2, 3)])  In [29]: filtered_graph = nx.subgraph_view(graph, filter_func)  In [30]: nx.betweenness_centrality(filtered_graph) ..... ..... ..... TypeError: filter_func() takes 0 positional arguments but 1 was given ```  Anyway I'm not sure if there is a clean way of preventing users from declaring wrong filter functions. They will get what they feed in :/
comment
> If we do this with a wrong filter_func we'll always get the inf, [] response. Bugs like these might be though to detect.  Hmm, these bugs would be hard to catch. We give users enough flexibility with these things and the `filter_funcs` are **supposed** to return a boolean. Now if the user isn't testing their `filter_funcs` we can't really expect networkx to test all user input. This would mean a check in every single function that takes in a graph object or any other user defined callable. We even avoid doing type checks (python is still a dynamic language ðŸ™ƒ). These checks are cheap but if we start checking for every little thing this will just add too much cruft to the codebase and it may start having performance issues too.  If you do come up with a not-so-invasive way of fixing it, do let us know :)
comment
> Static type checking would likely help here. If we had annotations for filter_node and filter_edge that specified them as callables that expect nodes or edges as input, respectively, and must return bools then this issue would be caught by e.g. mypy.  True but that still requires the user to know about mypy and actually run it ðŸ™ƒ.  > I was thinking about something like assert_graph_not_corrupt? It would be a one liner and raise an error if it's corrupted   Similar to the other issue I'm not super excited about adding just another helper function that can be checked by the user in one line (like just `print(filtered_graph)` )  PS: Maybe this is just a disconnect between how different people use networkx. I extensively use jupyter notebook while working with networkx and there is a quick feedback loop. So something like this wouldn't happen as this corrupted graph will be quickly caught.
comment
Also before sending a PR please do run the tests locally https://networkx.org/documentation/latest/developer/contribute.html#testing, this will catch all the issues before creating a pull request :)
comment
This was fixed in https://github.com/networkx/networkx/pull/6612, thanks for the PR @Qudirah!
comment
Seems to be working all fine https://app.codecov.io/github/networkx/networkx/commits :) Thanks @rossbar 
comment
Hmm, I just tested with a clean python 3.10.6 + networkx 3.1 environment. But I can't reproduce this.  Did this behavior emerge after the update to NetworkX 3.1?  
comment
Could you try removing and reinstalling networkx? Also can you make sure the jupyter kernel is running in the right environment?
comment
Could you give a link where you are seeing this in our documentation?  https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.community.louvain.louvain_communities.html#louvain-communities 
comment
@MasterC4t these pull requests and your comments all around networkx commits and repository are getting very spamy. Please let us know if you are looking for anything specific and we can point you towards the right place :)
comment
`networkx` doesn't natively support interactive drawing of graphs. You can look at other libraries like https://github.com/QuantStack/ipycytoscape or tools like D3.js (networkx graphs can be converted D3.js compatible JSON https://networkx.github.io/documentation/stable/reference/readwrite/json_graph.html) 
comment
@Qudirah let me know if you still have the time to work on this :) No worries if you dont! Thanks for all of your contributions to networkx :)
comment
> Right now I don't understand what it means, but is this something I can possibly work on?  Please look at all the previous discussions here https://github.com/networkx/networkx/issues/4064 and a bunch of other places inside networkx. One possible way for this is https://github.com/networkx/networkx/pull/6306 but we are nowhere near having a concrete plan for this, and wouldn't recommend to pick this up as a new contributor task :)
comment
Examples are good but we shouldn't be adding everything as an example :)  I'm not too sure if this adds anything new, that isn't already in other examples. Drawing and coloring networks seems to be covered well by https://networkx.org/documentation/latest/auto_examples/index.html#drawing 
comment
Well I'll be biased as I made this very notebook a long time back (~ 6 years I think now ðŸ˜…) https://ericmjl.github.io/Network-Analysis-Made-Simple/05-casestudies/01-gameofthrones/ and it's already out there ðŸ˜…   But it would be nice to get more real world "academic" datasets like protein networks, interactome, sociological networks. As this is one of often requested examples. Showing users how to use networkx in more (and new) research areas and helping them giving a basic overview of networkx is one of the aims of nx-guides.
comment
@BenFaruna there is no need to get any issue assigned :) If you are interested in it you can start working on the issue (you can just write a comment that you are working on it), this issue will involve looking at the documentation pipeline and our sphinx builds, so it could be a bit complicated to start with, but please do look into it!
comment
Just putting this here, the circle-ci issue was unrelated and was resolved.
comment
Thanks for the review @dschult!  Thanks @danieleades for getting this together, it's time to ruff-ify now :)
comment
@dschult we can check ruff "in production" I guess. If issues do pop up we can revert this PR.  I'll also add the main branch commit to git-blame-ignore so this doesn't pollute git blame.
comment
We have our set of layouts: https://networkx.org/documentation/latest/reference/drawing.html#module-networkx.drawing.layout, currently we just don't use them for latex graph drawing. TikZ provides with some layouts https://tikz.dev/gd-usage-tikz#sec-28.10, maybe we should investigate that further rather than using our inbuilt ones by default? But I agree we should do layouts in another PRs :)
comment
Well let's see then
comment
Please go through https://networkx.org/documentation/latest/developer/contribute.html#development-workflow, look at last point in step 1 to install pre-commit on your local networkx git repo. It should automatically catch and fix these style errors :)
comment
Looks like all of them are being run? Should we close this?
comment
Please provide some additional details about the issue.
comment
I'm kind of -0.5 on this change but I won't fight it :)  I like super quick helper functions show up with a `tab` hit when I do `nx.dag_`, without me trying to wrangle a dictionary structure and remembering where to call `sum`. Yes I like python but still I like my quick helper functions. 
comment
Urghh, yes this is an issue. Thanks for opening the issue! We should have caught this before.  > That would reduce compatibility to 3.8+ if I'm not mistaken. IDK if it is a good solution but what about raising an exception if len(args) != 0?  We already are py3.8+ for new networkx releases.
comment
> We'd have to make any function that uses the _dispatch decorator make the first input position-only. Would it be more flexible to allow the _dispatch decorator to include as an argument the name of the possibly keyword input variable? It could default to G and not change much code anywhere -- and we'd have to document that anyone decorating a function with first argument called something other than G will need to use this argument for the decorator.  We anyway have to revisit this specific bit of the decorator as right now the assumption is that there is only 1 argument with a graph object. The current `_dispatch` implementation wouldn't work for functions where you expect 2 graph inputs (like isomorphism). IMO these changes should happen inside the `_dispatch` decorator and we should do better job of standardizing function arguments (like it should either be just `G` or `graph` or something) elsewhere in the codebase.
comment
I have seen this issue before and this does come from pydot if I remember correctly (not able to quickly find a link right now), and as @navyagarwal pointed it's recommended to use pygraphviz instead for now.  Thanks for reporting it! I'll close the issue for now.
comment
@swederik Sometimes getting back to code after 8 years is the charm :D  I went through the PR, made the changes to be usable in the current version, rebased to main and did some minor clean ups. The resulting changes are here https://github.com/networkx/networkx/compare/main...MridulS:networkx:knotty_cent_review   I tried to run the code but I'm getting the `RuntimeError: maximum recursion depth exceeded` too. I have tested by increasing the recursion depth limit too but it's stuck in a `_best_perm` recursion loop. Do let me know if you have the bandwidth or interest to pick this up again and we can get this merged in :) 
comment
@swederik I have created a new issue which deals with clean up of this PR https://github.com/networkx/networkx/issues/6475 and if anyone is interested they can pick it up from here. Thanks again for submitting your work and sorry for the long delay :)
comment
> After having created a graph with tuples as nodes and weighted edges (see attachments), I am writing the edgelist to a text file.  Could you give a minimal example in text? No one should be downloading random .zip files from the internet :D 
comment
https://github.com/networkx/networkx/pull/4825 added LineCollections back, but for directed graphs you need to explicitly ask of LineCollections by passing in `arrows=False`. Something like `nx.draw_networkx_edges(G, pos, arrows=False)`  This behavior is already documented at https://networkx.org/documentation/latest/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html, any suggestions how can we improve the docs?
comment
We do not have any core dependency. If someone uses pip install networkx they will only get networkx. Users need to opt into to install the "default" dependencies. 
comment
I see in the linked project "default" is present in pyproject.toml while requiring networkx.  Unless the package requires the scipy/numpy/pandas parts of networkx, it should work just fine on plain networkx without any extras. If it does depend on numpy/scipy, the package can independently install that package. NetworkX should work just fine with the latest scipy/numpy/pandas installed independently of networkx.
comment
Yeah, that's just an intermittent github issue. I reran the tests. Should work now :)
comment
Could you please add this in https://github.com/networkx/networkx/pull/5925. Thanks!
comment
This PR hasn't been touched in a while and there is another PR which is trying to fix up FR https://github.com/networkx/networkx/pull/6400. Thanks for your contribution @Kdezaphi! Please feel free to add comments/reviews in the other PR.
comment
The PR hasn't been touched in a while. @benjaminbenteke let us know if you still have the time to work on this, thanks for opening the PR. 
comment
Can you reproduce this in other browsers? Which version are you using?  I tried it with Firefox 09.0.1, Chrome 109.0.5414.119, Safari 16.3 on a MacOS but I can't reproduce this. 
comment
@mjschwenne let me know if this is still an issue with any other browser you are using. If not we can close this issue :)
comment
Which OS are you using and which distribution of it?
comment
I tried looking into this (started going into the SVG rendering rabbithole for browser engines, a lot of things can go wrong apparently) but I don't think this is something specific to our SVG logo/website. I would vote for closing this issue, unless you can reproduce this on any other machine. What do you think?
comment
@danieleades Thanks for all the PRs. Individual PRs are indeed a nice way to review all the changes, but merging them one by one would create a lot of merge conflicts all around. How about we start reviewing the individual changes in these one-lint-rule-per-PR but once we are done with the review we close that PR and have all the reviewed changes added once with a ruff.toml file at the end of this exercise. This will also let us add just one commit in the git-blame-ignore file. We can keep a track of the "approved" lints/ruff.toml structure in this issue.  What do you think? Thanks again for sticking with this :)
comment
Also ruff is having a lot of quick releases, are you keeping a track of things that changing underneath there? We wouldn't want to review for 0.0.215 and then add 0.0.223 (the latest release) in the big PR. Let's keep the changes synced to one ruff version (I'll update the PR to 0.0.223)
comment
> Another approach would be to create a new branch, merge these PRs one by one into the branch, and then create a single PR to merge the branch into 'main'. I guess it's equivalent, but preserves the outcome of the PRs (ie accepted or rejected)  Yeah that's good too. We can do this on a branch on your fork and then you can just send that PR once it approved?
comment
> in order to keep a record of the approval chain within the networkx repo it would have to be a branch in the networkx original, not the fork. If that's too tricky logistically, I'll just create a new branch to squash all my existing diffs.  We can use Networkx PRs too.  > I don't see any objections on the open diffs so far, modulo the discussion in https://github.com/networkx/networkx/pull/6320. Is further approval required, or should I start pulling these together?  Please do create a new PR with all the changes with the ruff setup file https://github.com/networkx/networkx/issues/6325#issue-1518545283 (added at the end of the comment), and keep it draft for now. We can move to to review status as soon as we are done with all the ruff linting we want to get in.
comment
@stanyas let us know if you still have the bandwidth to finish up this PR :) Thanks for opening this up!
comment
Thanks @stanyas @rossbar !
comment
@hagberg @Midnighter @bjedwards What is the current status of this project? 
comment
Went through this PR to see the current status, a lot of code has been merged into NetworkX by new PRs.  Some bits of code that is left over: networkx/algorithms/community/community_quality.py ~- community_performance~ implemented in `partition_quality` ~- community_coverage~ implemented in `partition_quality`  ~networkx/algorithms/community/divisive.py~ -> https://github.com/networkx/networkx/pull/5830 ~- divisive_partition~ ~- edge_betweenness_partition~ ~- edge_current_flow_betweenness_partition~   networkx/algorithms/community/laplacian_spectral.py - spectral_bisection Added in https://github.com/networkx/networkx/pull/6404 ~- simple_directed_laplacian~ Available in directed_laplacian_matrix via keyword arguments. ~- lazy_directed_laplacian~ ~- pagerank_directed_laplacian~  networkx/algorithms/community/partition.py - spectral_modularity_partition -> https://github.com/networkx/networkx/pull/1733 - greedy_max_modularity_partition -> https://github.com/networkx/networkx/pull/1733 (this could also be closed as we already have a greedy algorithm for maximum modularity implemented in https://github.com/networkx/networkx/pull/2871) - recursive_partition [-1 on this one, I wasn't able to find too much on this approach]  networkx/algorithms/community/random_community.py - random_partition -> https://github.com/networkx/networkx/pull/1733 - random_p_community [I'm -1 on adding this as it's not a direct graph operation] - random_m_community [I'm -1 on adding this as it's not a direct graph operation]   ~networkx/algorithms/community/spectrum.py~ All of these seem just variations of pagerank, and I'm not sure if we need to add them to networkx. ~- stationary_distribution~ ~- lazy_stationary_distribution~ ~- pagerank_stationary_distribution~  We don't necessarily have to add all of the other bits of code. I'll go through the remaining bits and open a new PR so we an review it again and get this in NetworkX :)
comment
I have updated the [above comment](https://github.com/networkx/networkx/pull/764/#issuecomment-1130147447 ) with the current state and some opinions about some bits that I don't think we should add to networkx today. I am tagging this with a `close ?`. We can continue reviews in other open PRs.
comment
@jangwon-yie let me know if you have the bandwidth to finish this up :) Otherwise I'll go ahead and close this PR. Thanks for your contributions!
comment
I agree with @rossbar, thanks for the PR!! but I think we shouldn't be adding another text based graph format which seemingly (from a cursory internet search) doesn't seem to be supported in a lot of places. It heavily increases our maintenance burden.  And it looks like 4CAT has moved to GEXF https://github.com/digitalmethodsinitiative/4cat/commit/176b15a274ccd8245ac85739ee80eded40b767b6 ?  Anyway I'll go ahead and close this PR, thanks again for your contribution! 
comment
Yeah the file was renamed to `javascript_force.py` -> https://github.com/networkx/networkx/blob/main/examples/external/javascript_force.py in https://github.com/networkx/networkx/pull/4422. Feel free to send a PR to fix the typo :)
comment
@diogobaltazar to get this working you need to run the flask app in `javascript_force.py` not the `js` file itself. d3 is loaded in `force.html` and it is served via the flask app. Just do `python javascript_force.py` in the `external/` folder and it should start a server on 127.0.0.1:8000 with the d3 example.
comment
fixed in https://github.com/networkx/networkx/pull/6312
comment
Is the matrix market file in the array format or coordinate one?  Could you try with `nx.from_scipy_sparse_array` instead of `nx.from_numpy_array`?
comment
Before the review just wanted to point out that the GSoC application deadline is under 4 hours so please submit the application before that, Google is pretty strict with deadlines :)
comment
Thanks for starting discussion on this one @stanyas, we can use https://github.com/networkx/networkx/issues/5824 for further discussion on this one :)
comment
+1 on using `pytest --pyargs networkx` all around. @EricPostMaster could you update the instructions to just that instead of `PYTHONPATH`? Thanks!
comment
You should also add tests for the same.  I see you have added some tests in https://github.com/jnyrup/thisandthat/blob/master/cographTest.py . NetworkX uses [nosetests](https://nose.readthedocs.org/en/latest/), please add tests according to it.  You can view other test files in the codebase for inspiration. 
comment
@jnyrup sorry for the super late ping on this one ðŸ™ƒ  Let me know if you still have the bandwidth/interest in getting this into networkx :)
comment
No worries. Thanks for the contributions :) 
comment
@pedros Thanks for the contribution! And sorry for the delay in review ðŸ˜…  As of today it looks like rdflib maintains connectors to networkx https://github.com/RDFLib/rdflib/blob/9625ed0b432c9085e2d9dda1fd8acf707b9022ab/rdflib/extras/external_graph_libs.py#L72 so we don't need to add them here :)  The link to RGML seems broken, I think this is the current one https://www.cs.rpi.edu/~puninj/rgml.html . And from previous experience maintaining markup languages in networkx becomes a maintenance burden so we are trying to avoid adding new readwrite modules, especially the ones which don't seem to have robust support outside of networkx already. Let me know what you think. Thanks again!
comment
@westurner The plugins bits are currently setup to work for backend computation plugins, not readwrite modules. But this is something that indeed can be thought more about :)  For readwrite to arrow/Parquet, I think we can have a readwrite inside networkx too! (just my opinion) Arrow is a robust data format outside of networkx and if there is an efficient way of reading/writing into that I think that's a plus.  Now if someone comes up and implements algorithms on top of arrow data structures for graphs, that would be great :D. We would be able to directly latch into that as a backend.
comment
> RDF support would be worthwhile as a core "read write plugin" or as a third-party adapter with it's own integration tests that depend upon rdflib import IMHO.  rdflib already has all the support for conversion b/w networkx and rdf, not sure what else we can/should add.   > about arrow on GPU  Well we support (soon) cugraph as a backend for networkx so that's good news.  But arrow is still columnar memory layout which doesn't really work that well with graph algorithms, so it's not that straight forward having arrow support for the graph data structure itself. Yes, it can work as a dumping ground for graph data but not something we can write code on top off (which is the more interesting thing to me). 
comment
This is fixed now right @rossbar ?  https://github.com/networkx/networkx/blob/main/.github/workflows/pytest-randomly.yml seems to show that it's run without any exceptions.
comment
Done in https://github.com/networkx/networkx/pull/6215
comment
Thanks for this @hungz23 sorry for the delay in getting this reviewed!  NetworkX has made a bunch of changes in the last 5 years and this function can be now rewritten with just something like ``` python {i: list(G.adj[i]) for i in order} ```  So if anyone requires this in an implementation of any algorithm they should be able to use this one liner. 
comment
This was fixed in https://github.com/networkx/networkx/pull/6003 
comment
@mfrasca sorry for the delay in review ðŸ˜…  We already have a cutoff argument (`depth_limit`) for dfs https://github.com/networkx/networkx/blob/a1041e70836e989d94bca31c9e0816ec61b84925/networkx/algorithms/traversal/depth_first_search.py#L297  But the code looks like it is adding a `condition` callable to find a path which satisfies the `condition`. If we do go down this route this should be done for all the dfs/bfs route finding algorithms. I'm -1 on this change as it essentially creates a customized DFS, maybe we should just leave this to the user.   Let me know what you think @mfrasca!  and thanks again for the contribution!
comment
Indeed this is a bug! Thanks for the catch @ywangmy https://github.com/networkx/networkx/pull/6409 should fix it.
comment
This was fixed in https://github.com/networkx/networkx/pull/6073 and https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/stochastic.py shows 100%. Thanks for the PR @paulitapb!
comment
There are more red blocks at https://github.com/networkx/networkx/issues/6028 which aren't covered here, do you plan to add them in the PR? We can do another PR too :)
comment
https://app.codecov.io/gh/networkx/networkx/blob/main/networkx/generators/line.py shows 100% coverage now. Thanks for your contribution @nsengiyumva-wilberforce!
comment
Well this is deprecated now, so no need to merge this anymore.  Thanks for this @paulitapb!
comment
We now have a nice example at https://networkx.org/documentation/stable/auto_examples/drawing/plot_custom_node_icons.html#sphx-glr-auto-examples-drawing-plot-custom-node-icons-py thanks @sharwinbobde !
comment
This works fine with `pygraphviz` BTW.  ``` python G = nx.Graph() G.add_edge("long_name"*15, 1) pos = nx.nx_agraph.graphviz_layout(G, prog="dot") ```  and as we are planning on deprecating `pydot` https://github.com/networkx/networkx/issues/5723, I'll go ahead and close this issue as a won't fix (this should be fixed in pydot anyway) :)
comment
Support for `pydot` will soon be deprecated https://github.com/networkx/networkx/issues/5723, please use `pygraphviz` instead https://github.com/networkx/networkx/issues/6187 :)  You can use `pygraphviz` by changing `nx.drawing.nx_pydot.graphviz_layout(graph, prog="dot")` to `nx.drawing.nx_agraph.graphviz_layout(graph, prog="dot")`
comment
Thanks for the PR @jazzmuesli! We should be using https://github.com/networkx/networkx/pull/6306 and https://github.com/networkx/networkx/issues/4064 for further discussions about this :)
comment
@hcars thanks for the PR! We probably will not just depend on multiprocessing for parallelization.  Further discussions in https://github.com/networkx/networkx/pull/6306 and https://github.com/networkx/networkx/issues/4064
comment
@ericmjl regarding backends for computations check out https://github.com/Quansight-Labs/uarray. But to make that work with networkx will require a bit of work, cuz everything builds up on the dict-o-dict-o-dict data structure instead of arrays/lists/dataframe which Dask uses. [I am thinking on the lines of using Dask data structures to store the graph/network]. It would actually be pretty great if this could be done! :)
comment
To be discussed further in https://github.com/networkx/networkx/issues/4064 and https://github.com/networkx/networkx/pull/6306 . Thanks for opening the issue @jazzmuesli ! 
comment
To be discussed further in https://github.com/networkx/networkx/issues/4064 and https://github.com/networkx/networkx/pull/6306 
comment
@cimox Thanks for your contribution! Looks like this has been already added to networkx https://github.com/networkx/networkx/blob/main/networkx/algorithms/traversal/breadth_first_search.py  I'll go ahead and close this one :)  
comment
I have restarted the CI, the tests shouldn't fail now :)
comment
I really like this!  Just wanted to put this bit of code here too, this uses the library [rich](https://github.com/Textualize/rich) which is great for *pretty* terminal pictures. They have an inbuilt tree structure but it has it's limitations. Is it worth investigating this further?  ``` python import networkx as nx from rich.tree import Tree def rich_tree(G, root_node, depth_limit=4):     bfs_tree = nx.bfs_tree(G, root_node, depth_limit=depth_limit).to_directed()     tree_nodes = {i: Tree(f'{str(i)}') for i in bfs_tree}     for n in bfs_tree:         current_node = tree_nodes[n]         for children in bfs_tree.neighbors(n):             tree_nodes[n].add(tree_nodes[children])     return tree_nodes[root_node] ```  ``` python >>> G = nx.Graph() >>> G.add_edge('hello', 'world') >>> G.add_edge('world', 'tree') >>> G.add_edge('hello', 'rich-tree') >>> root_node = 'hello' >>> rich_tree(G, root_node)  hello â”œâ”€â”€ world â”‚   â””â”€â”€ tree â””â”€â”€ rich-tree  ```  This could also be used for `forest` ``` python def rich_forest(G, depth_limit=4):     for n in nx.connected_components(G):         yield rich_tree(nx.subgraph(G, n), n.pop(), depth_limit) ``` ```python >>> G = nx.erdos_renyi_graph(10, 0.15) >>> from rich import print >>> for i in rich_forest(G): >>>     print(i) 0  1 â”œâ”€â”€ 2 â”œâ”€â”€ 5 â”‚   â””â”€â”€ 7 â””â”€â”€ 6     â””â”€â”€ 3  4  8 â””â”€â”€ 9   ``` 
comment
Yeah, it's a linting issue, ignore that check.
comment
@LukasMoll could you give an example what do you mean by this testing module? What exactly do you want to test?
comment
> I'd like to be able to assert a nx.DiGraph, nx.Graph, nx.nodes etc.. All objects that I might want to assert with their own unique assertion function.  I don't think this translates that well to graphs. Maybe you are looking for graph isomorphism? Could you please give a concrete example where `graph_equal` fails? 
comment
> Why shouldn't we?  Adding new things is nice but the problem is maintenance. Every new line of code put in needs to be checked/maintained until it's removed/deprecated. We should avoid adding new bits to the API if they can just be one liners in Python. We really need a compelling reason to expand the API surface of networkx :)  There are a lot of ways users can write these assert statements in one liners, anything specific that you would like to expose that isn't already covered by these examples? We definitely wouldn't want to add too custom of testing code. ``` python # To compare nodes >>> G.nodes == H.nodes  # To compare nodes with attributes >>> G.nodes.data() == H.nodes.data()  # To compare specific attribute >>> G.nodes.data('attribute') == H.nodes.data('attribute') ```  All of this can also be used for edges.
comment
All of these things can exist inside the user codebase, not necessarily inside networkx.  We already provide some basic function like `edges_equal`, `nodes_equal`: https://networkx.org/documentation/latest/reference/utils.html  I'm not too excited about adding these things to networkx but if someone else would like to push for this I'm okay with that. 
comment
> What features are you interested in?   Just my personal list:  - Review old pull requests - Speed up current implementations - Fixup code in the `draw` subpackage - Add new algorithms  There are a LOT of things that can be done here.  I'll go ahead and close this issue for now, feel free to open a new issue/discussion if there is anything else you are interested in contributing :) 
comment
I'll close this one, this wouldn't really help the user until everything is typed in networkx.
comment
Should we just leave this to black? they will add it soon enough I guess in the main release. And we update our black config pretty quickly.
comment
> Or just make a note that the lint will be removed once the feature moves into stable Black?  IMO these are just aesthetic changes and I don't think anyone is any hurry of getting this in and then make sure we revert it to black. Just one less thing to keep track 
comment
Let's just close this one, this will come whenever it's part of black stable.
comment
@danigil thanks for your PRs! numpy isn't a strict requirement of networkx (we don't have any!). NetworkX works on any device Python works. There are certain pieces of the codebase that only work with numpy and to make our tests happy the filename needs to added to https://github.com/networkx/networkx/blob/6f50d397fb22fee79867e5bbdfc885e1247096d4/networkx/conftest.py#L134-L140 so pytest knows which files to skip when running the tests with `pypy`.  While writing the tests you would also need to do `np = pytest.importorskip("numpy") ` instead of the generic `import numpy as np` as `numpy` is not a given! As an example you can look at the import structure for tests for a function which requires numpy. https://github.com/networkx/networkx/blob/6f50d397fb22fee79867e5bbdfc885e1247096d4/networkx/linalg/tests/test_attrmatrix.py#L1-L3  Let us know if you any other questions about this :)
comment
numpy is fine is to use, adding c/cython is the only issue as we don't yet have a process of incorporating those changes in networkx :)  I'll go ahead and close this issue, feel free to open a new one or ping me on a pull request you are stuck at :)
comment
Just FYI, we do not accept cython/C code in networkx. NetworkX is a pure python library and it isn't changing anytime soon (I think)
comment
I went in and made some changes to make it work with the CI, @LucaCappelletti94 I also removed the type annotations as currently we don't actively put in type annotations for code in networkx (it was also failing the `mypy` check).
comment
@dschult @LucaCappelletti94 it would be great to get this in before 3.0 (but it's supposed to be released in 2 weeks) and I would be great to get the issues brought up (and replied) in https://github.com/networkx/networkx/pull/3591#issuecomment-668779935 resolved ! :)  The one major thing that sticks out to me is the API of write/read of LaTeX graphs, this should follow (IMO) the generic drawing API like `read_dot` and `write_dot`.  Users should be able to do something like: ``` python >>> G = nx.erdos_renyi_graph(10, 0.1) >>> nx.write_latex(G, 'erdos.tex') # which creates a Adigraph object and writes to file ```  I would suggest that we follow the API choices in `nx_agraph.py` as an example:  `from_adiraph` and `to_adigraph` that handles conversion between a NetworkX (Di)Graph object and a Adigraph object. This will let users interact with the `Adigraph` object itself and provide helper functions like `write_latex` and `read_latex` so users can quickly write a NetworkX (Di)Graph object to disk. 
comment
@Lukong123 there is a `{` missing in front of the result. It needs to **exactly** match the output.   `0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}`  should be  `{0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}`
comment
> One thing we could think about is fleshing out the text a bit more and making this a notebook example for nx-guides. Thoughts @MridulS ? For the record I'm opposed to adding this as a gallery example, just want to explore options and collect opinions!  Hmm, triads could be a nx-guides but we would need a much more compelling story, triads in themselves don't really justify a notebook (IMO) but if you mix them with things like `transitive_closure` and a nice dataset then we can have a nice story about how to use triads with social networks (or maybe something else).  PS: I guess you meant "not opposed"
comment
The checks are failing here as the code doesn't pass the `black` linter. Please [install `black`](https://black.readthedocs.io/en/stable/getting_started.html#installation) on your machine and reformat the code. Once `black` is installed you can run black on a particular file via the command line with `black name_of_the_file.py`  There is no need to add tests or image comparisons for this particular issue as we are adding a new example. Please go through the [adding examples section](https://networkx.org/documentation/latest/developer/contribute.html#adding-examples) in our contributor guide. This python file should be moved to the `examples/` folder.
comment
@paulitapb could you review the comments by @rossbar? Once they are resolved we can merge this in.
comment
The `mypy` job works fine on all PRs (https://github.com/networkx/networkx/actions/workflows/mypy.yml) except https://github.com/networkx/networkx/pull/6315 which touches `test_reportviews` and the mypy test fails for `reportviews.py`
comment
Which mypy version are you on? It works fine for me locally.  ``` (networkx-dev) âžœ  networkx git:(main) mypy --version mypy 0.991 (compiled: yes) (networkx-dev) âžœ  networkx git:(main) mypy -p networkx networkx/algorithms/planar_drawing.py:226: note: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs  [annotation-unchecked] Success: no issues found in 556 source files ```
comment
Indeed. What does git diff/git log tells you? Is this the `main` branch without any changes?
comment
BTW the `pyproject.toml` will be an issue in the ruff PRs so I would suggest to not create new PRs (there will be merge conflicts), maybe just have a tracking issue for now. And using `pyproject.toml` just for ruff can mess up projects which are building networkx from scratch in their workflows (I remember seeing poetry builds going wrong when both setup.py and pyproject.toml are present). We need to move all of setup.py to pyproject.toml to get ruff specific configuration
comment
This is an experimental feature in black itself https://black.readthedocs.io/en/stable/the_black_code_style/future_style.html#preview-style. We follow the black official releases in our pre-commit config https://github.com/networkx/networkx/blob/71ad516a90c89c7294e32bf28e1f05c63c5f17e4/.pre-commit-config.yaml#L6 if and when this is incorporated in a proper black release we can add this to networkx. The whole point for me to use `black` is to not think about these things :)  
comment
Let's discuss this in context of ruff, closing this in favor of https://github.com/networkx/networkx/pull/6317
comment
@tharrry sorry for the delay in reviewing this, but this was fixed in https://github.com/networkx/networkx/pull/6265. I'll go ahead and close this. Please feel free to fix any other open issue :)
comment
Thanks for raising this @sandrotosi, it should be fixed soon.
comment
There are a bunch of other packages for temporal networks.  https://github.com/IngoScholtes/pyTempNets  https://github.com/benmaier/tacoma/  Havenâ€™t used them a lot.  As already suggested I usually put in a time attribute in edges to make a networkx graph a temporal graph, it works for majority of cases.  On Mon, 19 Aug 2019 at 04:42, Dan Schult <notifications@github.com> wrote:  > I don't know of any others. But other people might... Anyone? > > â€” > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/issues/3548?email_source=notifications&email_token=ABI5RFHUAWZ3A6KTNLX2BULQFICBXA5CNFSM4IMTNMFKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD4RQ3PQ#issuecomment-522390974>, > or mute the thread > <https://github.com/notifications/unsubscribe-auth/ABI5RFGVCBU7MXVIRWJLZVLQFICBXANCNFSM4IMTNMFA> > . > 
comment
Hi @Perceivery, could you give some more information how you got this error? Please provide minimal example code that can generate this error.
comment
I can't really reproduce this (don't have a raspberrypi). But this error is coming from matplotlib. What version of `matplotlib` do you have?  Also the link to the example is a old version (which has a typo), pleas use the latest stable release https://networkx.org/documentation/stable/auto_examples/basic/plot_properties.html
comment
Well what's happening after this clone? Also I would suggest installing the "default" requirements of networkx. You can change your RUN command to: ``` pip3 install --no-cache-dir networkx[default] ipywidgets ```
comment
@paulitapb just a ping to review the comments :)
comment
I'll go ahead and close this one! We have a new implementation https://github.com/networkx/networkx/pull/5736
comment
Thanks @Qudirah!
comment
Also you can check this by running `pytest` locally before submitting a pull request. It will catch something like this :)  You can also click on "Details" next to a red crossed failed test to get more details. It should take you to exact place it failed.
comment
A video which explains.   https://user-images.githubusercontent.com/5363860/196732072-7c813a84-6a79-41f3-ba50-6a8ac0baa809.mov  
comment
thanks @Qudirah! This looks good :)
comment
No need to create an issue. This looks good. Thanks!
comment
Thanks @Qudirah!
comment
Could you give some details how you ended up getting this output? I see you are using osmnx, can you provide the code block that generated this output?  From the output it does look like node `583097016` is not in the Graph `G`
comment
@Qudirah Looks like this PR contains multiple different commits. Could you please update the description of the PR, which issues does this PR fix.  Thanks!
comment
The issue here is that when you create a new branch you are using the development branch to create a new branch, so it copies over the history of that development branch.  Suppose you want to work on 2 issues (A and B), to create independent branches for A & B which do not interfere with each other you should use `main` as the base branch. So you local branches should be created something like this:  ``` $ git checkout -b branch-for-A main $ git checkout -b branch-for-B main ```  Currently I think the branches are created in this fashion ``` $ git checkout -b branch-for-A $ git checkout -b branch-for-B ``` The second checkout above will create a branch from the last commit of branch A, and hence the mixing of commits here.  Yes `git` is confusing, but don't worry you will get used to it ðŸ˜„ 
comment
Thanks for the PR @jeftersantiago. I merged https://github.com/networkx/networkx/pull/5988 with the suggested change so this PR isn't required. Thanks anyway!
comment
> When I used this G.add_edge (u_for_edge=None,v_for_edge=3), it did generate a graph with edge point none.  I can not reproduce this. This gives an error (as it should!). Can you give a minimal example how to reproduce this? It shouldn't be possible to get a graph with a `None` node.   You need to add a test when somewhere tries to do something like ``` python G = nx.MultiGraph() G.add_edge(None, 'anything_else') ``` it generates an error.
comment
Well, that's interesting. Can you check your networkx version? What does `nx.__version__` prints out?  
comment
This was fixed in https://github.com/networkx/networkx/pull/4892/ so should be in networkx version > 2.6
comment
Are you using a M1 mac? How did you install graphviz?  Trying searching in the pygraphviz issue tracker about this, one suggestion https://github.com/pygraphviz/pygraphviz/issues/398#issuecomment-1038476921.  I'll go ahead and close this issue as this is a pygraphviz installation issue, please search in the current open issues here https://github.com/pygraphviz/pygraphviz. You only need pygraphviz for a tiny section of networkx so it's perfectly fine to develop without pygraphviz for now :)
comment
Thanks for this @Qudirah!  Just a general note: Please make the title of the pull request a bit more detailed, it's hard to understand "fixes # some issue number" without searching for the issue. Something like "Improve test coverage for load centrality" can give reviewers a quick way of understanding the context of the changes in this pull request.  The commit message should also contain more information rather than just "fixed networkx#6036" as when someone is looking at the project after some time, 2-4 years after this is fixed they won't be able to quickly understand what does 6036 mean. So it's highly suggested to make commit messages and pull request titles as informative as possible :) 
comment
Thanks for the contribution @Qudirah!
comment
Thanks for this @chimaobi-okite!  Please make the title of the pull request a bit more detailed, it's hard to understand "solved for issue" without searching for the issue. Something like "Improve test coverage on expanders line graph generators" can give reviewers a quick way of understanding the context of the changes in this pull request. 
comment
thanks for the contribution @chimaobi-okite!
comment
I'll go ahead and close this. thanks for opening this @SMorrison42 
comment
Could you add the link to the exact issue this pull request is fixing?
comment
I will close this one, let's do this in https://github.com/networkx/networkx/pull/6076
comment
Do you have `pre-commit` installed in your development environment?  Please look at https://networkx.org/documentation/latest/developer/contribute.html#development-workflow
comment
The test is failing the `isort` linter. Please use `pre-commit install` to install all the linters and run `pre-commit run --all-files` to force run the linter on all files.
comment
Closing this as there a duplicate discussion https://github.com/networkx/networkx/discussions/6079
comment
Thanks again for this! I will go ahead and close this. Let's get https://github.com/networkx/networkx/pull/6073 merged in :)
comment
Thanks for this @Emmanuel-Lud! But this was also fixed in https://github.com/networkx/networkx/pull/6045.  I'll go ahead and close this, feel free to create a new pull request with the fixes.
comment
Thanks for your PR @Emmanuel-Lud!  To fix https://github.com/networkx/networkx/issues/6030 we need to add a test at https://github.com/networkx/networkx/blob/main/networkx/algorithms/traversal/tests/test_beamsearch.py which tests the function `bfs_beam_edges` when `width=None`.
comment
Thanks for the update @brocla! 
comment
To make the lint test pass, can you run the following to force run it on all files. ``` $ pre-commit install $ pre-commit run --all-files ```
comment
https://github.com/networkx/networkx/runs/8274473488 still failing :/
comment
There is a lot of conversation happening already about this at https://github.com/networkx/networkx/issues/3988, https://github.com/networkx/networkx/pull/4014, https://github.com/networkx/networkx/pull/5886. Let's not create a new issue about this :)
comment
I'll go ahead and close this, if there is a way we can make the documentation better please let us know :)
comment
@eumiro while fixing up the merge conflicts and getting this ready to be merged messed up git a bit. I'll close this and move your commits to a new PR :) Thanks for the PR!
comment
Wouldn't it make more sense for compatibility that Mixin is the first base class in the MRO and also call `super().__init__()`? This will make sure the user has more control over the behavior.   ``` python In [1]: class Mixin:     ...:     def __init__(self, *args, **kwargs):     ...:         print('Mixin is initialized!')     ...:         super().__init__(*args, **kwargs)     ...:  In [2]: class Specialized(Mixin, Graph):     ...:     pass     ...:  In [3]: Specialized([(1, 2), (2, 3)]).nodes() Mixin is initialized! Out[3]: NodeView((1, 2, 3)) ```
comment
Hello all! It's great to see so much interest to work on the project :)  You can read more about the development processes on our website:  - [New Contributor FAQ](https://networkx.org/documentation/latest/developer/new_contributor_faq.html) - [Contributor Guide](https://networkx.org/documentation/latest/developer/contribute.html)  For the point about assigning issues we don't usually assign issues to anyone, feel free to open a PR when you are ready. If you are worried it may conflict with what other people are working on please put in the method you are working on in this issue and open a PR.  Even if you are stuck please do open a PR (you can keep it as a draft) as we can help you review and improve the code in the PR :)
comment
This is fixed in networkx 2.8.5, could you update the networkx version?  Also we are looking into removing pydot as it isn't actively maintained https://github.com/networkx/networkx/issues/5723, so please do comment there if you have any feelings about this change :)
comment
Thanks for the report @rgrenz! This is indeed an issue but this comes from `pydot` and we already have raised this upstream https://github.com/pydot/pydot/issues/258.  ``` python >>> import pydot >>> pydot.Node("Example:A").get_name() 'Example' ``` A quick way right now is to use this hack-ish way of dealing with `:` in node names:  ``` python G = nx.Graph() G.add_edges_from([     (1, '"Example:A"'),     (2, '"Example:B"'), ]) ```   I'll go ahead and close this for now, please feel free to reopen an issue if there is something else we can do here :) 
comment
Is it just me or CircleCI isn't building here?
comment
I haven't used PySimpleGUI before so I am not sure what is happening there but the following code will NOT pop up/draw any graph, this will only calculate the shortest path between node `A` and `B`.  ``` import networkx as nx G = nx.Graph()  G.add_node(1) G.add_edge('A', 'B', weight=4) G.add_edge('B', 'D', weight=2) G.add_edge('A', 'C', weight=3) G.add_edge('C', 'D', weight=4) nx.shortest_path(G, 'A', 'D', weight='weight') ```  Can you try adding `nx.draw(G)` at the end of your code and see what happens?  ``` import networkx as nx G = nx.Graph()  G.add_node(1) G.add_edge('A', 'B', weight=4) G.add_edge('B', 'D', weight=2) G.add_edge('A', 'C', weight=3) G.add_edge('C', 'D', weight=4) nx.shortest_path(G, 'A', 'D', weight='weight') nx.draw(G) ```
comment
If I were to take a guess it probably has something to do with matplotlib interactions inside PySimpleGUI. I am not familiar with PySimpleGUI  so can't say what's happening there. NetworkX code doesn't import/interact with PySimpleGUI.
comment
Thanks for the report @0ddoes! Feel free to work on them.
comment
changes were added in https://github.com/networkx/networkx/pull/5644, closing this one.
comment
changes merged in https://github.com/networkx/networkx/pull/5641, closing this one
comment
> Please I had a problem running nx.extrema_bounding(G, compute="eccentricities")  > It returns [TypeError: cannot convert dictionary update sequence element #0 to a sequence]() > It looks like I am missing something but I cannot figure it out  Can you provide more information about this? What's the graph `G` you are using? Also `extrema_bounding` will be removed in NetworkX 3.0 so don't worry too much about adding an example for it :)
comment
It's always recommended to create Pull Requests in small modular batches, it's harder to review a lot of changes in one single Pull Request. It also helps the maintainers to merge the pull request quicker.  This pull request also contains the changes from https://github.com/networkx/networkx/pull/5478/ (the covering.py file). You can look at the changes in a PR by going to the `Files Changed` tab just above, next to `commits` and `checks`.  I think this happened because of branches being mixed together locally on your computer. (BTW this is just fine! no need to worry, `git` is tricky to work with and this still happens with me :) )  Some personal recommendations while working with git. - Make sure that you never work on the local `main` branch, it should always be synced up with the `main` branch on github.com/networkx/networkx. You can sync up using `git pull upstream main` while you in the `main` branch. - If you want to make any change (even one line change) create a new branch with `git checkout -b name_of_the_new_branch` and make sure this command is run from the `main` branch. - For example: if you are currently working in `branch_a` and now you want to work on a new thing, make sure you go back to `main` (`git checkout main`), sync it up (`git pull upstream main`) and then create the new branch (`git checkout -b branch_b`.  You can directly do this with `git checkout -b branch_b main` but you will miss the sync up. - A mistake that I used to make was to directly create a new branch (`branch_b`) while I'm working on a branch (`branch_a`), so what ends up happening is that the new branch (`branch_b`) contains all the changes from the old branch too! (`branch_a`)  This PR is titled `distance_measures` so it should only contain the changes that are made to the `distance_measures` file, not other files. It is also recommended to add a more descriptive title for a PR, just `distance_measures` doesn't give us enough information until we look at the changes. Something like "Added new examples in the documentation of distance measures"
comment
> Oh okay sir, I don't know for sure but I am guessing is as a result of me having to clone back my forked repository which made me lose the branches I worked on previously. Please, sir, what are my options to undo any mix made on this pull request, will I have to remove the other examples on covering made on this pull request?.  The easiest solution here is to just copy the changes. Create a new branch, and make your changes. Use this: ``` $ git checkout -b distance_measures_example upstream/main ``` (this is assuming you followed our networkx setup guide and you have a "remote" setup to "upstream") This will create a new branch for you called `distance_measures_example` which builds on top of the current `main` branch in the networkx repo.  and then make the changes again to this branch `distance_measures_example` and create a new PR, we can close this :)
comment
The changes were merged in https://github.com/networkx/networkx/pull/5608, closing this one.
comment
The example was added in https://github.com/networkx/networkx/pull/5642, I'll close this PR and create a new issue to discuss the behavior of `is_regular` with an empty graph.
comment
this was added in https://github.com/networkx/networkx/pull/5641, closing this PR. Thanks @Lukong123 !
comment
Thanks for opening this @simonsteinberg, I've created a new PR with the suggested change in https://github.com/networkx/networkx/pull/5844. I'll go ahead and close this :)
comment
I do like this! Something like https://scikit-learn.org/stable/_static/ml_map.png but for network science algorithms could help direct folks towards the "right" kind of algorithm they are looking to work on :) 
comment
> What are the next steps with the application? Should I link here my proposal https://github.com/networkx/networkx/discussions/5111 for you to give feedback?  Yes that helps us suggest more things.  > Should I make an example pull request for a mini MM?   That would be great!  > Can this be a 350 hours project given that I would need to understand, visualize, and provide a minimum viable code for each algorithm?  As these things are flexible you can choose to either submit a 175 hour or 350 hour proposal :)
comment
thanks for raising this @genericCandy! But I'm not sure why should the given python script work? Why should the `Child` class should have access to the `subgraph` method from a `[Multi|Di]Graph` class? How do you define a subgraph for a `Child` object?  If you want to keep a track of a graph object inside the `Child` class maybe something like this could work for you? ``` python class Child:     def __init__(self, data):         self.data = data         self.graph = nx.Graph() ```  ``` python In [3]: G = Child("some data")  In [4]: G.graph.add_nodes_from(range(5))  In [5]: G.graph.subgraph([1, 2, 3]) Out[5]: <networkx.classes.graph.Graph at 0x10add1120> ```     
comment
Hello @5aumy4! There is already an open Pull Request which implements this for Directed Acyclic Graphs https://github.com/networkx/networkx/pull/5432, feel free to review that PR and suggest any new changes that you think can make the examples gallery better :)  
comment
Thanks for the report @osfrickler, this is indeed an issue.
comment
Thanks for the report @LiuCMU!  My first hunch was this is a bug too! But it's not, these graphs are structurally isomorphic and isomorphic only if you either take the `bond_type` or `atomic_num` but not both!!  After spending way too much time debugging the NetworkX codebase I drew these things out and they are totally different "molecules" if we take both `bond_type` and `atomic_num`. The hexagonal rings inside them can't be exchanged with each other if we take both `bond_type` and `atomic_num` together.   ![Scanned Documents](https://user-images.githubusercontent.com/5363860/174770592-843e91ac-61d9-4aa4-936d-88056e9eeb43.png)  
comment
Thanks for the report @KrishivVora, please go through https://github.com/networkx/networkx/issues/5686. This is an issue if you mix `pydot` and `networkx` read write functions. A `pydot` write to disk adds the extra `\n`.  A workaround could also be to use `nx.nx_agraph` (pygraphviz) instead of `nx.nx_pydot` (pydot). I'll close the issue for now, but please feel free to put in more details if you think there are any other issues :) 
comment
I believe this is fixed in https://github.com/networkx/networkx/pull/4183. I'll go ahead and close this :)
comment
Docs were updated in https://github.com/networkx/networkx/pull/5289, closing this :)
comment
try with ch -> checkout ?
comment
`git checkout upstream/main` to be precise.
comment
This is really interesting! +1 on having this run as a cron-job or something on the master branch.
comment
I'll go ahead and merge this and get the cron job up and running on github actions. Let's see if we find more test failures :)
comment
Thanks for raising this @adam2392! But this behavior comes from `pydot`  ``` python In [1]: import pydot  In [2]: graph = pydot.Dot("test", graph_type="graph")  In [3]: test_node = pydot.Node("a", label="something")  In [4]: graph.add_node(test_node)  In [5]: graph.to_string() Out[5]: 'graph test {\na [label=something];\n}\n' ```  One way of handling this could be to drop the line break (`\n`) explicitly while writing the graph to disk in the function `write_dot`.
comment
@adam2392 after thinking a bit more thinking about this I don't think this is a "defect", we shouldn't be mixing `nx.nx_pydot.write_dot` ( a NetworkX function ) with `pydot.graph_from_dot_file` ( a pydot function). I think we should only worry about maintaining round trips inside NetworkX and that works currently.  From example the `to_pydot` and `from_pydot` function do maintain the round trip ``` python In [1]: import networkx as nx  In [2]: from networkx.drawing.nx_pydot import to_pydot, from_pydot  In [3]: nx_graph = nx.DiGraph()  In [4]: nx_graph.add_nodes_from([0, 1, 2, 3, 4])  In [5]: nx_graph.add_edges_from([(0, 4), (3, 4)])  In [6]: nx.is_isomorphic(nx_graph, from_pydot(to_pydot(nx_graph))) Out[6]: True  ```  `write_dot` and `read_dot` are indeed failing on this round trip but that's because how pydot deals with integers (it doesn't), everything is converted to strings underneath.  ``` python In [7]: nx.nx_pydot.write_dot(nx_graph, 'test.dot')  In [8]: H = nx.nx_pydot.read_dot('test.dot')  In [9]: nx.is_isomorphic(nx_graph, H) Out[9]: False  In [10]: nx_graph Out[10]: <networkx.classes.digraph.DiGraph at 0x109073c40>  In [11]: nx_graph.edges() # initial nodes were ints Out[11]: OutEdgeView([(0, 4), (3, 4)])  In [12]: H.edges() # the nodes after reading from the dot file written to disk are strings Out[12]: OutMultiEdgeDataView([('0', '4'), ('3', '4')]) ```   The round trip in pydot isn't maintained: ``` python In [1]: import pydot  In [2]: graph = pydot.Dot("nx_graph")  In [3]: graph.add_node(pydot.Node(1, foo='bar')) # a integer node is created   In [4]: graph.write_raw("output_raw.dot")  In [5]: graphs = pydot.graph_from_dot_file('output_raw.dot')   In [6]: graphs[0].get_node(1) # the file read in via pydot doesn't know about the integer node 1 Out[6]: []  In [7]: graphs[0].get_node('1') # it does know about the string node 1 Out[7]: [<pydot.Node at 0x1096a8e20>]  ```  I'll go ahead and close this issue, please feel free to comment here or open a new issue if you think we can add something else here :)
comment
Thanks for the report! I can reproduce this.  Adding a minimal example: ```python >>> import networkx as nx >>> G = nx.Graph() >>> G.add_node(0, label='"foo("bar")"') >>> G.nodes.data() NodeDataView({0: {'label': '"foo("bar")"'}}) >>> nx.nx_pydot.write_dot(G, 'test.dot') >>> nx.nx_pydot.read_dot('test.dot').nodes.data() NodeDataView({'0': {'label': '"foo("', 'bar': None, '")"': None}})
comment
@PaulRitter this is indeed coming from pydot as the user needs to explicitly escape the strings in this case. Even if I use pydot to write the graph to a png file it will **not** automatically quote this specific string and throw an error. A minimal example here:  ``` python In [1]: import pydot  In [2]: graph = pydot.Dot("my_graph")  In [3]: graph.add_node(pydot.Node("A", foo='"foo("bar")"'))  In [4]: graph.write_png("output.png") ..... ..... ..... AssertionError: "dot" with args .....  In [5]: graph.to_string() Out[5]: 'digraph my_graph {\nA [foo="foo("bar")"];\n}\n'  In [6]: graph.write_raw("output_raw.dot")  In [7]: !cat output_raw.dot digraph my_graph { A [foo="foo("bar")"]; } ```  Now if the user properly quotes the string, pydot works.  ``` python In [1]: import pydot  In [2]: graph = pydot.Dot("my_graph")  In [3]: graph.add_node(pydot.Node("A", foo="foo(\"bar\")"))  In [4]: graph.write_png("output.png")  In [5]: graph.to_string() Out[5]: 'digraph my_graph {\nA [foo="foo(\\"bar\\")"];\n}\n'  In [6]: graph.write_raw("output_raw.dot")  In [7]: !cat output_raw.dot digraph my_graph { A [foo="foo(\"bar\")"]; } ```  I'll close this issue for now, let us know if we can do something to make this better :) Or you can open this issue on the pydot repo.
comment
This was merged in https://github.com/networkx/networkx/pull/5710, thanks for the suggestion @grusin! I went with explicitly erroring out if the user has `:` in the string and the string isn't quoted :)  
comment
Both graphviz and pygraphviz have been updated on `conda-forge` and we can't really control the `defaults` channel so I'll go ahead and close this for now.
comment
Thanks for the report @mgorny! This is indeed a bug. https://github.com/networkx/networkx/pull/5693 should fix it.
comment
I'll go ahead and merge this (I don't like the red `x` on our main branch ðŸ™ƒ)
comment
https://github.com/networkx/networkx/pull/5680 is merged. The tests should pass now. Thanks!
comment
Thanks for the report! and yes it's indeed an issue. Please feel free to submit a pull request :)
comment
fixed in https://github.com/networkx/networkx/pull/5677
comment
resolved via https://github.com/networkx/networkx/pull/3358
comment
It looks like we decided on **not** removing the convenience of the `@open_file` decorator. I'll go ahead and close this but feel free to reopen an issue if someone wants to start the conversation again :)
comment
I'll close this as we have a solution here already :)
comment
thanks for the report @harristeague!  It's indeed a bug and this should be fixed with https://github.com/networkx/networkx/pull/5660
comment
fixed in https://github.com/networkx/networkx/pull/5660
comment
@horvatha I'll close this issue for now. https://github.com/networkx/networkx/pull/5667 will atleast gracefully error out for cases where pydot isn't able to parse the node names correctly.  Thanks for the report!
comment
Thanks for the report! This is indeed a bug:  A minimal example I was able to come up with (this is a bug for both `DiGraph` and `MultiDiGraph`): ``` python In [2]: class Something:     ...:     def __init__(self):     ...:         self.g = nx.MultiDiGraph()     ...:         self.e = self.g.in_edges     ...:  In [3]: s = Something()  In [4]: deepcopy(s) ... ... AttributeError: 'MultiDiGraph' object has no attribute '_adj' ```  This should be fixed by https://github.com/networkx/networkx/pull/5657
comment
I'll go ahead and close this PR, this hasn't been touched in a long time and the code bits from BayesNet can't go in NetworkX as it's GPL.  @jac2130 I have created a new draft PR https://github.com/networkx/networkx/pull/5653 with only the new distances and made some changes to make it work with main branch of NX (it's not really tested) but feel free to pick it up from there if you interested in getting this in NetworkX ðŸŽ‰ 
comment
The correct place to put an example like this would be in the https://github.com/networkx/nx-guides repository. We could have a notebook about various centrality measures explained via a real world dataset. 
comment
Yeah, I'm not sure why would there be an expectation of getting this as the result ``` [Foo(0, zero), Foo(1, one)] [Foo(0, zero), Foo(1, one)] [Foo(0, zero), Foo(1, one)] ``` The `source` and `target` are just keys in the dictionary underneath, we do not do anything with the data structure of the node itself. It just needs to be hashable so it can be a key in the dictionary and well if people use the `__hash__` to construct these kinds of classes, we can't really make any promises about how it will work out :)  I'll go ahead and close this issue, feel free to put in any more details if you think that can help us get a better understanding of this! :D 
comment
I'll go ahead and close this issue, there isn't an actionable item here :)
comment
`branching_weight` needs to imported from the `tree` namespace, not everything is imported into the root level `networkx` namespace.  ``` python >>> from networkx.algorithms import tree >>> tree.branching_weight(G) 11 ```  This should be better documented.
comment
Just by calling `nx.triadic_census(G))` it will return the triad type and number of occurrences. If you want the type of triad and all the triad graphs please use `nx.triads_by_type(G)`.  
comment
Thanks for the report! The nodes are colored in the wrong order as the nodes are **not** ordered by node_id (the assumption in the provided code), they are ordered via the order of insertion. In this case, this is the node order ``` In [11]: list(graph) Out[11]: [0, 2, 6, 8, 4, 7, 1, 10, 9, 11, 3, 5] ``` and `vcolors` will map the colors in this order!  Just change the vcolors line to `vcolors = ['green' if n < 6 else 'orange' for n in graph]` and it should be fixed :)    
comment
`data = res_file.readlines()` this bit of line returns a `list` but `nx.node_link_graph(data)` requires the data to be a dict like object. Use something like `json.load` to read in the data and then pass it to `nx.node_link_graph(data)` :)
comment
Thanks for this @silamon!  I understand the need for this but I'm -1 on adding this to our documentation as this adds another thing to keep in check and maintain. There isn't really a quick automated way of making sure things are working and this setup doesn't break. People also end up having different preferences for their IDE setup too, so having something like this forced by our documentation isn't really something I am personally enthusiastic about :/  Also there isn't really a need of graphviz most of the time (which is usually the only pain point in our current setup) so I'm not sure if this is right way to solve that :)  PS: I personally do use devcontainers some times! I like them :)
comment
Thanks for reporting this @aaronzo! > I do think anything that passes is_bipartite_node_set should definitely give correct and error-free answers when passed to the projection function, else this behaviour is surprising.  I agree, this can be surprising. How about we raise an `Error` for `is_bipartite_node_set` if the user passes in a node list which has duplicates. At least then `is_bipartite_node_set` fails correctly for the input list of nodes. A check like `if len(nodes) > len(S): raise ...`  https://github.com/networkx/networkx/blob/6a0b4faf09ec9d3d40ad93e2ec9b431d6bab5dc4/networkx/algorithms/bipartite/basic.py#L132-L135  On that note there are probably a bunch of places where we silently change the incoming nodes list to a set and get rid of the duplicates. I'm not sure if we should do this everywhere.
comment
@britapiiro `MultiGraph.degree` does return an `int` when a single node is passed: ``` python In [1]: import networkx as nx  In [2]: G = nx.MultiGraph()  In [3]: G.add_edges_from([(0, 2), (0, 1), (0, 2)]) Out[3]: [0, 0, 1]  In [4]: G.degree(0) Out[4]: 3  In [5]: G.degree([0, 1]) Out[5]: MultiDegreeView({0: 3, 1: 1})  In [6]: G.degree() Out[6]: MultiDegreeView({0: 3, 2: 2, 1: 1}) ```  We do need to update this documentation (the iterator bit is outdated), but this may or may not work with the PyCharm IDE. The suggested change by @rossbar accuratly represents the return objects of  `MultiGraph.degree`
comment
>  How can it return an int?  It's true that the function returns a `MultiDegreeView` but as soon as you call the `G.degree` function with `G.degree(1)`the `MultiDegreeView` object is also called with the node provided. If `G.degree` is used a property then yes it will only return a `MultiDegreeView` object but if it's used as a function then it will call the internal machinery of `*DegreeView` which returns an `int` for specific nodes.  The following 2 are equivalent ``` >>> G.degree(1) # returns an int >>> nx.classes.reportviews.MultiDegreeView(G).__call__(1) # returns an int ```  You can read the code for this here, the `__call__` function : https://github.com/networkx/networkx/blob/7bf722bec50682b793feb388b220578f8412ff9d/networkx/classes/reportviews.py#L423-L432  and the `__getitem__` bits: https://github.com/networkx/networkx/blob/7bf722bec50682b793feb388b220578f8412ff9d/networkx/classes/reportviews.py#L590-L603
comment
This is probably because of google colab default python version. They have py3.7 be default and networkx 2.7+ requires python 3.8. So please first update python in your colab session and then you should be able to update the networkx version available in google colab. 
comment
Thanks for the report! This is indeed a mistake, there should be a space between `method` and `[` here:  https://github.com/networkx/networkx/blob/12c1a00cd116701a763f7c57c230b8739d2ed085/networkx/algorithms/community/label_propagation.py#L115  Feel free to submit a PR to fix this!
comment
@kpetridis24 thanks for this but I am not too sure where we stand on this right now. We should have a look at https://github.com/networkx/networkx/issues/1705 again. If we remove the `NetworkX` prefix does the rest of the exception name still make sense? and mypy correctly complains about the cyclic exceptions. These changes should also not be made inside the old documentation of releases.  Also reviewing this PR is pretty much impossible in one go and it looks like you have also committed the `venv` folder ðŸ˜… 
comment
No worries @dtekinoglu! I have done this multiple times too ðŸ˜…   [Disclaimer: this is an ugly fix, its better to use something like `cherry-pick`, but this should be quicker for this change]  The most straightforward way would be to get rid of all the new changes in this branch `improvement-for-issue-5192`.  You can go back in history to the Head - 7th commit [CAUTION: this will remove your recent changes in this branch from your computer, so copy them from the GitHub interface] ``` # in the improvement-for-issue-5192 branch git reset --hard HEAD~7 ``` Now put in the changes for `bethe_hessian_matrix` again and commit them.  While pushing you would need to use `--force` this time. (see ugly) ``` git push --force <your_remote_name> improvement-for-issue-5192 ```
comment
Yeah the indentation isn't right, it returns a sparse matrix. Could you add 2 spaces in front of all the outputs or you can also use `todense` to get a more "friendly" output.  ```python In [12]: H.todense() Out[12]: matrix([[ 3.5625, -1.25  , -1.25  , -1.25  ,  0.    ],         [-1.25  ,  2.5625, -1.25  ,  0.    ,  0.    ],         [-1.25  , -1.25  ,  2.5625,  0.    ,  0.    ],         [-1.25  ,  0.    ,  0.    ,  1.5625,  0.    ],         [ 0.    ,  0.    ,  0.    ,  0.    ,  0.5625]])  ```
comment
@dtekinoglu There were some more indentation problems. I have put them as commit suggestions, you can directly commit them from the GitHub UI by clicking on the `Commit Suggestion` button if you agree with the changes.  Thanks!
comment
I'll keep on updating this PR, https://github.com/networkx/networkx/pull/1894  
comment
Instead of merging one huge PR, I guess we can start updating errors like we do for PEP8 changes. Update them only when you work on the file. 
comment
Thanks @NikitaSharma1!
comment
I'll go ahead and merge this, thanks @Lukong123 for your contribution :)
comment
@Lukong123 please go ahead and submit a Pull Request when you are ready :)
comment
fixed in https://github.com/networkx/networkx/pull/5471
comment
I will close this PR here, feel free to open the PR to the outreachy repository https://github.com/networkx/outreachy/ when the example is ready.
comment
Hi @aliveevie! It's not clear from these changes what's happening here. Also there is already an open Pull Request that fixes the issue #5277 -> https://github.com/networkx/networkx/pull/5323 (We should try to get that merged in!).  But please do review the code in https://github.com/networkx/networkx/pull/5323 too! It would be helpful to get another set of eyes on it :)
comment
I think it's because @mjschwenne is currently part of `triage` team, and that team can move around issues, close them but they can't merge PRs into the `main` branch. 
comment
They have a public beta open. Should I ask them to put us in there?
comment
Yeah that's not good. Thanks for the report!
comment
Thanks @aterrel!
comment
Changing the code with @rossbar suggestions should get you the same results every time.   Editing the code at these 2 places gives me consistent results locally when I run it multiple times :)  ``` python import matplotlib.pyplot as plt import numpy as np  import networkx as nx  nodes = ["1", "2", "3", "4", "5"]  P = nx.Graph() P.add_nodes_from(nodes)  weighted_edges = [     ("1", "2", 0.11),     ("1", "3", 3.1),     ("1", "5", 2.25),     ("4", "5", 0.25),     ("2", "5", 0.2),     ("2", "4", 0.22),     ("2", "3", 0.2), ]  P.add_weighted_edges_from(weighted_edges) # get edges, positions and weights  pos = nx.spring_layout(P, seed=1)  # Add the seed here  labels = nx.get_edge_attributes(P, "weight")  nx.draw(P, pos=pos, with_labels=True)  # add the position argument  # get edge labels edge_labels = dict(     [         (             (u, v),             d["weight"],         )         for u, v, d in P.edges(data=True)     ] ) # add edge labels  nx.draw_networkx_edge_labels(P, pos, edge_labels=edge_labels, font_weight="normal") # no need to create the variable plot  plt.show() ```  Feel free to reopen this issue if you have any other queries :)
comment
unrelated: CircleCI artifacts links appear to be broken. (I can still get them from the CircleCI GUI). Maybe they moved the internal links.
comment
Yup, https://github.com/larsoner/circleci-artifacts-redirector-action/issues/19 it's broken
comment
I have added this to https://github.com/networkx/networkx/wiki/NetworkX-2.0-API-~-DRAFT . I think this is a good time to discuss this further. 
comment
@chebee7i like you initially suggested we should keep `self.adj` and `self.succ` different. And yes this will create a lot chaos for algorithms (as they wont work for mixedgraph). So this is many naive attempt at this.  ``` python def add_undirected_edges(): # Follow the graph class add_edge() def add_directed_edges(): # Follow the digraph class add_edge() with self.succ different from sel.adj def degree(): # give the degree by looking at self.adj def out_degree()/in_degree(): # give the degree by looking at self.pred and self.succ ``` 
comment
Okay I also have a-not-so-great idea. I was going through [Voltage Graphs](https://en.wikipedia.org/wiki/Voltage_graph) and found the concept of "darts". They are basically a cartesian product between the sets of arcs in a directed graph and (+1, -1) [note](http://courses.csail.mit.edu/6.889/fall11/lectures/L02.pdf). Should we discuss this kind of implementation where we add a new characteristic for edges/arcs. 
comment
This is some skeleton code for mixedgraph class  ``` python import networkx as nx from networkx.classes.graph import Graph from networkx.classes.digraph import DiGraph  class MixedGraph(Graph):     node_dict_factory = dict     adjlist_dict_factory = dict     edge_attr_dict_factory = dict     def __init__(self):          self.node_dict_factory = ndf = self.node_dict_factory         self.adjlist_dict_factory = self.adjlist_dict_factory         self.edge_attr_dict_factory = self.edge_attr_dict_factory         self.graph = {}         self.node = ndf()         self.adj = ndf()         self.pred = ndf()         self.succ = ndf()         self.edge=self.adj      def add_node(self, n):         if n not in self.node:             self.adj[n] = self.adjlist_dict_factory()             self.node[n] = attr_dict      def add_undirected_edge(self, u, v, attr_dict=None, **attr):         if attr_dict is None:             attr_dict=attr         if u not in self.adj:             self.adj[u] = self.adjlist_dict_factory()             self.node[u] = {}         if v not in self.adj:             self.adj[v] = self.adjlist_dict_factory()             self.node[v] = {}         datadict = self.adj[u].get(v, self.edge_attr_dict_factory())         datadict.update(attr_dict)         self.adj[u][v] = datadict         self.adj[v][u] = datadict      def add_directed_edge(self, u, v, attr_dict=None, **attr):         if attr_dict is None:             attr_dict=attr         if u not in self.succ:             self.succ[u]= self.adjlist_dict_factory()             self.pred[u]= self.adjlist_dict_factory()             self.node[u] = {}         if v not in self.succ:             self.succ[v]= self.adjlist_dict_factory()             self.pred[v]= self.adjlist_dict_factory()             self.node[v] = {}         datadict=self.succ[u].get(v,self.edge_attr_dict_factory())         datadict.update(attr_dict)         self.succ[u][v]=datadict         self.pred[v][u]=datadict   ```  With the output being something like this  ``` python In [1]: import networkx as nx  In [2]: G = nx.MixedGraph()  In [3]: G.add_undirected_edge(1, 2)  In [4]: G.add_directed_edge(1, 2)  In [5]: G.add_directed_edge(3, 4)  In [6]: G.add_undirected_edge(2, 3)  In [7]: G.adj Out[7]: {1: {2: {}}, 2: {1: {}, 3: {}}, 3: {2: {}}}  In [8]: G.pred Out[8]: {1: {}, 2: {1: {}}, 3: {}, 4: {3: {}}}  In [9]: G.succ Out[9]: {1: {2: {}}, 2: {}, 3: {4: {}}, 4: {}} ```  @dschult Is there any general interest in networkx community regarding an unified class for all types of graphs? 
comment
As @chebee7i suggested we can calculate degree, in_degree, out_degree using combinations of `G.adj`, `G.succ`, `G.pred` 
comment
As @chebee7i pointed out MixedGraph are helpful for Bayesian networks.  http://www.jmlr.org/papers/volume10/silva09a/silva09a.pdf 
comment
@hagberg I think "bi-directed edges" do make sense but the properties won't be well defined. For example, `G.degree()` will return `in_degree + out_degree` and a node(undirected) which was originally supposed to have degree 1 will have degree 2. This may create chaos in implementation of algorithms.  
comment
Thanks!
comment
CI is happy now :) Thanks @solsword!
comment
Thanks @solsword! Please do send a PR with similar changes to `MultiGraph` documentation, it would be great to get the changes for `MultiGraph` in today as we are planning on releasing NetworkX 2.7.2 later today. No worries if you don't have the bandwidth today, I can create the PR instead :) 
comment
Thanks for this @cvanelteren!  There are merge conflicts in one of the file plus we don't setup git submodules while running the CI.  I'm generally -1 on adding code through submodules. It would be super great if we could get this in if someone can port the code to python and networkx. We *could* add the package as a dependency and use it but I'm not too excited about new dependencies too.
comment
> What do you mean exactly with porting it to python and networkx?  When I saw cython as a dependency I thought parts of it were written in Cython, but that doesn't seem to be the case. thanks for pointing it out.  We can't include GPL code with NetworkX (this would require re-licensing the code base from BSD to GPL, this is at least what I understand IANAL). If it stays as an optional dependency I'm not sure how it works out (the dynamic linking of GPL code. I am no expert) 
comment
@cvanelteren I'm going to close this for now, but thanks for starting up the conversation! I would like to see ForceAtlas2 included, but implemented specifically for NetworkX. The original paper https://doi.org/10.1371/journal.pone.0098679 would be good starting point :)
comment
thanks!
comment
We conform with the Google requirements :)
comment
nx-guides is updated https://github.com/networkx/nx-guides/pull/62 and I think we have no more py3.10 specific bits in our CI anymore.  We can close this :)
comment
+1 on deprecation. I'm not sure if we still need `make_small_graph`, `from_dict_of_lists` is definitely more canonical NetworkX IMO.  PS: Most of the `make_small_graph` code hasn't been touched in 17 years!
comment
Thanks for filing this! All of the formats should have better support now.   - GraphML succeeds (it's saved as a string but it can recovered back to ints  ``` python >>> nx.write_graphml(graph, 'graph.graphml') >>> G = nx.read_graphml('graph.graphml',node_type=int) >>> nx.is_isomorphic(G, graph) True ```  - It also works with GML by using (de)stringizer ``` python >>> nx.write_gml(graph, 'graph.gml', stringizer=str) >>> G = nx.read_gml('graph.gml', destringizer=int) >>> nx.is_isomorphic(G, graph) True ``` I'm closing this one, feel free to open a new issue if there are any issues :)
comment
Can you look at the output of `data_frame`? I am not able to reproduce this.  Does it matches a schema like this? ``` python In [1]: import pandas as pd  In [2]: df = pd.DataFrame({'col1': [0, 1], 'col2':[3, 0], 'weight': [0.1, 3.4]})  In [3]: df Out[3]:    col1  col2  weight 0     0     3     0.1 1     1     0     3.4 ```  Running the minimal example below seems to work for me.  ``` python In [1]: import networkx as nx  In [2]: import pandas as pd  In [3]: df = pd.DataFrame({'col1': [0, 1], 'col2':[3, 0], 'weight': [0.1, 3.4]})  In [4]: G = nx.DiGraph()  In [5]: nx.from_pandas_edgelist(df, source= 'col1', target = 'col2', edge_attr=True, create_using = G) Out[5]: <networkx.classes.digraph.DiGraph at 0x108504940>  In [6]: nx.is_weighted(G) Out[6]: True  In [7]: G.edges.data() Out[7]: OutEdgeDataView([(0, 3, {'weight': 0.1}), (1, 0, {'weight': 3.4})]) ```
comment
If this is the output of dataframe it should give you an error while you run `from_pandas_edgelist(data_frame, source= 'col1', target = 'col2', edge_attr=True, create_using = G)` as `col1 != COL1`.  It would be great if you can you give a minimal example where it's failing. Thanks!
comment
I don't think it's used anywhere inside networkx (the need for keeping a track of the contraction) but it's definitely something that people use (I remember using it for a project). This is also an issue with supporting a bunch of different formats (this would be perfectly fine to be exported as a JSON blob for example).  I agree with @rossbar this should raise a better exception rather than the cryptic error, we should error out more gracefully. That will also take care of the cases where folks added containers as edge attributes and ended up getting these cryptic errors. Thanks for raising this @taylorn3!
comment
I'm going to go ahead and merge this ðŸ¥³   The performance of the loops could probably be optimized further (not sure if the code would remain nicely readable like this in that case ðŸ™ƒ)    
comment
I think we can merge this in now, we can further iterate on this in https://github.com/networkx/networkx/pull/5262  Are there any other blockers @rossbar ?
comment
I'll go ahead and merge this then ðŸ˜„ 
comment
Woopsie, sorry about that ðŸ˜… 
comment
Support for shapefiles I/O is deprecated in NetworkX https://github.com/networkx/networkx/pull/4298. There are a bunch of [new examples in our gallery for users who want to work with geospatial data and networkx](https://networkx.org/documentation/latest/auto_examples/index.html#geospatial).  https://github.com/geopandas/geopandas/issues/1592 discusses the enhancement proposal of interop between geopandas and networkx.
comment
Merging this in to update the project list, started a discussion at https://github.com/networkx/networkx/discussions/5111 to get everyones consent before adding links/proposals from previous participants.
comment
https://github.com/actions/python-versions/releases python "3.10" is available now on github action :) 
comment
NOTE: The test fail is due to tests running on 3.7.
comment
Thanks @SimoneGasperini! I am closing this as the changes you have made in this PR have been incorporated in https://github.com/networkx/networkx/commit/4866d572f2cdb18016d67e7dbe5792b473e446db.
comment
@KHBAAW Please update your networkx installation or your decorator installation to the latest versions. 
comment
Could you try deleting networkx and then reinstalling it? Maybe it will solve the dependencies issues as newer versions of networkx don't depend on decorator.
comment
> fresh install of Anaconda Individual edition  This could be the issue, as the Anaconda distribution could have pinned to a previous release by default instead of the latest one. Could you confirm the version of networkx and decorator after a fresh install?  Something like ```python In [1]: import networkx as nx  In [2]: nx.__version__ Out[2]: 'X.X.X'  In [3]: import decorator  In [4]: decorator.__version__ Out[4]: 'X.X.X' ```
comment
thanks for this @divyanx! Could you also please add some tests for this? They should go in `networkx/algorithms/shortest_paths/tests/`
comment
Hi @divyanx, sure thing! Please go ahead. As a first step you can setup a local development environment for NetworkX, the instructions to setup the environment are present in the [Contributor Guide](https://networkx.org/documentation/latest/developer/contribute.html). You can also go through the [New Contributor FAQ](https://networkx.org/documentation/latest/developer/new_contributor_faq.html) for some general FAQs. Let us know if there are any other questions about this!
comment
>  Is there a reasonable way to run the corrected version until then?  You can install the main branch which has the changes by using pip:  ``` pip install git+https://github.com/networkx/networkx.git ```  Feel free to reopen this issue if the error persists.
comment
Have a look at https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.connectivity.stoerwagner.stoer_wagner.html  This should solve the min cut point problem for an undirected, unweighted graph without terminal nodes.
comment
If the graph is a "proper" barbell graph (the hairballs on either sides connected) `nx.minimum_edge_cut(G)` should give you the required details about the edge in between the hairballs. Example: <img width="543" alt="Screenshot 2020-10-07 at 21 17 31" src="https://user-images.githubusercontent.com/5363860/95355026-b9eed400-08e2-11eb-985f-55f110c4d565.png">   PS: I am not sure if this the most optimal way of doing this.
comment
Can you try `nx.minimum_edge_cut(G)` for this if it doesn't give you the desired cut you can pick one node from hairball A and one node from hairball B  and execute `nx.minimum_edge_cut(G, node_from_hairball_A, node_from_hairball_B)` (assuming you are doing this "visually")
comment
Thanks @bt-nia!
comment
> Why would networkx always load everything including OpenBLAS?  NetworkX shouldn't be loading OpenBLAS (numpy brings that in), we don't have numpy as a base dependency anymore. Can you give some more information about the environment?
comment
Yay! This is amazing :)
comment
I tried this with the data provided but it looks like both `first_graph_to_git.csv` and `graph_to_git.csv` are the same files ``` python >>> all(pd.read_csv('first_graph_to_git.csv') == pd.read_csv('graph_to_git.csv')) True ``` Could you link to the dataset with the old data?
comment
So I started looking at the data and it seems like yes there are more than a million cycles in the new data but it doesn't seem like a bug in the code, maybe how this data is generated? (assuming you are expecting it have 100-200 cycles).  On the networkx implementation side most of it seems to follow the definition of a simple cycle in a directed graph. They are unique cycles.  I have added some code below I used while thinking through this.  ``` python import pandas as pd import networkx as nx from collections import defaultdict  old = nx.from_pandas_edgelist(pd.read_csv('first_graph_to_git.csv'), create_using=nx.DiGraph()) new = nx.from_pandas_edgelist(pd.read_csv('graph_to_git.csv'), create_using=nx.DiGraph()) ```  Number of cycles ``` python >>> len(list(nx.simple_cycles(old))) 60 >>> len(list(nx.simple_cycles(new))) 1148313 ```  Let's look at the paths and their length. ``` python paths = defaultdict(list) for i in nx.simple_cycles(new):     paths[len(i)].append(i) ```  There are more than 90k cycles just of length 27. ``` python >>> sorted([(len(j), i) for i, j in paths.items()]) [(4, 46),  (11, 3),  (20, 4),  (20, 5),  (24, 6),  (26, 2),  (55, 7),  (56, 45),  (82, 8),  (187, 9),  (348, 44),  (358, 10),  (718, 11),  (1317, 12),  (1318, 43),  (2393, 13),  (3515, 42),  (4099, 14),  (6736, 15),  (7251, 41),  (10569, 16),  (12189, 40),  (15859, 17),  (16705, 34),  (17219, 39),  (17884, 33),  (18838, 35),  (20948, 38),  (21355, 36),  (22374, 37),  (22541, 18),  (25297, 32),  (30617, 19),  (40109, 31),  (40256, 20),  (51687, 21),  (60018, 30),  (63908, 22),  (74944, 23),  (79311, 29),  (83546, 24),  (89967, 25),  (92193, 28),  (94809, 26),  (96632, 27)] ```   Let's look at a subgraph from just one of these paths. ``` python temp = nx.subgraph(new, paths[27][0]) nx.draw_circular(temp) ``` <img width="541" alt="Screenshot 2021-07-30 at 15 11 20" src="https://user-images.githubusercontent.com/5363860/127657725-08c83d1c-cf55-43a3-ba2b-342e2a14c08f.png">  As you can see this isn't really a large graph, just 27 nodes and 51 edges. ``` python >>> temp.number_of_edges(), temp.number_of_nodes() (51, 27) ``` and it has 1008 cycles, as @dschult mentioned, these cycles add up pretty quickly. ``` python >>> len(list(nx.simple_cycles(temp))) 1008 ```  I would maybe look at the data generation process, if you expecting low number of cycles in the graph. It looks like the graph structure of the old dataset seemed to have "lucked" out in terms of cycles inside. 
comment
I'm not able to reproduce this with a fresh environment.  In the error traceback it says `networkx.barabasi_albert_graph(Integer(6),Integer(1))` where is the `Integer` object coming from?
comment
It's a styling error, could you run `black` on the files in the PR?  https://github.com/psf/black#installation ``` $ pip install black $ black networkx/algorithms/bipartite/extendability.py networkx/algorithms/bipartite/tests/test_extendability.py ``` 
comment
Shouldn't we also add `multigraph_input=True` explicitly to the `__init__` constructors of `Multi(Di)Graph`?  This wouldn't fix #4824 as we would still need to pass `multigraph_input=True` while giving `MultiGraph` a dict-o-dict-o-dict-o-dict data structure.  ``` diff --git a/networkx/classes/multigraph.py b/networkx/classes/multigraph.py index 1779a616..e3758531 100644 --- a/networkx/classes/multigraph.py +++ b/networkx/classes/multigraph.py @@ -306,7 +306,7 @@ class MultiGraph(Graph):           """          self.edge_key_dict_factory = self.edge_key_dict_factory -        Graph.__init__(self, incoming_graph_data, **attr) +        Graph.__init__(self, incoming_graph_data, multigraph_input=True, **attr)       @property      def adj(self): ```  With this PR:  ```python In [1]: import networkx    ...: g = networkx.MultiGraph({'a': {'b': {0: {'w': 200}, 1: {'w': 201}}}})    ...: print(g.edges)    ...: h = networkx.MultiGraph()    ...: h.add_edges_from([('a', 'b', {"w": 200}), ('a', 'b', {"w": 201})])    ...: print(h.edges) [('a', 'b', 0)] [('a', 'b', 0), ('a', 'b', 1)] ```  After forcing all the incoming data to be `multigraph_input=True` ``` python In [1]: import networkx    ...: g = networkx.MultiGraph({'a': {'b': {0: {'w': 200}, 1: {'w': 201}}}})    ...: print(g.edges)    ...: h = networkx.MultiGraph()    ...: h.add_edges_from([('a', 'b', {"w": 200}), ('a', 'b', {"w": 201})])    ...: print(h.edges) [('a', 'b', 0), ('a', 'b', 1)] [('a', 'b', 0), ('a', 'b', 1)]  ``` 
comment
These are all just opinions, feel free to ignore them :)  > we need to allow users to specify multigraph_input=False even for a MultiGraph constructor.  How about something like this? ``` diff --git a/networkx/classes/multigraph.py b/networkx/classes/multigraph.py index 1779a616..c8078992 100644 --- a/networkx/classes/multigraph.py +++ b/networkx/classes/multigraph.py @@ -306,7 +306,10 @@ class MultiGraph(Graph):           """          self.edge_key_dict_factory = self.edge_key_dict_factory -        Graph.__init__(self, incoming_graph_data, **attr) +        if incoming_graph_data is not None and 'multigraph_input' not in attr: +            Graph.__init__(self, incoming_graph_data, multigraph_input=True,  **attr) +        else: +            Graph.__init__(self, incoming_graph_data, **attr) ``` We can deal with both `multigraph_input` bool values and if the user wants they can explicitly turns it False.  ``` python In [1]: import networkx  In [2]: g = networkx.MultiGraph({'a': {'b': {0: {'w': 200}, 1: {'w': 201}}}})  In [3]: print(g.edges) [('a', 'b', 0), ('a', 'b', 1)]  In [4]: g = networkx.MultiGraph({'a': {'b': {0: {'w': 200}, 1: {'w': 201}}}}, multigraph_input=False)  In [5]: print(g.edges) [('a', 'b', 0)] ```  The reason I'm thinking of this change is to make this roundtrip work as default behaviour without the need to provide `multigraph_input` as I guess if we are creating a MultiGraph it should probably expect a `multigraph_input` by default? (I would probably expect this). ``` python In [14]: h = networkx.MultiGraph()  In [15]: h.add_edges_from([('a', 'b', {"w": 200}), ('a', 'b', {"w": 201})]) Out[15]: [0, 1]  In [16]: g = networkx.MultiGraph(networkx.to_dict_of_dicts(h))  In [17]: networkx.is_isomorphic(g, h) Out[17]: True ``` 
comment
This looks great to me! thanks @dschult!  > Should this require a deprecation? It changes the API, but it is a feature that was hardly used and can be seen as fixing a defect instead of changing the API.  I see this as a bug fix too, so this can just show up in the API changes part of the release log.  > Notice that this will make the default different from the default for to_networkx_graph. That breaks the mirrored behavior of `H = nx.MultiGraph(dod)` and `H = nx.to_networkx_graph(dod)`. Should we worry about these giving different results? That is, should we also change the default input for nx.to_networkx_graph?  IMO `H = nx.MultiGraph(dod)` and `H = nx.to_networkx_graph(dod)` are independent things, for the first one the user creates a multigraph explicitly so they know what they are expecting, in the other case they are asking networkx to infer the graph object for them, so I think it's okay for these functions to not be mirrored.    > My current view is to make the default for `nx.MultiGraph(dod)` use `multigraph_input=True` while `nx.to_networkx_graph(dod, create_using=nx.MultiGraph)` defaults to `multigraph_input=False`. But I seem to change preference from one day to the next. Thoughts?  I think we should default to `multigraph_input=True` with `nx.to_networkx_graph(dod, create_using=nx.MultiGraph)` too, as the user could see that equivalent to `nx.MultiGraph(dod)`.  IMO it's okay if `nx.MultiGraph(dod)` != `nx.to_networkx_graph(dod)` but `nx.MultiGraph(dod)` == `nx.to_networkx_graph(dod,  create_using=nx.MultiGraph)`.  Let me know if this makes sense :) 
comment
> Really, the type of the incoming data object should be indepedent of the type of the constructed graph. I think that is true for both to_networkx_graph(...) and for nx.MultiGraph(...). Thoughts?  Ah yes, I like this.  I guess we should only enforce `multigraph_input` to maintain round trip between `nx.to_dict_of_dicts` and `nx.MultiGraph`. A dictionary structure which is dumped using a networkx function should be able recreate the initial networkx object.
comment
@timebarn I'm not sure if the example provided would be a valid data structure for a networkx `MultiGraph`. An edge can't have two values for the same attribute in the way provided in the example. A way of achieving something like this would be ``` python In [56]: G = nx.MultiDiGraph()  In [57]: G.add_edge('a', 'b', attr='foo') Out[57]: 0  In [58]: G.add_edge('a', 'b', attr='bar') Out[58]: 1  In [59]: G.add_edge('c', 'd', attr={0: 'foo', 1: 'bar'}) Out[59]: 0  In [60]: nx.to_dict_of_dicts(G) Out[60]: {'a': {'b': {0: {'attr': 'foo'}, 1: {'attr': 'bar'}}},  'b': {},  'c': {'d': {0: {'attr': {0: 'foo', 1: 'bar'}}}},  'd': {}} ``` The third layer of the dictionary will always be the edge id not the attributes in a `Multi(Di)Graph`. ``` python {'first_node':          {'second_node':                {'edge_id':                      {'attribute_1': any object                       'attribute_2': any object }}}} ```  Let me know if I am misunderstanding this :)
comment
> This is exactly what I'm speaking about; when initializing, you can't know if the third dict refers to many edges and the keys are IDs or it refers to just one edge and the keys are attributes.   Oh yeah currently the behaviour **is** broken, I am advocating for making it accept third dict as edge IDs by default and IMO the third layer should always be the edge_id because that is what the networkx MultiGraph data structure expects.  The following code should work after this behaviour is fixed. ``` python In [14]: h = networkx.MultiGraph()  In [15]: h.add_edges_from([('a', 'b', {"w": 200}), ('a', 'b', {"w": 201})]) Out[15]: [0, 1]  In [16]: g = networkx.MultiGraph(networkx.to_dict_of_dicts(h))  In [17]: networkx.is_isomorphic(g, h) Out[17]: True ``` and the example given in the original issue will be fixed by https://github.com/networkx/networkx/pull/4823 ``` python g = networkx.MultiGraph({'a': {'b': {0: {'w': 200}, 1: {'w': 201}}}}) print(g.edges) h = networkx.MultiGraph() h.add_edges_from([('a', 'b', {"w": 200}), ('a', 'b', {"w": 201})]) print(h.edges)  output  [('a', 'b', 0), ('a', 'b', 1)] [('a', 'b', 0), ('a', 'b', 1)] ``` I am not sure why should we have `multigraph_flag` for every edge. One *can* add `0:{"attr":"foo"},1:{"attr":"bar"}` as an edge attribute but that would require people going in and changing the underlying `_adj` dictionary, but even after that the structure would be something like this ``` python In [46]:  G = nx.MultiGraph()  In [47]: G.add_edge(1, 2) Out[47]: 0  In [48]: G._adj[1][2][0] = {0:{"attr":"foo"}, 1:{"attr":"bar"}}  In [49]: G._adj Out[49]: {1: {2: {0: {0: {'attr': 'foo'}, 1: {'attr': 'bar'}}}},  2: {1: {0: {0: {'attr': 'foo'}, 1: {'attr': 'bar'}}}}} ```  Something like the given example ``` nx.MultiGraph({'a':{'b':{'multigraph_flag':True,0:{"attr":"foo"},1:{"attr":"bar"}}}, 'c':{'b':{'multigraph_flag':False (or not specifying) ,0:{"attr":"foo"},1:{"attr":"bar"}}) ``` would be mixing MultiGraphs (d-o-d-o-d-o-d) with Graphs (d-o-d-o-d) and I am not sure if we should support that.
comment
This looks great!
comment
v2.6 should be out by May 31st. We have removed pyyaml from v2.6 https://github.com/networkx/networkx/pull/4802 so it should solve these issues.
comment
yeah, same behaviour here, works in ipython, fails with vanilla python interpreter. (I still don't know why)
comment
thanks @bkbncn, the CI fail is fixed in `main` branch.
comment
The  `KeyError` (`KeyError: 'expiry'`)  pops up when there is no key in the attribute dictionary, i.e the attribute `expiry` is not present in the edge of the `modelgraph`. I think (just a speculation) this is happening only in one case because the key `expiry` is not set properly for all the edges in the graph. A quick example:   ``` python  In [1]: import networkx as nx  In [2]: G = nx.DiGraph()  In [3]: G.add_edge(1, 2, expiry=1) # the outgoing edge from node 1 has the attribute expiry set to 1  In [4]:  G.add_edge(2, 1) # the attribute expiry is missing in the incoming edge.  In [5]: [(a, b) for a, b in G.out_edges(1) if G[a][b]['expiry'] == 1] Out[5]: [(1, 2)]  In [6]: [(a, b) for a, b in G.in_edges(1) if G[a][b]['expiry'] == 1] --------------------------------------------------------------------------- KeyError                                  Traceback (most recent call last) <ipython-input-6-45b0424c3541> in <module> ----> 1 [(a, b) for a, b in G.in_edges(1) if G[a][b]['expiry'] == 1]  <ipython-input-6-45b0424c3541> in <listcomp>(.0) ----> 1 [(a, b) for a, b in G.in_edges(1) if G[a][b]['expiry'] == 1]  KeyError: 'expiry' ```   
comment
Could you provide a bit more details about the crash? Does it output any error? 
comment
Could you update decorator version to v5.0.7 (`pip install decorator==5.0.7`) and try again? This is a known issue https://github.com/networkx/networkx/issues/4718.
comment
Thanks for this @DebarghaG! As part of our tests we run the examples too, so could you update the code to define a graph `G`? ``` python >>> import networkx as nx >>> from networkx.algorithms import approximation >>> G = nx.erdos_renyi_graph(10, 0.2) >>> approximation.average_clustering(G, trials=1000, seed=None) ```
comment
ahh, it expects to check the output too, so do put in the output too and change the seed from `None` otherwise we can't guarantee the reproducibility of the output.  ``` python >>> import networkx as nx >>> from networkx.algorithms import approximation >>> G = nx.erdos_renyi_graph(10, 0.2) >>> approximation.average_clustering(G, trials=1000, seed=42) 0.085 ```
comment
By default [this](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.cluster.average_clustering.html?highlight=average_clustering#networkx.algorithms.cluster.average_clustering) `avergage_clustering` is imported in the nx namespace, so to access the one in the `approximation` module you would need something like ``` python >>> from networkx.algorithms import approximation >>> approximation.average_clustering(G, trials=1000, seed=None) ...... ```  We should definitely add this as an example in the [function documentation](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.approximation.clustering_coefficient.average_clustering.html#networkx.algorithms.approximation.clustering_coefficient.average_clustering).
comment
closing this for https://github.com/networkx/networkx/pull/4735
comment
There are no `TypeHints` in NetworkX and we can't control what/how PyCharm infers them.
comment
BTW this discussion is more suited towards GitHub discussions (moving this issue to discussions).   > My guess is that networkx does not explicitly depend on numpy nor scipy, and thus there is a version of this function for when one of those packages is not installed. As a rule of thumb, if you have numpy on your system : use the numpy version !  Yes numpy/scipy weren't hard dependencies of networkx but now they are and we will be updating the code(https://github.com/networkx/networkx/issues/4371) to use numpy version by default whenever someone uses `eigenvector_centrality`, currently if you want to access the numpy version you need to use `eigenvector_centrality_numpy`. The python implementation will stay in our codebase for reference (if someone just wants to read it or use it without numpy/scipy).
comment
@NareshPeshwe https://networkx.github.io/documentation/networkx-1.9.1/reference/generated/networkx.algorithms.approximation.independent_set.maximum_independent_set.html#networkx.algorithms.approximation.independent_set.maximum_independent_set 
comment
This should give a better answer than the approximation but it is highly inefficient. What do you think @hagberg ? 
comment
This code includes a mix of tabs and space. Have a look at https://www.python.org/dev/peps/pep-0008/ :) (use 4 spaces for indentation) 
comment
this looks like a good candidate for sprints?
comment
This is fixed in NetworkX 2.5 https://github.com/networkx/networkx/pull/3841. Can you update networkx locally and test it out? ``` $ pip install networkx==2.5 ``` 
comment
Could you also look at the pyyaml version on your machine?  ``` python >>> import yaml >>> yaml.__version__ ```  There are recent changes in the way yaml Loader works which could have broken this https://github.com/yaml/pyyaml/blob/master/CHANGES  The following code should work with  Python 3.7, NetworkX 2.4, PyYAML 5.1  ``` python import networkx as nx G = nx.Graph() G.add_edges_from([(0,1)]) nx.write_yaml(G, "test.yaml") nx.read_yaml("test.yaml") ```  
comment
This has been fixed in the master branch and it should be out in the 2.6 release (https://github.com/networkx/networkx/commit/a6dd458a12ad8db161271e2271644803d4f29a96, https://github.com/networkx/networkx/issues/4569). Till then you would need to downgrade pyyaml to 5.1 for this to work. ``` $ pip install pyyaml==5.1 ```
comment
Can you test the build with the latest master branch too? https://github.com/networkx/networkx/commit/a6dd458a12ad8db161271e2271644803d4f29a96 should have fixed it.
comment
`black` seems happy now, failed tests are due to the recent `yaml` issue. Should be fixed after https://github.com/networkx/networkx/pull/4548 is merged.  
comment
Couple of points: - There is no need to open and close the file, `read_weighted_edgelist` and `write_weighted_edgelist` will take care of that. - The graph `G1` in your code is a normal `Graph` not a `DiGraph`, you need to provide `read_weighted_edgelist` with the argument `create_using=nx.DiGraph`  The following changes to your code should make this work.  ``` python G = nx.DiGraph() weightededgelist = [[ ......... ]] G.add_weighted_edges_from(weightededgelist)  # to write to edges.csv in the current directory nx.write_weighted_edgelist(G, 'edges.csv', delimiter=',')  # read the edges.csv to a directed graph G1 and cast nodes as int instead of str G1 = nx.read_weighted_edgelist('edges.csv', delimiter=',', nodetype=int, create_using=nx.DiGraph) ```  ``` >>> G1.edges == G.edges True ```  You can look at the [documentation here](https://networkx.org/documentation/stable//reference/readwrite/generated/networkx.readwrite.edgelist.read_weighted_edgelist.html#networkx.readwrite.edgelist.read_weighted_edgelist).  PS: the weights still need to converted from floats to int in the graph `G1`.  ``` python In [31]: G1[25][27] Out[31]: {'weight': 7.0}  In [32]: G[25][27] Out[32]: {'weight': 7}  # expected failure  In [33]: G1.edges(data=True) == G.edges(data=True) Out[33]: False ```
comment
A network with 200 million weighted edges wouldn't be possible with networkx unless you have a heavy duty server at your disposal :) You can look at tools like [graph-tool](https://graph-tool.skewed.de/), [SNAP](http://snap.stanford.edu/), [igraph](https://igraph.org/) or if you have access to a GPU [CuGraph](https://github.com/rapidsai/cugraph).
comment
The linked dot file is pretty big. How big is the graph? (nodes and edges)
comment
It does look like the project is non maintained anymore, and I am not aware if this is still used. +1 on deprecating it.
comment
The `subgraph_view` should be pickleable. Where is the `gridmap_to_nx.<locals>.filter_node` part coming from?  Example:  ``` python In [2]: G = nx.erdos_renyi_graph(100, 0.2)  In [3]: def filter_node(n):     ...:     return bool(n%2)     ...: In [4]: view = nx.subgraph_view(G, filter_node=filter_node)  In [5]: nx.write_gpickle(view, 'view.pickle')  In [6]: view_read = nx.read_gpickle('view.pickle')  In [7]: view_read.nodes() == view.nodes() Out[7]: True  ```
comment
`write_gpickle` just calls `pickle.dump`  https://github.com/networkx/networkx/blob/ef1c828560856c2dfd85c7892829202fa88a9970/networkx/readwrite/gpickle.py#L67   not sure what `cachier` is doing underneath.  Try using `nx.subgraph()` instead of `nx.subgraph_view()` to create the subgraph?  ``` python  In [2]: G = nx.erdos_renyi_graph(100, 0.2)  In [3]: def filter_nodes(G):    ...:     return [node for node in G.nodes() if node%2 == 0]    ...:  In [4]: nodes = filter_nodes(G)  In [5]: nx.subgraph(G, nodes) ```    
comment
neighbours != degree when looking at graphs with self loops.  ``` python In [2]: G = nx.Graph()  In [3]: G.add_edge(1, 1)  # Neighbours are the nodes adjacent to a node. In [4]: list(G.neighbors(1)) Out[4]: [1]  # Degree of a node with a self loop is a special case and is counted twice. In [5]: nx.degree(G) Out[5]: DegreeView({1: 2}) ``` 
comment
Will CuGraph work with our CI? (It needs cuda)
comment
Thanks @ljwolf for this!  > what do you think about whether we need to have the files stored in the directory or not?  If the dataset (or a slice of it) is small enough <0.5MB, keeping it inside the example repo should be perfectly fine IMO. 
comment
You can use a subgraph view to filter out the nodes (not tested) ``` python # Create a generator to find all the nodes which have a specific substring def filter_nodes(G, node_name):     for n in G.nodes:         if node_name in n:             yield n  G = nx.subgraph(G, filter_nodes(G, "pu.edu.tw")) nx.write_gml(G, "finaltest.gml") ```
comment
>  keep specific node that related to 'pu.edu.tw' so that edges won't missing. or some way to reconnect node  ah my last comment won't solve this.  As this is a directed graph do you want keep all the nodes which are connected to `pu.edu.tw` nodes irrespective of direction or do you want to keep specific `node -> pu.edu.tw`/`pu.edu.tw-> node` connections?  ``` python # this will keep both node -> pu.edu.tw / pu.edu.tw -> node def filter_edge(u, v, k):     if "pu.edu.tw" in u or "pu.edu.tw" in v:         return True     return False  G = nx.subgraph_view(G, filter_edge=filter_edge) nx.write_gml(G, "finaltest.gml") ```
comment
Can you check if the following code solves the issue for you?  ``` python G = nx.read_gml('test.gml')  def filter_edge(u, v, k):     if "pu.edu.tw" in u or "pu.edu.tw" in v:         return True     return False  G = nx.subgraph_view(G, filter_edge=filter_edge) nx.write_gml(G, "finaltest.gml") ```
comment
Can you try drawing the graph?  What does the following code outputs? ``` python G = nx.read_gml('test.gml')  def filter_edge(u, v, k):     if "pu.edu.tw" in u or "pu.edu.tw" in v:         return True     return False  G = nx.subgraph_view(G, filter_edge=filter_edge)  nx.draw(G, with_labels=True) ``` 
comment
ahh okay.  Let's try this one more time :)  Does the following code work for you? ``` python G = nx.read_gml('test.gml')  def filter_edge(u, v, k):     if "pu.edu.tw" in u or "pu.edu.tw" in v:         return True     return False  G = nx.subgraph_view(G, filter_edge=filter_edge).copy() G.remove_nodes_from(list(nx.isolates(G))) nx.write_gml(G, "finaltest.gml")  ```
comment
Sure :)  ``` python G = nx.read_gml('test.gml')  # Create a filter which returns True if the start node or the end node of # an edge has "pu.edu.tw" in its name. def filter_edge(u, v, k):     if "pu.edu.tw" in u or "pu.edu.tw" in v:         return True     return False  # Create a subgraph view using the filter (we use copy() to create a copy # as we want to modify this graph in the next step) G = nx.subgraph_view(G, filter_edge=filter_edge).copy()  # isolates finds the nodes which aren't connected to any other node # (degree = 0) and we remove all the nodes from the graph we filtered. G.remove_nodes_from(list(nx.isolates(G)))   nx.write_gml(G, "finaltest.gml") ```  You can also read the documentation for [subgraph_view](https://networkx.org/documentation/stable//reference/generated/networkx.classes.function.subgraph_view.html) and [isolates](https://networkx.org/documentation/stable//reference/algorithms/generated/networkx.algorithms.isolate.isolates.html#networkx.algorithms.isolate.isolates)
comment
@suvayu Can you look at the failing tests?
comment
Putting this here just for reference:  We can also directly use `nx.degree_histogram` with `plt.bar`  ``` python degree_hist = nx.degree_histogram(G) deg = range(len(degree_hist))  plt.bar(deg, degree_hist, width=0.80, color='b') plt.show() ```  if using `plt.hist`  (is there a better way to plot it?)  ``` python values = [d for n, d in G.degree()] bins = max(values) - min(values) # multiply this by 2 to make it more "pretty" plt.hist(values, bins) plt.show() ```  NOTE: The `nx.degree_histogram` way will include all distribution from degree 0 even if no node exists there, one way to remove that ``` python degree_hist = nx.degree_histogram(G) deg = range(len(degree_hist))  for i, j  in enumerate(degree_hist):     if j != 0:         start = i         break  plt.bar(deg[start:], degree_hist[start:], width=0.80, color='b')  ```
comment
Yeah it looks like networkx will always add the edge key irrespective of `named_key_ids`  https://github.com/networkx/networkx/blob/8411e59ac840eecff618b20861f911ae1eecffed/networkx/readwrite/graphml.py#L537-L539  A temporary fix would be to make sure distinct keys are added while adding edges to the `MultiGraph` object. ``` python c = itertools.count() G = nx.MultiDiGraph(((0, 1, next(c)), (0, 1, next(c)), (1, 2, next(c)), (2, 0, next(c)))) nx.write_graphml(G, './test.graphml') ``` Generates: ``` <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"> <graph edgedefault="directed"> <node id="0"/> <node id="1"/> <node id="2"/> <edge source="0" target="1" id="0"/> <edge source="0" target="1" id="1"/> <edge source="1" target="2" id="2"/> <edge source="2" target="0" id="3"/> </graph></graphml> ```
comment
@rossbar `git commit --amend --no-edit && git push -f` my not so pretty way of re-trigging builds.
comment
You can create a custom key when you are adding edges to your MultiDiGraph.  ``` python In [20]: G = nx.MultiDiGraph()  In [21]: G.add_edge(1, 2, key='my_key_2', weight='lol') Out[21]: 'my_key_2'  In [22]: G.add_edge(1, 2, key='my_key_1', weight=10) Out[22]: 'my_key_1'  In [27]: G.edges[1, 2, 'my_key_1'] Out[27]: {'weight': 10}  In [28]: G.edges[1, 2, 'my_key_2'] Out[28]: {'weight': 'lol'} ```  
comment
I believe there isn't anything needs to be done for that? NetworkX already supports 3.9. I guess we should change the travis test from 3.9-dev to 3.9.
comment
We also need to wait for GitHub python checkout action and Appveyor to have a stable 3.9 release to turn on CI there.
comment
Good catch! The relabel should have preserved both values 'a' and 'b'. Feel free to submit a pull request with a fix for this.
comment
``` {     "list": {         "Elements": [             {"id":1, "text":"open browser", "Shape":"Rectangle"},             {"id":2, "text":"type username", "Shape":"Rectangle"},             {"id":3, "text":"type password", "Shape":"Rectangle"},             {"id":4, "text":"click on submit button", "Shape":"Rectangle"},             {"id":5, "text":"user logged in", "Shape":"Decision"},             {"id":6, "text":"user password is wrong", "Shape":"Rectangle"}         ],         "links": [             {"source":"1", "Target":2},             {"source":"2", "Target":3},            {"source":"3", "Target":4},             {"source":"4", "Target":5},            {"source":"4", "Target":6}                      ]     } } ``` This is essentially a different format. It is **not** possible to get that output from json_graph.node_link_data(G).  To get something closer to it, you could try to map a node integer to a "text" attribute. Have a look at the following code block ``` python def get_graph_from(dataList):     G = nx.Graph()     for j, i in enumerate(range(0, len(dataList)-1)):         curr_val = dataList[i]         next_val = dataList[i+1]         if (curr_val=='nan' or next_val=='nan'):              continue         if not G.has_edge(j, j+1):             G.add_node(j, text=curr_val)      # add individual node information you can add as many attributes you like             G.add_node(j+1, text=next_val)  # you can also shape here by doing something like G.add_node(j+1, text=..., shape=...)             G.add_edge(j, j+1)     return G ```  You would get the following JSON output ``` {'directed': False,  'multigraph': False,  'graph': {},  'nodes': [{'text': 'open browser', 'id': 0},   {'text': 'type username', 'id': 1},   {'text': 'type password', 'id': 2},   {'text': 'click on submit button', 'id': 3},   {'text': 'user loged in', 'id': 4},   {'text': 'open browser', 'id': 6},   {'text': 'type username', 'id': 7},   {'text': 'type password', 'id': 8},   {'text': 'click on submit button', 'id': 9},   {'text': 'user password is wrong', 'id': 10}],  'links': [{'source': 0, 'target': 1},   {'source': 1, 'target': 2},   {'source': 2, 'target': 3},   {'source': 3, 'target': 4},   {'source': 6, 'target': 7},   {'source': 7, 'target': 8},   {'source': 8, 'target': 9},   {'source': 9, 'target': 10}]} ```  But you still have to manipulate to get your desired output. The following function will get you your desired output from the networkx JSON output. ``` python def create_custom(json_input):     custom = dict()     custom['list'] = dict()     custom['list']['Elements'] = json_input['nodes']     custom['list']['links'] = json_input['links']     return custom ```  ``` python >>> create_custom(nx_json_out) {'list': {'Elements': [{'text': 'open browser', 'id': 0},    {'text': 'type username', 'id': 1},    {'text': 'type password', 'id': 2},    {'text': 'click on submit button', 'id': 3},    {'text': 'user loged in', 'id': 4},    {'text': 'open browser', 'id': 6},    {'text': 'type username', 'id': 7},    {'text': 'type password', 'id': 8},    {'text': 'click on submit button', 'id': 9},    {'text': 'user password is wrong', 'id': 10}],   'links': [{'source': 0, 'target': 1},    {'source': 1, 'target': 2},    {'source': 2, 'target': 3},    {'source': 3, 'target': 4},    {'source': 6, 'target': 7},    {'source': 7, 'target': 8},    {'source': 8, 'target': 9},    {'source': 9, 'target': 10}]}} ```  
comment
Closing this, @vsharm29 let us know if you have any other issue about this.
comment
It would be nice to also have version warnings on older documentation, something like https://github.com/humitos/sphinx-version-warning 
comment
@GCPBigData the 'a', 'b', 'c' .. on the nodes you see *are* the labels.  with labels  <img width="465" alt="Screenshot 2019-12-21 at 12 06 24 PM" src="https://user-images.githubusercontent.com/5363860/71311109-64e0e080-23ea-11ea-90a0-372288c52f6f.png">  without labels  <img width="413" alt="Screenshot 2019-12-21 at 12 06 35 PM" src="https://user-images.githubusercontent.com/5363860/71311111-6c07ee80-23ea-11ea-9b81-00d80086a114.png"> 
comment
Is there a Dockerfile to reproduce this? I'm stuck on installing scipy (required for spectral_graph_forge test) with the image alpine python image (3.11 and py3.8) `python:3.8-alpine` https://hub.docker.com/_/python
comment
Can you post an example where  write_edgelist and read_edgelist  breaks?
comment
> My intuition is that it should be the other way round: the higher is the combination of edge weights for a node, the higher is the chance that the shortest path will go through that node. Don't you think so?  This will be the other way round. Higher the combination of edge weights for a node, lower the change the shortest path will go through that node.  When we calculate the shortest path between 2 nodes we try to find the path which has the lowest possible cost, for example, let's create a cycle graph. ``` python In [6]: G = nx.cycle_graph(4) In [7]: G.edges() Out[7]: EdgeView([(0, 1), (0, 3), (1, 2), (2, 3)]) In [8]: nx.betweenness_centrality(G) Out[8]: {0: 0.16666666666666666,  1: 0.16666666666666666,  2: 0.16666666666666666,  3: 0.16666666666666666} ``` We get expected results in the case of an unweighted network.  Let's add a weight between node 0 and node 1. ``` python In [11]: G[0][1]['weight'] = 2 In [14]: nx.betweenness_centrality(G, weight='weight') Out[14]: {0: 0.0, 1: 0.0, 2: 0.3333333333333333, 3: 0.3333333333333333} ``` The all_pairs_shortest_path function (which is used underneath while calculating betweenness centrality) will try to avoid the path between node `0-1` as its expensive to go through that, hence higher the combination of edge weights for a node, lower the change the shortest path will go through that node.  One way to counter this and for what you are looking for would be take the inverse of weight. ``` python In [11]: G[0][1]['weight'] = 1/2 In [14]: nx.betweenness_centrality(G, weight='weight') Out[14]: {0: 0.3333333333333333, 1: 0.3333333333333333, 2: 0.0, 3: 0.0} ``` NOTE: You need to be careful with the inverses as edges without weights will have a default weight of 1, which can skew the exact numerical values.
comment
Oh yes definitely, this makes sense. For some use cases having a high capacity or channel throughput is good for an edge. But the standard definition of dijkstra (which is again used underneath and implemented in networkx) interprets weight in the sense of a road network (finding the shortest path between cities, etc.) https://github.com/networkx/networkx/blob/master/networkx/algorithms/shortest_paths/weighted.py#L828 We should probably add a note in the documentation about this so that users keep this in mind while using these centrality measures, and one way to counter this (which I personally use) is to use the inverse function for weights. Do you think there is a better way of keeping both these interpretations? 
comment
> Yes, I think definitely it is very important to add a note into documentation. Should I do it?  Yeah!  > Ultimately it would be great to add a setting to inverse the weights in all calculations where the results may be affected (and the function you said you use). Something like weight_inverse=True (you could keep it False by default).  This is my way of doing it, this is not really a standard way. We should probably wait for more people to weigh in on this.  > Another related question: does this also affect the community detection algorithms in the same way?  This pretty much depends on the community detection algorithm in question. The python-louvain implementation has a weighted case, but I need to read the code to see how it takes care of it. For modularity maximization my gut feeling is that it shouldn't matter.
comment
checkout https://github.com/rapidsai/cugraph, networkx like API with GPU support.
comment
You can change the link to points towards the Scipy website instead for the BibTex and pdf entry  BibTeX: http://conference.scipy.org/proceedings/SciPy2008/paper_2/reference.bib PDF: http://conference.scipy.org/proceedings/SciPy2008/paper_2/full_text.pdf
comment
v2.2 was the last supported version for python 2.7, you can install it through pip   pip install networkx==2.2   > On 12-Apr-2020, at 3:19 AM, Nika Gabisonia <notifications@github.com> wrote: >  >  > I need it for personal use, since I'm using a library that has been deprecated few years ago. It used networkx but an old one. Unfortunately I can't find any of old downloads on the pypi. >  > Could anyone be kind enough to search up old folder of this library on their HDDs and upload it somewhere? I'd be grateful. >  > Thanks. >  > â€” > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub <https://github.com/networkx/networkx/issues/3908>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ABI5RFAIUHQOYW6UBPJ6AC3RMDQYHANCNFSM4MGFAH5A>. >   
comment
You can also download the source code for the previous versions through https://github.com/networkx/networkx/releases 
comment
Please do add tests for this, and try to format your code according to PEP8 :) 
comment
@frhyme the bottleneck here is using `(e1, e2) for e1, e2, e_attr in NODE_subG.edges(data=True)            if e_attr['weight'] > 0.5)`  to create the filtered list of edges to keep in the new subgraph. This alone will take up the most time as for loops are generally very expensive in terms of compute time in python. Coming to why you should use `subgraph_view` over chaining it like `subgraph(nodes).edge_subgraph(edges)`,  by using `lambda` in `subgraph_view` you force `nx_subG` to be a lazy evaluated and it always stays a view. By chaining it in `G.subgraph(nodes).edge_subgraph(edges)` it becomes a view of a view.   To better understand what I mean by a view of a view.  ``` python >>> nx_subG._node FilterAtlas({0: {'weight': 0.08474794689102627}, 1: {'weight': 0.7485890441372873}, 2: {'weight': 0.0069110208643630155}, 3: .......... >>> subG._node FilterAtlas(FilterAtlas({0: {'weight': 0.08474794689102627}, 1: {'weight': 0.7485890441372873}, 2: {'weight': 0.0069110208643630155}, 3: {'we  ``` One is creating a FilterAtlas once and the other one in chaining two FilterAtlas.  This takes us to the functionality of `nx.subgraph_view(G, filter_node, filter_edge)` and  `G.subgraph(nodes).edge_subgraph(edges)`. This may look like they are doing the same thing but they won't necessarily give you same results. `nx.subgraph_view(G, filter_node, filter_edge)` will be the union of filters while `G.subgraph(nodes).edge_subgraph(edges)` will stack the edge filter on top of node filter. Example:  ``` >>> import networkx as nx >>> G = nx.Graph([(0, 1), (1, 2)]) >>> G.add_node(3) # filter nodes 0, 1, 3 and filter edges to only (0, 1) >>> union = nx.subgraph_view(G, filter_node=lambda x: True if x in [0, 1, 3] else False,                     filter_edge=lambda e1, e2: True if (e1, e2) in [(0, 1)] else False) # same done using stacking/chaining >>> stack = G.subgraph(nodes=[0, 1, 3]).edge_subgraph(edges=[(0, 1)])  >>> union.nodes() NodeView((0, 1, 3)) >>> stack.nodes() NodeView((0, 1)) ```  Let me know if this makes sense!
comment
The reason for this discrepancy is because of lazy evaluations. `G.subgraph` takes in an explicit container of nodes while `nx.subgraph_view` takes in a callable, in this case a `lambda` function.  In the following example you can look at the difference between the filters, one is a `show_nodes` and other is `lambda`.   ``` python >>> nx_subG._node FilterAtlas({0: {'weight': 0.00767033093403946}, .... 4: {'weight': 0.308129712638896}},  <function <lambda> at 0xa495783b0>) >>> subG._node FilterAtlas({0: {'weight': 0.00767033093403946}, ... 4: {'weight': 0.308129712638896}}, <networkx.classes.filters.show_nodes object at 0xa2fa39810>) ``` `subG._node` is already evaluated while ` nx_subG._node` isn't evaluated yet as it needs to pass through the `lambda` function.  Let's see what happens once both are evaluated.  ``` python >>> %%timeit >>>  nx_subG.copy() 19.9 s Â± 2.6 s per loop (mean Â± std. dev. of 7 runs, 1 loop each)  >>> %%timeit >>> subG.copy() 11.9 s Â± 59.4 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each) ``` As you can see `nx.subgraph_view` is faster than `G.subgraph` while creating the subgraph but its the other way round once we need to copy the subgraph into a new graph. (i.e. evaluating them)  This is absolutely required if you want to play around with the this filtered subgraph as a view just gives a view of the original graph, if you try manipulate `subG` or `nx_ subG` you will end manipulating the original graph `G.` 
comment
Should be closed, PR merged in https://github.com/networkx/networkx/pull/3646 
comment
Make sure you have python 3.6+ as the setup.py file in master branch uses f strings (which were introduced in 3.6) 
comment
Yeah, fixed it https://github.com/networkx/networkx/pull/3738 
comment
They are two different methods, they are supposed to do that.  Maybe this should mentioned somewhere in the docs. ``` python In [10]: G = nx.DiGraph([(1, 2), (2, 3), (3, 4), (4, 5)])  In [11]: nx.predecessor(G, 1) Out[11]: {1: [], 2: [1], 3: [2], 4: [3], 5: [4]}  In [12]: nx.predecessor(G, 5) Out[12]: {5: []}  In [13]: list(G.predecessors(4)) Out[13]: [3]  In [14]: list(G.predecessors(5)) Out[14]: [4]  In [15]: list(G.predecessors(1)) Out[15]: [] ```  Doc for the `predecessor` method https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.unweighted.predecessor.html#networkx.algorithms.shortest_paths.unweighted.predecessor
comment
@jfinkels Are you working on this? 
comment
The documentation you have linked is for version 1.10 and iter methods were removed from 2.0 onwards. Google indexing isnâ€™t that good for distinction between different versions.   On Thu, 23 May 2019 at 10:20, Vincenzo Lavorini <notifications@github.com> wrote:  > Hi, > > just replicating the exmaple in the documentation > <https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.DiGraph.nodes_iter.html> > : > > G = nx.Graph() > G.add_path([0,1,2]) > [d for n,d in G.nodes_iter(data=True)] > > gives: > > --------------------------------------------------------------------------- > AttributeError                            Traceback (most recent call last) > <ipython-input-47-91f3d939c1a6> in <module> >       1 G = nx.Graph() >       2 G.add_path([0,1,2]) > ----> 3 [d for n,d in G.nodes_iter(data=True)] > > AttributeError: 'Graph' object has no attribute 'nodes_iter' > > Networkx version: 2.3 > > â€” > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/issues/3452?email_source=notifications&email_token=ABI5RFEOSU5QYMTFSEARWI3PWZHUJA5CNFSM4HO3BY62YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVMQPCQ>, > or mute the thread > <https://github.com/notifications/unsubscribe-auth/ABI5RFFH54GJWR7GYAFIUILPWZHUJANCNFSM4HO3BY6Q> > . > 
comment
> Adding edges to a graph using G.add_edges_from produces graphs with different edges on Python 3.5 vs 3.6  Even though the order is different, the underlying graphs are equivalent. As for undirected graph, an edge for node 1 to node 2 is equivalent of saying that there is an edge from node 2 to node 1. So while working with networkx you shouldn't assume that the output of `edges` would be sorted in the way the graph was built.
comment
Thanks for the report. The issue https://github.com/networkx/networkx/issues/2342 and it's proposed fix https://github.com/networkx/networkx/pull/2397  @oigroig You can just neglect these warnings right now :)
comment
I did a quick search with grep. I didn't find any place where instance is really required.  
comment
This breaks the code, https://github.com/networkx/networkx/pull/1845 uses `blockmodel`. I guess we could add an alias for it. 
comment
Using an alias still breaks backward compatibility as the arguments of the function `blockmodel` and `quotient_graph` are different. `nx.quotient_graph(G, partition, create_using=nx.MultiGraph())` has to be used instead of `nx.blockmodel(G, partition, multigraph=True)` .Should we remove `blockmodel` then? 
comment
I have added a wrapper function `blockmodel` in https://github.com/networkx/networkx/pull/1886. I have also added a note in the documentation.  ```     Notes     -----     This function has been deprecated. Please use ``quotient_graph`` instead. ``` 
comment
@bakerwho the tests are going to fail. Can you update the tests too? As the current tests assume that the buggy version was the correct version.
comment
https://github.com/hyperopt/hyperopt/commit/2442bb24aca594bd566044fce276afbd377e0c03  It is fixed in the master repo of hyperopt. 
comment
:+1: on generating these using `References` section of the doc. 
comment
@bjedwards @python27 I could help around if needed :) 
comment
We already use a BSD license. Doesn't that automatically make all the code contributed BSD licensed.  Are you talking about something like this http://www.harmonyagreements.org/index.html  
comment
@jg-you :+1:  
comment
Any decision on this ? 
comment
I think this can be closed now. 
comment
@OrkoHunter https://github.com/networkx/networkx/blob/a822b491c6b53a2819915a8c620e97a36ba6c060/networkx/algorithms/simple_paths.py#L11 and https://github.com/networkx/networkx/blob/a822b491c6b53a2819915a8c620e97a36ba6c060/networkx/algorithms/tests/test_simple_paths.py#L40  
comment
@OrkoHunter You do realise that the hamiltonian path problem is a NP-Complete problem. As @ysitu pointed out it will be a hard to implement it in a "good way" . 
comment
@zjpjack Dense matrices store every entry in the matrix. Sparse matrices only store the nonzero entries. Sparse matrices don't have a lot of extra features, and some algorithms may not work for them. You use them when you need to work with matrices that would be too big for the computer to handle them, but they are mostly zero, so they compress easily. 
comment
@hagberg  We can start by implementing these measures: http://en.wikipedia.org/wiki/Weighted_network#Measures_for_weighted_networks What do you think? 
comment
https://networkx.readthedocs.io/en/stable/reference/api_1.11.html#api-changes 
comment
@Eisenbarth Can you please close the issue :) 
comment
@leycec That was fast! ðŸ»  Thanks for debugging pydot, was scratching my head for a long time to find it!  
comment
Can you have a look at the merge conflicts?
comment
Regarding example notebooks should we test against the latest release or the master branch? I think the master(the default one) branch of networkx/notebooks should be tested against the latest release i.e. 1.11 currently [it's better to directly work on 2.0 as we are planning this to be a part of 2.0 release]  And we can have a Dev branch which is tested against networkx master branch.    On 16-Jul-2017 9:16 PM, "Dan Schult" <notifications@github.com> wrote:  > I don't think #2054 <https://github.com/networkx/networkx/pull/2054> will > be merged without a lot of work -- and then probably in a different PR. It > has been a long time and there are many conflicts at this point. So I think > you should proceed to make changes as you are. But there are some good > ideas in those old commits so incorporate them wherever you think they are > helpful. > > I think the examples don't need to be moved to rst files -- so long as we > get the notebooks repository to automatically hook in with the testing > system we should keep the examples there. But restructuring the current > /doc would be good. > > â€” > You are receiving this because you are subscribed to this thread. > Reply to this email directly, view it on GitHub > <https://github.com/networkx/networkx/pull/2517#issuecomment-315617645>, > or mute the thread > <https://github.com/notifications/unsubscribe-auth/AFHYlGHmg3_qiBbCn24HopNPChPG9IZOks5sOjBUgaJpZM4OZMI8> > . > 
comment
Not the right thread for discussion. I'll open a new issue so we can move the discussion regarding example notebooks there.
comment
What should be returned in the case of `g.add_edges_from()` ? A list of keys?  @hagberg I don't think we should return any key for `remove_edge()` because the user is ok with deleting a random edge according to the following specifications.  ``` 1) want to remove edge and don't care which one - MultiGraph.remove_edge(u,v) 2) want to remove edge and have specific key - MultiGraph.remove_edge(u,v,key=key) 3) want to remove all edges - MultiGraph.remove_edges_from(M.edges(u,v)) ``` 
comment
https://github.com/networkx/networkx/pull/1945 
comment
Side note: for API changes we have this https://github.com/networkx/networkx/blob/master/doc/source/reference/release_2.0.rst
comment
Then I think we shouldn't have any release with the iterator version as it will unnecessarily change the API twice.  What about a 1.99 release with cherry picked commits(no changes to the base graph classes) in the coming days?
comment
@jarrodmillman I took a stab at this with a Jekyll based theme, moving from the sphinx based landing page https://nxtestweb.github.io  No more HTML editing with Jekyll :D  Thoughts? @hagberg @dschult @jarrodmillman 
comment
@dschult This is what it is supposed to be ![screen shot 2017-07-19 at 10 44 44 pm](https://user-images.githubusercontent.com/5363860/28380157-e7361120-6cd3-11e7-8676-98a5bb016bc4.png)  It's pretty much inspired by http://www.mdanalysis.org  The alabaster theme looks nice on http://networkx.github.io/ . Anyway as @jarrodmillman pointed out we can change the theme or modify the landing page at any later time ðŸ˜„ 
comment
Thanks for this! Could you please add tests and reformat your code to PEP8 specs. 
comment
@jfinkels let me know if you want to handle these conflicts or I can pull this PR and update it.  I have also made a boilerplate website https://nxtestweb.github.io , let me know if this makes sense!
comment
@hagberg the closet thing to that would be https://github.com/computationalmodelling/nbval . I have a built a rudimentary setup with binder and travis for the tutorial notebook at https://github.com/MridulS/test-tut . For more discussions regarding notebooks I have opened a new issue https://github.com/networkx/networkx/issues/2518
comment
I think that something like this https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt should also be a part of this file. 
comment
Yeah, that would work too :) 
comment
I opened a new issue for the design specification #1382  
comment
@Michael-E-Rose by forking the PR you will maintain the commit history.
comment
@Michael-E-Rose I understand but it's more about keeping the credit where it's due. :) You can open a new PR with a forked version of this one. (PRs are cheap)
comment
@Michael-E-Rose Checkout https://hub.github.com . It will make this easier. ``` hub checkout https://github.com/networkx/networkx/pull/1453 ``` will create a new branch with the content of this PR and you can add your commits on top of this. :)  Let me know if you face any problems :)
comment
`kmanninen-master` is the name of your local branch not the OP's branch. (This is the default name of the branch fetched using hub).  You can push it to GitHub using `git push origin kmanninen-master:branch_name` where you can decide the branch name, e.g.: `gexf_viz`,   `git push origin kmanninen-master:gexf_viz`. Then it is business as usual, open a new PR :)  PS: assuming `origin` points to `https://github.com/Michael-E-Rose/networkx`  
comment
@harlowja I'll send in a PR regarding this. Right now we are looking into making traversal algorithms return iterators instead of dict/list, this will be a part of the 2.0 release :) 
comment
@necklace010 It should work.   > MatplotlibDeprecationWarning: pyplot.hold is deprecated. Future behavior will be consistent with the long-time default: plot commands add elements without first clearing the Axes and/or Figure.  This is just a warning it shouldn't impact the output.  Are you using a jupyter notebook?
comment
make sure you execute  ``` %matplotlib inline ``` in one of the cells. ![screen shot 2017-05-04 at 11 18 12 pm](https://cloud.githubusercontent.com/assets/5363860/25717425/0cc81ca2-3120-11e7-9e6f-15e51061ed4a.png) 
comment
@necklace010 happy to help :) Can you please close this issue.
comment
@hagberg :+1:
comment
Another new feature: https://github.com/networkx/networkx/projects . It's a good way to keep track of short time and long time goals, example https://github.com/scikit-learn/scikit-learn/projects/5 
comment
@joelmiller   ``` python G.add_weighted_edges_from([(1, 2, 2), (1, 3, 2), (2, 4, 2), (3, 4,3)]) G.node[2]['node_weight'] = 5 def func(u, v, d):     return G.node[u].get('node_weight', 1)/2 + G.node[v].get('node_weight', 1)/2 + d.get('weight', 1) print(nx.dijkstra_path(G, 1, 4, weight=func)) [1, 3, 4] ```  Let me know if you need any help! :) 
comment
I guess we can have something like   ``` python @not_implemented_for('multigraph') def is_complete(G):     if G.is_directed():         H = G.to_undirected(reciprocal=True)         nodes = H.number_of_nodes()         edges = H.number_of_edges()     else:         nodes = G.number_of_nodes()         edges = G.number_of_edges()     return edges == nodes *( nodes - 1)/2 ``` 
comment
For writing tests you can use `nx.complete_graph()` to generate complete graphs. 
comment
Storing time stamps as edge attributes is not a problem.  If you are working with actual date/time (something like "13/04/2015 10:20 AM")  I would recommend using https://docs.python.org/3/library/datetime.html objects as edge attributes, easier to manipulate and play with.  Hope this helps :)  
comment
It's just plain old BFS  :) 
comment
https://github.com/networkx/networkx/pull/1894 
comment
I think we shouldn't create a huge PR (touching a lot of files) for these changes. We should update the files as we work on them, like we do for PEP8 changes.  
comment
You need to add `from networkx.generators.joint_degree_seq import *` to  `networkx/generators/__init.py`. This is one of the reasons of Travis failure 
comment
You also need to add this  ``` Joint Degree Sequence -------------------- .. automodule:: networkx.generators.joint_degree_seq .. autosummary::    :toctree: generated/     is_valid_joint_degree    joint_degree_model ```  to `doc/source/reference/generators.rst` 
comment
I did start doing this https://github.com/MridulS/NetworkX-Tutorial . I started writing a tutorial. Should I just convert the current examples (and add a few) to IPython notebooks? 
comment
I think this a good idea. We should go ahead and do this. :)  On Monday, July 20, 2015, Aric Hagberg notifications@github.com wrote:  > Perhaps the notebooks should be in a separate repository (with the > tutorial)? >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1656#issuecomment-122697421. 
comment
something like this https://github.com/MridulS/nx-examples ? 
comment
Thanks for doing this :), I will be updating the rest of the functions as part of my GSoC project. 
comment
@jfinkels I think we can close this now. https://github.com/networkx/networkx/pull/1586   
comment
As a newbie to networkx (started using it a month back), I think we need more documentation and maybe more examples. I got stuck some times at very trivial things. 
comment
I think we should go by the pythonic standard and keep the unit tests in the package. As mentioned by @dschult most of the packages in scientific python community uses the same structure. 
comment
Note: pydot on pypi was last updated for python 2.6. 
comment
Regarding nx.is_connected(): I have read conflicting definitions about a null graph. Some books treat them as connected graph and some don't. According to our implementation it is not defined. Should we revisit this? 
comment
@borisdan If we have different weight attribute per edge-type then I think it shouldn't be a problem.  ``` python In [23]: G.add_edge(1, 2, r_weight=10, b_weight =4)  In [24]: G.add_edge(2, 3, r_weight=10, b_weight =4)  In [25]: G.add_edge(1, 3, r_weight=8)  In [26]: nx.shortest_path(G, 1, 3, weight='r_weight') Out[26]: [1, 3]  In [27]: nx.shortest_path(G, 1, 3, weight='b_weight') Out[27]: [1, 3] ```  `nx.shortest_path(G, 1, 3, weight='b_weight')` returns `[1, 3]` because the implementation gives any absent weight attribute a default value of 1. I guess we can change that and add a `default` argument. Something like `nx.shortest_path(G, 1, 3, weight='b_weight', default=float("inf"))` [This won't change the graph structure] 
comment
@jfinkels @dschult In both cases we create a new graph. What do you think of exposing the `default` parameter to the user? 
comment
I think we shouldn't completely remove `add_path`, `add_cycle`, `add_star`. The alternates like `G.add_edges_from(zip(nlist[:-1], nlist[1:]))` are not easy to get right for beginners, and is used at various places in doctests.  They should definitely be removed from the core graph classes and moved to someplace like `function.py` as suggested by @dschult or maybe some file like `algorithms/add_structure.py`. 
comment
@dschult That's the same link. I guess this is what we are looking for  http://networkx.readthedocs.org/en/latest/reference/algorithms.simple_paths.html :) 
comment
http://networkx.readthedocs.org/en/latest/ and http://networkx.readthedocs.org/en/stable/ looks okay. default should be changed to point to http://networkx.readthedocs.org/en/stable/ i.e v1.11 
comment
Addressed in #1771. We can close this issue now. 
comment
Git can be confusing at first. Don't worry :) Send in a new PR. On Jan 7, 2016 9:53 PM, "Arafat" notifications@github.com wrote:  @dschult https://github.com/dschult Thanks a lot for the valuable pointers. I have handled the PEP8 guidelines but their are a lot of issues with rebasing because of my college network proxy(I perform all the changes on git website itself and not from terminal). Is it okay,if i close this pr and make a new one with the exact same changes?  â€” Reply to this email directly or view it on GitHub https://github.com/networkx/networkx/pull/1902#issuecomment-169714469. 
comment
Everything looks okay :) 
comment
on it :) 
comment
https://github.com/networkx/networkx/pull/1884 
comment
This can be closed now, fixed in https://github.com/networkx/networkx/pull/1884 
comment
https://pypi.python.org/pypi/coverage/4.0 has dropped support for python 3.2 :/ 
comment
The `u'unicode'` syntax was dropped for str() objects in python 3.2. It was brought back in 3.3. 
comment
Sounds good  On Tuesday, September 1, 2015, Dan Schult notifications@github.com wrote:  > Should we add a line to the client webchat.freenode.net for those who > don't know/want to install a client? >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/pull/1758#issuecomment-136768815. 
comment
Cool kids use gitter here ;)  On Tuesday, September 1, 2015, Sanket Dasgupta notifications@github.com wrote:  > Slack will be overkill for a repository. It does have some "cool" features > that IRC doesn't have, but IRC will suffice for most of the time. >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/pull/1758#issuecomment-136776175. 
comment
I think now is a good time to decide on a chat/discussions forum. IRC / Slack/ Gitter, we should decide on one.  @chebee7i @ysitu @jfinkels  
comment
I have ported the current tutorial to a ipython notebook. https://github.com/networkx/networkx/pull/1663  pydot was last tested for python 2.6 and we have dropped support for 2.6 I think we should mention this as a note. 
comment
@hagberg https://github.com/networkx/networkx/pull/1693 and https://github.com/networkx/networkx/pull/1676 
comment
Yeah :) 
comment
Hey, I am interested in working for networkx during GSoC. How can I help?  I updated the wiki page by copying information from the networkx documentation page. 
comment
@ysitu I think I don't qualify as a mentor, I am not that familiar with the codebase. But, I would love to help around during the summer or even participate as a student myself. I am an undergrad student majoring in mathematics and electrical engineering. 
comment
@ysitu How many mentors have signed up till now? According to Python Software Foundation's GSoC 2015 page we have time till March 16 to apply; the earlier the better. We should try to apply by next week. 
comment
Having a [gitter](https://gitter.im/) chat room or an irc channel could be nice way to interact with prospective students and new developers. IMHO it is a better option (for general discussion) than github / mailing list.  P.S. I personally would prefer gitter; better integration with github. 
comment
@rashoodkhan Please go through #1076 to get an idea about matrix graphs. 
comment
@chebee7i we can't access the gitter room because it is private, only owner/ collaborators can access it. Please change the settings :)  
comment
I guess you can add us to that room :) We should also add a badge in README (gitter will do that via a PR). 
comment
I was thinking to start writing my GSoC proposal for 2.0 API, but I have a lot of questions regarding it (specifically design). I am planning to start working on the code (I have some free time before the summer). @Midnighter I would also like to work on #1076, seems interesting.  If we start working on 2.0 API before the summer then I think the API project won't last full summer (Will be completed by early July). The matrix graphs project should conform with the 2.0 API. How about combining the API project with matrix graphs project?  I know it sounds ambitious but we (GSoC Students) are expected to work 40 hours/week :) 
comment
@gcetusic Yes, the design specification of 2.0 API should be done before other proposals, but there is still a lot to discuss about.    PS: The student applications are during 16-27 March. 
comment
@Midnighter But I need to explicitly mention my week by week plan in my GSoC Application. @dschult @ysitu @hagberg @chebee7i it would be helpful if we could start a discussion about the design.  
comment
IMO projects like 5 and 11 are not thorough enough to qualify as GSoC projects, but they sound as good individual projects to take on. Project 6 could help in https://github.com/networkx/networkx/issues/1343. I would personally like to work on 5, 6, 7, 8 and 9. :) 
comment
Yes I agree that they are important. But I think that they won't be able to span over a time frame of 12 weeks.  On Monday, March 2, 2015, ysitu notifications@github.com wrote:  > @hagberg https://github.com/hagberg Merely allowing seeding is not > enough. The underlying PRNG is shared. Seeding one function affects other > functions relying on random numbers. Changing to dependency injection help > decouple them and also the tests. >  > @MridulS https://github.com/MridulS 5 and 11 are about project > evangelism and make a lot sense for NetworkX. I think that they are > actually good projects for GSoC. >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1341#issuecomment-76654999. 
comment
To all the mentors, mentor registrations have started http://google-melange.com/gsoc/org/list/public/google/gsoc2015  
comment
@chebee7i We are under Python Software Foundation, and they got in :) 
comment
@prasunanand you can also take a glance at https://github.com/networkx/networkx/wiki/GSoC-2015-project-ideas first :) 
comment
As we are participating under the PSF umbrella, everyone should update their proposal according to the PSF template. https://wiki.python.org/moin/SummerOfCode/ApplicationTemplate2015 
comment
I think this can be closed now. 
comment
I guess this is like PEP8 category changes. Instead of doing `grep`/`sed` and removing `__author__`  at one go we can just add this change if anyone works on a file, just like PEP8 changes.  Anyway I have created a PR https://github.com/networkx/networkx/pull/1731 
comment
http://apple.stackexchange.com/questions/209572/how-to-use-pip-after-the-el-capitan-max-os-x-upgrade 
comment
`Dijkstra shortest path` returns the shortest <b>path</b> between two nodes and `Dijkstra shortest path length` returns the <b>length</b> between them. For example:  ``` python In [2]: G = nx.Graph()  In [4]: G.add_edge('A', 'B', weight=1)  In [5]: G.add_edge('B', 'C', weight=2)  In [6]: G.add_edge('A', 'C', weight=5)  In [7]: nx.dijkstra_path(G, 'A', 'B') Out[7]: ['A', 'B']  In [8]: nx.dijkstra_path(G, 'A', 'C') Out[8]: ['A', 'B', 'C']  In [9]: nx.dijkstra_path_length(G, 'A', 'C') Out[9]: 3 ```  If you only want the weight of specific path you should use `Dijkstra shortest path length` 
comment
@SanketDG yes and the documentation is broken at various places  
comment
I am working on it :) 
comment
https://github.com/networkx/networkx/blob/master/networkx/algorithms/shortest_paths/generic.py#L234  This is also an inconsistency  
comment
Change http://networkx.github.io/documentation/latest/install.html -> http://networkx.readthedocs.org/en/latest/install.html in INSTALL.txt 
comment
we did have a GSoC 2015 specific gitter channel (kind of online irc) 
comment
https://gitter.im/networkx/GSoC_2015 
comment
https://webchat.freenode.net 
comment
@vergenzt We currently don't support implicit graphs.  > If not, any tips on alternative approaches? Can a graph object be modified during traversal to simulate this?  Something like this, maybe?  ``` python In [1]: import networkx as nx  In [2]: G = nx.Graph()  In [3]: g = lambda x: x in range(0, 10, 2)       # neighbor function  In [4]: for i in range(0,10):    ...:     if g(i):    ...:         G.add_edge(0, i)           # 0 is the starting node    ...:  In [5]: list(G.edges()) Out[5]: [(0, 0), (0, 8), (0, 2), (0, 4), (0, 6)] ```  What kind of neighbor function are you working with? 
comment
This has been already fixed https://networkx.readthedocs.org/en/v1.10/reference/generated/networkx.readwrite.nx_shp.read_shp.html You can update your networkx distribution to v1.10 using https://pypi.python.org/pypi/networkx/ 
comment
fixed in https://github.com/networkx/networkx/commit/dda332ea88ac344a4acd9d54579c3f838f82c126 
comment
@litaotju self.degree() returns an int only if a single node is passed as an argument, which is not the case here.  So, this won't be a problem :) 
comment
I am still new to this community, but still I would love to attend SciPy and meet you guys and work further with NetworkX. @jtorrents Thanks for the link, lets hope to get some financial aid :) 
comment
@ysitu @hagberg @dschult @jtorrents @chebee7i @midnighter 5 hours to go for deadline. I would be grateful to know some pointers and views for my application, I have uploaded it on Melange. 
comment
@ysitu Can you email me your contact info :)  
comment
I think this can be closed now. 
comment
I think this can be closed now. 
comment
Would like to know your views and suggestions regarding my proposal (initial draft) at https://github.com/networkx/networkx/wiki/NetworkX-GSoC-2015-Application:-NetworkX-2.0-API---Mridul-Seth 
comment
@ysitu The project ideas page should also be updated with possible mentors for each project. 
comment
@ysitu The potential mentors can confirm it @hagberg @dschult @Midnighter @chebee7i  . And we should have at least 3 mentors signed up.  PS: Confirmed with Terri (PSF), 3 mentors have registered. She said that mentors can sign up well after the student deadline 27th March.  
comment
I think this can be closed now. 
comment
@harlowja You can add this to https://github.com/networkx/networkx/wiki/NetworkX-2.0-API-~-DRAFT 
comment
I think ordered dict, mentioned in the subclasses section of graph.py, will solve this. Give it a try :)  On Saturday, July 18, 2015, Himanshu Mishra notifications@github.com wrote:  > I have a question regarding the order in which add_nodes_from adds nodes > to a Graph. >  > In [1]: import networkx as nx > In [2]: node_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 1, 2, 3, 4, 5, 6] >  > In [3]: G = nx.Graph() > In [4]: G.add_nodes_from(node_list) >  > In [5]: list(G.nodes()) > Out[5]: ['a', 1, 'c', 'b', 'e', 'd', 'g', 'f', 'i', 'h', 'j', 2, 3, 4, 6, 5] >  > Why is the order changed? How can I make it in the same order as node_list > . >  > I can understand that in a graph, the order is meaningless. But in a > python list, the order has a good role in various operations. >  > â€” > Reply to this email directly or view it on GitHub > https://github.com/networkx/networkx/issues/1670. 
comment
@MisterSheik Make sure to squash your commits. 
comment
@MisterSheik This is a known error https://github.com/networkx/networkx/issues/1637. The test was removed in https://github.com/networkx/networkx/issues/1639. You should rebase this branch to the master repo and it will fix this issue. 
comment
Fixed in #1319  
comment
The current documentation is broken at places. This is the link for latest documentation http://networkx.readthedocs.org/en/latest/  
comment
Oh wait.... It is broken at readthedocs too :/ https://networkx.readthedocs.org/en/latest/reference/algorithms.centrality.html 
comment
@chebee7i Yes it is fixed. 
comment
@chebee7i I opened a new issue regarding the failure #1642  
comment
@sjackman As @dschult suggested this will be slower for unweighted case. You could add a `if` check for weights. 
comment
something like this with `weight=None` in function. And is using `default_weight` as an argument necessary?   ``` python if weight is None:     for node in nx.topological_sort(G):         pairs = [(dist[v][0] + 1, v) for v in G.pred[node]]             if pairs:                 dist[node] = max(pairs)             else:                 dist[node] = (0, node) else:     for v in nx.topological_sort(G):         dist[v] = max([(0, None)] + [(dist[u][0] + G[u][v].get(weight, 1), u) for u in G.pred[v]]) ``` 
comment
@sjackman Did some testing. Here `dag_longest_path()` is the implementation with a check and `dag_longest_path_1()` is without a check for `weight`. `dag_longest_path_1()` is definitely slower for unweighted graphs.  ``` In [18]: G = nx.gn_graph(100)  In [19]: %timeit nx.algorithms.dag.dag_longest_path(G) 1000 loops, best of 3: 235 Âµs per loop  In [20]: %timeit nx.algorithms.dag.dag_longest_path_1(G) 1000 loops, best of 3: 304 Âµs per loop  In [21]: G = nx.gn_graph(1000)  In [22]: %timeit nx.algorithms.dag.dag_longest_path_1(G) 100 loops, best of 3: 3.03 ms per loop  In [23]: %timeit nx.algorithms.dag.dag_longest_path(G) 100 loops, best of 3: 2.28 ms per loop  In [24]: G = nx.gn_graph(3000)  In [25]: %timeit nx.algorithms.dag.dag_longest_path(G) 100 loops, best of 3: 7.34 ms per loop  In [26]: %timeit nx.algorithms.dag.dag_longest_path_1(G) 100 loops, best of 3: 9.86 ms per loop ``` 
comment
Yes, speed is not a big issue here,  but at many places (example: `networkx/algorithms/shortest_paths/generic.py`, `networkx/algorithms/centrality/betweenness.py`, `networkx//algorithms/centrality/betweenness_subset.py`) in the codebase we kind of follow this type of check for `weight`. I thought keeping this consistent everywhere would be better. :) 
comment
This is weird. It is documented and it shows on http://networkx.readthedocs.org/en/latest/reference/algorithms.html  
comment
This should be closed https://github.com/networkx/networkx/issues/1626 
comment
@OrkoHunter we already have a release candidate for 1.10 so in my opinion this should be in 2.0. :) 
comment
On a different note, we should start discussing about an appropriate design specification for the new API, which is the second part of my GSoC project (and further). 
comment
Should we remove `*iter` functions from timingclasses.py file also? @dschult @hagberg @ysitu @chebee7i @jfinkels  
comment
@jtorrents shouldn't we remove transitive_closure and antichains from this PR if we merge #1413  
comment
:+1:  
comment
@SanketDG And also remember to squash your commits with proper commit messages  for example you have three commits with the title: fix tests 
comment
@SanketDG It can be done :) google `git rebase` 
comment
@OrkoHunter looks fine, squash the commits and you should always work on a new branch   ``` $ git checkout -b some_new_branch ```  you should keep your local master branch clean and do changes in the new branch. It is a good practice. 
comment
@lucjon can you also resolve the merge conflicts please. 
comment
@jtorrents I am on it :) 
comment
@ysitu Can you restart this task on coveralls? Travis output for python 2.7 line: 3458  ``` networkx.algorithms.dag                                            120      0   100%    ``` 
comment
@ysitu That seems to be the problem. I cannot restart the travis job as I don't have write access to the repo :) 
comment
The problem is with 3.4 also [link](https://coveralls.io/builds/2116066/source?filename=%2Fhome%2Ftravis%2Fminiconda%2Fenvs%2Ftest-environment%2Flib%2Fpython3.4%2Fsite-packages%2Fnetworkx%2Falgorithms%2Fsmetric.py) 
comment
@chebee7i They are tested on miniconda only.  
comment
This is failing for a lot of tasks. 
comment
+1 for turning them off.  And coveralls tend to give those annoying red crosses on PRs without even changing the code. 
comment
@chebee7i I am not talking about Travis. This is for reporting coveralls.  from https://github.com/networkx/networkx/blob/master/.travis.yml  ``` after_success:   # `coveralls` needs to be run from the git repository, and it requires   # the .coverage file that was generated during the testing phase. The   # .coverage file stores absolute paths to the modules, and since we ran   # tests from the installed directory, the paths do not point to files in   # the git repository. Although this does not affect reported statistics,   # it does prevent coveralls from providing more detailed information on   # each file. So the paths in .coverage must be modified to match the   # repository paths. This is what `fixcoverage.py` does.   #   # Report coverage for 2.7 and 3.4 only. - if [[ "${PYTHON_VM}" != ipy ]]; then       cp .coverage $TRAVIS_BUILD_DIR;       cd $TRAVIS_BUILD_DIR;       if [[ "${TRAVIS_PYTHON_VERSION}${OPTIONAL_DEPS}" =~ 2\.7miniconda|3\.4miniconda ]]; then         python fixcoverage.py "$VIRTUAL_ENV/lib/python.*/site-packages/networkx/" "$TRAVIS_BUILD_DIR/networkx/";         coveralls;       fi;     fi ``` 
comment
cool :) 
comment
@SanketDG http://stackoverflow.com/questions/27841396/cannot-import-release-from-networkx. Try reinstalling it. 
comment
I agree with @ysitu. The user should also be able to remove a specific edge. 
comment
@chebee7i I guess it has something to do with pyplot. It gives a weird plot for me too. 
comment
@ysitu @hagberg @bjedwards GSoC 2015 org application starts tomorrow, I guess we should finalise mentors and project wiki, and contact PSF. 
comment
@ysitu The difficult part of networkx 2.0 API is the design part, as far as implementation is concerned I guess it can be considered as a beginner-friendly project, anyone with decent python experience can start working on it. So I think we should start working on the design part. And get a final word on #1246.  
comment
@ysitu From the #1246 discussion, I guess there are more things to do other than renaming `func_iter` over `func` . We could start discussing about the ANY() function, having single implementation of functions for Di/Multi/Graph (making functions more generalised) , etc.    P.S. I am thinking of applying for GSoC as a student and working on 2.0 API. 
comment
You could use https://virtualenv.pypa.io/en/latest/ to deal with multiple python installations. I used to face similar issues, virtualenv worked for me. 
