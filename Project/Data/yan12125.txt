comment
Following suggestions in [PEP-479](https://www.python.org/dev/peps/pep-0479/):  > This is done by enclosing those places in the generator body where a StopIteration is expected (e.g. bare next() calls or in some cases helper functions that are expected to raise StopIteration) in a try/except construct that returns when StopIteration is raised. The try/except construct should appear directly in the generator function; doing this in a helper function that is not itself a generator does not work. If raise StopIteration occurs directly in a generator, simply replace it with return.  I managed to patch networkx to fix tests. For version 2.1: ```Diff diff --git a/networkx/algorithms/connectivity/edge_augmentation.py b/networkx/algorithms/connectivity/edge_augmentation.py index cd8c748f..525feff9 100644 --- a/networkx/algorithms/connectivity/edge_augmentation.py +++ b/networkx/algorithms/connectivity/edge_augmentation.py @@ -813,7 +813,10 @@ def unconstrained_bridge_augmentation(G):          A2 = [tuple(leafs)]      else:          # Choose an arbitrary non-leaf root -        root = next(n for n, d in T.degree() if d > 1) +        try: +            root = next(n for n, d in T.degree() if d > 1) +        except StopIteration: +            return          # order the leaves of C by (induced directed) preorder          v2 = [n for n in nx.dfs_preorder_nodes(T, root) if T.degree(n) == 1]          # connecting first half of the leafs in pre-order to the second @@ -954,7 +957,10 @@ def weighted_bridge_augmentation(G, avail, weight=None):      #     nx.least_common_ancestor on the reversed Tree.        # Pick an arbitrary leaf from C as the root -    root = next(n for n in C.nodes() if C.degree(n) == 1) +    try: +        root = next(n for n in C.nodes() if C.degree(n) == 1) +    except StopIteration: +        return      # Root C into a tree TR by directing all edges away from the root      # Note in their paper T directs edges towards the root      TR = nx.dfs_tree(C, root) @@ -1230,7 +1236,7 @@ def greedy_k_edge_augmentation(G, k, avail=None, weight=None, seed=None):        done = is_k_edge_connected(G, k)      if done: -        raise StopIteration() +        return      if avail is None:          # all edges are available          avail_uv = list(complement_edges(G)) diff --git a/networkx/algorithms/connectivity/edge_kcomponents.py b/networkx/algorithms/connectivity/edge_kcomponents.py index 37bf61dc..f9b4364c 100644 --- a/networkx/algorithms/connectivity/edge_kcomponents.py +++ b/networkx/algorithms/connectivity/edge_kcomponents.py @@ -573,7 +573,7 @@ def general_k_edge_subgraphs(G, k):      if G.number_of_nodes() < k:          for node in G.nodes():              yield G.subgraph([node]).copy() -        raise StopIteration() +        return        # Intermediate results      R0 = {G.subgraph(cc).copy() for cc in find_ccs(G)} diff --git a/networkx/algorithms/traversal/edgedfs.py b/networkx/algorithms/traversal/edgedfs.py index 5434057d..b9d442b6 100644 --- a/networkx/algorithms/traversal/edgedfs.py +++ b/networkx/algorithms/traversal/edgedfs.py @@ -152,7 +152,7 @@ def edge_dfs(G, source=None, orientation='original'):      """      nodes = list(G.nbunch_iter(source))      if not nodes: -        raise StopIteration +        return        kwds = {'data': False}      if G.is_multigraph(): diff --git a/networkx/generators/classic.py b/networkx/generators/classic.py index 22741a37..3338db36 100644 --- a/networkx/generators/classic.py +++ b/networkx/generators/classic.py @@ -57,7 +57,10 @@ def _tree_edges(n, r):      # helper function for trees      # yields edges in rooted tree at 0 with n nodes and branching ratio r      nodes = iter(range(n)) -    parents = [next(nodes)]  # stack of max length r +    try: +        parents = [next(nodes)]  # stack of max length r +    except StopIteration: +        return      while parents:          source = parents.pop(0)          for i in range(r): diff --git a/networkx/readwrite/sparse6.py b/networkx/readwrite/sparse6.py index 00ccae60..6f404ca3 100644 --- a/networkx/readwrite/sparse6.py +++ b/networkx/readwrite/sparse6.py @@ -163,7 +163,10 @@ def from_sparse6_bytes(string):            while 1:              if dLen < 1: -                d = next(chunks) +                try: +                    d = next(chunks) +                except StopIteration: +                    return                  dLen = 6              dLen -= 1              b = (d >> dLen) & 1  # grab top remaining bit @@ -171,7 +174,10 @@ def from_sparse6_bytes(string):              x = d & ((1 << dLen) - 1)  # partially built up value of x              xLen = dLen		# how many bits included so far in x              while xLen < k:  # now grab full chunks until we have enough -                d = next(chunks) +                try: +                    d = next(chunks) +                except StopIteration: +                    return                  dLen = 6                  x = (x << 6) + d                  xLen += 6 ``` On master, an extra patch is needed: ```Diff diff --git a/networkx/algorithms/traversal/edgebfs.py b/networkx/algorithms/traversal/edgebfs.py index 19260899..959ad4c0 100644 --- a/networkx/algorithms/traversal/edgebfs.py +++ b/networkx/algorithms/traversal/edgebfs.py @@ -96,7 +96,7 @@ def edge_bfs(G, source=None, orientation=None):      """      nodes = list(G.nbunch_iter(source))      if not nodes: -        raise StopIteration +        return       directed = G.is_directed()      kwds = {'data': False} ```
