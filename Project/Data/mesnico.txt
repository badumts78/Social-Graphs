comment
@aparamon awesome work! This implementation helped me a lot. I tried testing the algorithm with DiGraphs and it seems working! In the simplest test case, I tried with 2 graphs containing respectively edges A->B and B->A; the algorithm gives me as result the cost associated to one edge substitution, that is right. Is it a chance or the algorithm does already work with DiGraphs?   By the way, in my specific use case, I would need support for MultiDiGraphs. How difficult would it be to make appropriate changes in order for the algorithm to work even with this kind of graph? If small localized changes are needed, I could try to work on them by myself, possibly committing them afterward. Maybe you can help me finding the pieces of code that need to be touched ;)  Thank you!
comment
@aparamon Thank you for the hints, I'll look into it as soon as possible!
comment
Hi @aparamon, I was trying adding support for `MultiDiGraph`s. I am not sure about correctness of my solution; I am still running tests. However, as of now, I came out with these modifications for the `match_edges` function: ``` python {.line-numbers} g_ind = list(i for i in range(M)     if any(pending_g[i] [0:2] in ((p, u), (u, p), (u, u))         for p, q in matched_uv)) h_ind = list(j for j in range(N)     if any(pending_h[j][0:2] in ((q, v), (v, q), (v, v))         for p, q in matched_uv)) ```  and   ``` python {.line-numbers} for k, i in zip(range(m), g_ind):     g = pending_g[i][0:2]     for l, j in zip(range(n), h_ind):         h = pending_h[j][0:2]           #add a cost of 1 if edge should be flipped         if any((g == (p, u) and h == (v, q)) or (g == (u, p) and h == (q, v)) 	           for p, q in matched_uv): 	    #TODO: make this cost a variable chosen by user 	    C[k, l] +=1         if not any(g in ((p, u), (u, p)) and h in ((q, v), (v, q)) 	           or g == (u, u) and h == (v, v) 	           for p, q in matched_uv): 	    C[k, l] = inf ```  Basically, as `MultiGraph` edges make use of a third dimension to distinguish different edges between the same couple of nodes, as of now I am filtering out the third dimension, as only the first two (vertex indexes) are meaningful for the purpose of matching edges.  Instead, for `DiGraph` support, I checked if vertexes match in the opposite order. If this happens, an _inversion cost_ of 1 (this should be a customizable parameter) is added to the edge cost matrix.   Though if in my application domain this solution seems working (more testing needed), I noticed a heavy increasing in the overall computation times, probably due to the fact that the cost matrix is not as sparse as before. Do you believe I am doing anything wrong? If not, is there a way to improve performances?  Thank you very much!
comment
@aparamon thank you very much for your quick reply.  > I'm not sure that additional dimension is needed for multigraph edges  This is the way networkx handles `MultiGraph` edges: by adding a third dimension so that edges among the same couple of nodes can be distinguished. So, I am basically throwing away that third dimension that all edges of a `MultiGraph` have. I noticed that your code should already handle multiple matching items, so adding support for `MultiGraph` seemed quite straightforward.  > Also, I'm not quite sure that separate operation "edge flip" is a good idea. Just insert/delete/edit triple should be enough.  Basically, I am allocating an additional cost in the substitution zone of the edge cost matrix. I am doing that because, from what I have understood, all costs are initialized by calling ```edge_subst_cost``` function on each edge pair while initializing the edges cost matrix, and in that phase it seems impossible to keep into consideration also inversion costs. Maybe another solution could be expanding the edge cost matrix to keep into consideration edges having different directions.  I don't know if conceptually I am adding another operation other than insert/delete/edit. I thought my modification could be classified as edit.  However I will perform a pull request as soon as I prepare some interesting tests. Thank you!   
