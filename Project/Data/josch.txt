issue
graphml: re-add graph attribute type 'long' after 857aa81 removed it#TITLE_END#closes: #4188
issue
regression: nx 2.5 doesn't support graphml attribute type "long" anymore#TITLE_END#Take this graphml file:  ``` <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">   <key attr.name="cudfversion" attr.type="long" for="node" id="d6" />   <graph edgedefault="directed">   </graph>   </graphml> ```  And this Python code:      python3 -c "import networkx; networkx.read_graphml('test.xml')"  This worked with networkx 2.4 but with 2.5 I'm getting:  ``` Traceback (most recent call last):   File "<string>", line 1, in <module>   File "<decorator-gen-692>", line 2, in read_graphml   File "/tmp/networkx/networkx/utils/decorators.py", line 239, in _open_file     result = func_to_be_decorated(*new_args, **kwargs)   File "/tmp/networkx/networkx/readwrite/graphml.py", line 258, in read_graphml     glist = list(reader(path=path))   File "/tmp/networkx/networkx/readwrite/graphml.py", line 775, in __call__     (keys, defaults) = self.find_graphml_keys(self.xml)   File "/tmp/networkx/networkx/readwrite/graphml.py", line 951, in find_graphml_keys     "type": self.python_type[attr_type], KeyError: 'long' ```  The commit that broke this functionality is 857aa81ead611dd05c7445b53bd128131033d50e.  Please consider restoring this. There exists software that produces graphs with attribute type "long" which I cannot read in anymore since the release of 2.5.
issue
repeatedly reading and writing dot files does not converge on the same dot file#TITLE_END#Steps to reproduce ---  Suppose the following Python command:      python3 -c 'import networkx as nx, sys; nx.nx_agraph.write_dot(nx.nx_agraph.read_dot(sys.stdin), sys.stdout)'  Essentially this is just writing the same dot graph to stdout that it read from stdin.  And then also this trivial dot input:  ```dot digraph G { 	graph ["edge"="{}", 		"graph"="{}", 		name=G, 		"node"="{}" 	]; } ```  Now I'm executing:      command < graph1.dot > graph2.dot     command < graph2.dot > graph3.dot     command < graph3.dot > graph4.dot     ...  Expected behaviour ---  Since the command is writing out the same graph it is reading without modifying it, it should not matter how often I read in and write out the same dot file. At least after the first invocation, what networkx writes out should remain the same over the remaining invocations. That is, the file should converge to a stable version that doesn't change independent how often the script is executed on it.  Reality ---  The `graph` attribute gets more and more populated. The more often this is executed the bigger the file becomes.  `graph2.dot`:  ```dot digraph G { 	graph ["edge"="{}", 		"graph"="{'edge': '{}', 'graph': '{}', 'name': 'G', 'node': '{}'}", 		name=G, 		"node"="{}" 	]; } ```  `graph3.dot`: ```dot digraph G { 	graph ["edge"="{}", 		"graph"="{'edge': '{}', 'graph': \"{'edge': '{}', 'graph': '{}', 'name': 'G', 'node': '{}'}\", 'name': 'G', 'node': '{}'}", 		name=G, 		"node"="{}" 	]; } ```  `graph4.dot`:  ```dot digraph G {                    	graph ["edge"="{}", 		"graph"="{'edge': '{}', 'graph': '{\'edge\': \'{}\', \'graph\': \"{\'edge\': \'{}\', \'graph\': \'{}\', \'name\': \'G\', \'node\': \'{}\'}\", \'\ name\': \'G\', \'node\': \'{}\'}', 'name': 'G', 'node': '{}'}", 		name=G, 		"node"="{}" 	]; } ```
issue
nx.nx_agraph.read_dot should be able to parse dot from a string or a file-like object#TITLE_END#Hi,  Currently, `nx.nx_agraph.read_dot` seems to be unable to parse dot data from memory but I would like to avoid having to write a temporary file to be able to parse my dot graph.  Currently this works:  ``` python3 -c 'import sys,networkx as nx; nx.nx_agraph.read_dot("out.dot")' ```  and so does this:  ``` python3 -c 'import sys,networkx as nx; nx.nx_agraph.read_dot(sys.stdin)' < out.dot ```  But this will segfault:  ``` python3 -c 'import sys,io,networkx as nx; nx.nx_agraph.read_dot(io.StringIO("out.dot"))' ```  The underlying reason seems to lie in pygraphviz and I reported the issue as pygraphviz/pygraphviz#101.  The problem could easily be fixed by `nx.nx_agraph.read_dot` checking if the argument is either a string or a file-like object. In the former case, it should use `pygraphviz.AGraph(filename=...)` (and not the deprecated `file` argument as it is currently doing) and in the latter case it could slurp in the content behind the file descriptor and do `pygraphviz.AGraph(string=...)`.  Or am I missing an existing way that allows me to parse my dot data without writing a temporary file? 
issue
networkx is unable to save graphs in dot format where node names contain a colon#TITLE_END#Steps to reproduce:  ``` python >>> import networkx as nx >>> G=nx.Graph() >>> G.add_node("foo:bar") ```  writing out this graph in GraphML format yields the expected result:  ``` python >>> print(nx.readwrite.graphml.GraphMLWriter(G)) <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">   <graph edgedefault="undirected">     <node id="foo:bar" />   </graph> </graphml> ```  but writing the same graph in dot format replaces the node id `foo:bar` by the node id `foo`:  ``` python >>> print(nx.nx_pydot.to_pydot(G).to_string()) strict graph "" { foo; } ```  The reason for this is, that the colon in node ids has a special meaning in the dot format. Namely, the colon in a node name is used to specify input or output ports. For references see:  http://stackoverflow.com/questions/33722809/ http://stackoverflow.com/questions/31523810/ https://github.com/erocarrera/pydot/issues/38 http://www.graphviz.org/doc/info/attrs.html#k:portPos  A possible fix might be, to surround the node name with quotes if it contains a colon. Without quotes, pydot will understand the colon as a special character:  ``` python >>> import pydot >>> g = pydot.Dot() >>> g.add_node(pydot.Node('foo:bar')) >>> print(g.to_string()) digraph G { foo; } ```  If networkx would surround such vertex names with quotes, the problem would vanish:  ``` python >>> import pydot >>> g = pydot.Dot() >>> g.add_node(pydot.Node('"foo:bar"')) >>> print(g.to_string()) digraph G { "foo:bar"; } ```  Thanks! 
issue
Undeterministic output between different architectures#TITLE_END#Hi,  I'm testing in two Debian unstable chroots. I use chroots to make sure that both environment are exactly the same. The only difference is that one chroot is architecture i386 and the other is amd64. Consider the following graph:  ``` xml <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">   <graph edgedefault="directed">     <node id="n1616"/> <node id="n48"/> <node id="n3637"/> <node id="n2842"/>     <node id="n2530"/> <node id="n2396"/> <node id="n6453"/> <node id="n278"/>     <node id="n1209"/> <node id="n92"/> <node id="n793"/> <node id="n3631"/>     <node id="n341"/> <node id="n3151"/> <node id="n1717"/> <node id="n890"/>     <node id="n11399"/> <node id="n203"/> <node id="n1928"/> <node id="n555"/>     <node id="n156"/> <node id="n553"/> <node id="n2524"/> <node id="n3396"/>     <node id="n1741"/> <node id="n4117"/> <node id="n959"/> <node id="n1667"/>     <node id="n6489"/> <node id="n4973"/> <node id="n2247"/> <node id="n927"/>     <node id="n1211"/> <node id="n5467"/> <node id="n450"/> <node id="n1727"/>     <node id="n3531"/> <node id="n6357"/> <node id="n317"/> <node id="n37"/>     <node id="n14349"/> <node id="n1530"/> <node id="n12429"/>     <node id="n249"/> <node id="n348"/> <node id="n3285"/> <node id="n2518"/>     <node id="n406"/> <node id="n2034"/> <node id="n2855"/> <node id="n6"/>     <node id="n4742"/> <node id="n125"/> <node id="n281"/> <node id="n44"/>     <node id="n924"/> <node id="n926"/> <node id="n251"/> <node id="n5455"/>     <node id="n666"/> <node id="n3112"/> <node id="n2870"/> <node id="n6452"/>     <node id="n3156"/> <node id="n2299"/> <node id="n416"/> <node id="n4556"/>     <node id="n1832"/> <node id="n89"/> <node id="n2342"/> <node id="n1327"/>     <node id="n1333"/> <node id="n542"/> <node id="n674"/> <node id="n47"/>     <node id="n1174"/> <node id="n102"/> <node id="n1570"/> <node id="n1362"/>     <node id="n9721"/> <node id="n789"/> <node id="n270"/> <node id="n1524"/>     <node id="n4616"/> <node id="n6093"/> <node id="n2386"/>   </graph> </graphml> ```  I now run the following command in both chroots after installing the `python3-networkx` package version 1.9:  ``` PYTHONHASHSEED=0 python3 -c "import networkx, sys; g = networkx.read_graphml('test.xml'); networkx.write_graphml(g, sys.stdout.buffer)" | md5sum ```  Because of `PYTHONHASHSEED=0` the output will be deterministic for repeated calls in the same chroot. But surprisingly, the output is not the same between the two chroots of different architecture. The order is different and two elements have swapped position (`n1616` and `n6489`).  I was not being able to come up with a more minimal input graph than the one above. It seems that if I remove any node from it, then the error does not show anymore.  The error also does not show anymore if the order of the input graph is changed. I'm not claiming that the example I gave is the only graph which shows this behaviour, I'm just saying that not every graph shows this behaviour and that I do not know what triggers it, so I cannot make my example more minimal or clearer.  The desired behaviour would be for networkx to output the exact same file no mater the architecture it runs on. 
issue
Undeterministic output order with python3#TITLE_END#Hi, with Python3, hashes are salted and thus, functions like edges_iter return their results in a different order between subsequent python3 invocations. While this might be acceptable, this should be documented.  Unfortunately, a side effect of this is, that writing to a file does not produce deterministic output either. I'd argue that if the user saves the same graph twice with different invocations of python3, the generated graphs should not only be semantically the same but also byte-by-byte the same files.  Right now, this is only the case in python2.x but not anymore in python3 where a random seed is used by default.  Please document that the order of the various iterators in networkx depends on pythons internal order and is just not deterministic with python3.  Please make it such that when writing graphs to files, the output is deterministically the same between different invocations. 
issue
Allow to write graphs in sorted order#TITLE_END#- with python3, graph output is no longer deterministic because of hash   randomization - add sort argument to writer functions to make the output optionally   predictable - fixes issue #1181 
