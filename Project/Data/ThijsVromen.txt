issue
Bugs WL (sub)graph hashing in relation to use degree at initialisation#TITLE_END#### Current Behavior  At initialisation in both `weisfeiler_lehman_graph_hash` and `weisfeiler_lehman_subgraph_hashes` for graphs that do not have node or edge attributes, node weights are initialised using the degree of the nodes. This already aggregates information about neighbours at a 1-hop distance (the direct neighbours).  This has three main consequences. - The explanation and examples in the documentation are incorrect. It gives an example that requires 4 neighbourhood aggregations for certain nodes to converge to the same label, but incorrectly finds only 3 (the aggregation during node initialisation is not visible). - The behaviour of graphs with and without attributes (even if those attributes are trivial/irrelevant) is not in line with each other. This is because graphs with node attributes skip this step. - It hides a bug in the implementation for directed nodes: certain graphs are now correctly distinguished because of this initial step, but fail to be distinguished by graphs with attributes.   ### Expected Behavior  Using a node's degree can be an efficient way to aggregate information about the 1-hop neighbourhood. However, this should then be used as the first iteration, instead of during initialisation. It should not be used for directed graphs (at least not in this way) because apparently it treats outgoing and ingoing edges the same.  Directed graphs should consider both in- and outgoing edges at each iteration of the algorithm.  ### Steps to Reproduce  The iteration problem on undirected graphs: ```python # This is the example used in the documentation. G1 = nx.Graph() G1.add_edges_from([(1, 2), (2, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 7)]) G2 = nx.Graph() G2.add_edges_from([(1, 3), (2, 3), (1, 6), (1, 5), (4, 6)]) g1_hashes = nx.weisfeiler_lehman_subgraph_hashes(G1, iterations=3, digest_size=8) g2_hashes = nx.weisfeiler_lehman_subgraph_hashes(G2, iterations=3, digest_size=8) # diverge at iteration 3" print(g2_hashes[5]) print(g1_hashes[1]) # ['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc'] # ['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']   # now give both G1 and G2 node weights, all the same weight for i in range(1, 8):     G1.nodes[i]['weight'] = 1 for i in range(1, 7):     G2.nodes[i]['weight'] = 1 # run the WL algorithm again, but this time with node weights g1_hashes = nx.weisfeiler_lehman_subgraph_hashes(G1, node_attr='weight', iterations=4, digest_size=8) g2_hashes = nx.weisfeiler_lehman_subgraph_hashes(G2, node_attr='weight', iterations=4, digest_size=8) # diverge at iteration 4" print(g2_hashes[5]) print(g1_hashes[1]) # ['d9614b235de46ab6', 'c2e8da8e81cb1547', 'b04e4278628353d2', 'ad7c8ff452869678'] # ['d9614b235de46ab6', 'c2e8da8e81cb1547', 'b04e4278628353d2', '70167e752a1990c2'] ``` The (hidden) problem with directed graphs: ```python # Digraphs without weights use neighbourhood aggregation, which gives them information about both in- and outgoing edges. Ga = nx.DiGraph() Gb = nx.DiGraph() Ga.add_nodes_from([1, 2, 3, 4]) Gb.add_nodes_from([1, 2, 3, 4]) Ga.add_edges_from([(1,2), (3,2)]) Gb.add_edges_from([(1,2), (3,4)]) Ga_hash = nx.weisfeiler_lehman_graph_hash(Ga) Gb_hash = nx.weisfeiler_lehman_graph_hash(Gb) print(Ga_hash == Gb_hash) # False  # Now with trivial weights for i in range(1, 5):     Ga.nodes[i]['weight'] = 1     Gb.nodes[i]['weight'] = 1 Ga_hash = nx.weisfeiler_lehman_graph_hash(Ga, node_attr='weight') Gb_hash = nx.weisfeiler_lehman_graph_hash(Gb, node_attr='weight') print(Ga_hash == Gb_hash) # True ```  ### Environment  <!--- Please provide details about your local environment -->  Python version: 3.12.3 NetworkX version: 3.4.2  ### Additional context  Apologies for posting what are effectively two bugs in one issue, since they both at least partially arise from the same underlying issue I had trouble separating them.  If convenient, I'd be willing to make a pull request to fix this. Especially the fix for undirected graphs should be fairly straightforward. I'd need some more time to figure out how to fix the bug on directed graphs. 
issue
Fix graph_hash iteration counts and DiGraph handling#TITLE_END#Fixes #7806  Includes bugfixes for the issues discussed. Does not cover the potential extension to ```MultiGraph```s.  Extended testing, but note that a lot of the test in this module in depend on randomly generated graphs. We continued that here. However, that does not necessarily mean all edge-cases are covered (as the original bug showed). Note that subgraph hashing requires hashing of initial labels for digest size testing. This is not necessarily (and thus omitted) for general graph hashing.  ~~A small optimisation is also made to the original graph hashing method. It used to collect _all_ labels calculated during execution in a counter, and hashed that to get the final graph hash. However, the WL algorithm only relies on the colouring (labels) calculated at the last iteration, so the current versionl only hashes those to obtain the final hash.~~  
