issue
How to speed up calculating the graph edit distance between graphs whose size is about 30 nodes ?#TITLE_END#Hello,dear author,  I have a dataset which covers about 2000 graphs, this dataset covers the graphs who has about 30 nodes.The dataset format is like as following  ``` ...... t # 11808 v 1 C   v 2 C   v 3 O   v 4 O   v 5 C   v 6 S   v 7 S   v 8 O   v 9 O   v 10 C   e 1 2 1 e 1 4 1 e 1 5 1 e 2 3 1 e 2 10 1 e 5 6 1 e 6 7 1 e 7 8 2 e 7 9 2 e 7 10 1 t # 15905 v 1 C   v 2 C   v 3 C   v 4 C   v 5 C   v 6 C   v 7 S   v 8 C   v 9 C   v 10 C   v 11 C   v 12 C   v 13 N   v 14 O   v 15 O   e 1 2 1 e 2 3 2 e 3 4 1 e 4 5 2 e 1 6 2 e 4 7 1 e 7 8 1 e 8 9 1 e 9 10 2 e 10 11 1 e 11 12 2 e 8 13 2 e 7 14 2 e 7 15 2 e 5 6 1 e 12 13 1 t # 17157 .... ``` The explanation of this train.txt is : t # 11808 means the graph's id is 11808,  v 1 C  means the label of vertex 1 is 'C'  e 1 2 1 means the label of the edge from vertex 1 to vertex 2 is 1.  Now I should select a graph randomly as a query graph from this dataset. Next I will calculate the graph edit distance (GED) between this query graph and other graphs  from this dataset.  Before I calculate 1999 pais of graphs, I do a test between a pair of graphs. It cost me about 3.5 hours. [The code](https://github.com/networkx/networkx/blob/1800fe9108a7e9706c21659f9b9e01da7f4c74ef/networkx/algorithms/similarity.py#L37) I use is in the link ,it is shown as follows.  ``` path,cost = nx.optimal_edit_paths(g,query_graph,                                                         node_match = lambda node1,node2:node1['label']==node2['label'],                                                         edge_match = lambda edge1:edge2:edge1['label']== edge2['label'])  ```  It is too slow for me. And want to speed up the speed. I  want to use parallel computing , but I cannot have the ability to implement it.So I have some questions :   1.How to speed up the result of GED about 2000 pairs of graphs? 2.Could I use the parallel computing to implement it ?  The result of the code is too important for me ,because I want to do an index of the dataset to complete a query duty. So I want to do a ground_truth by the networkx code above. Hope I can get a contact with you  who has the idea.  
issue
How to print the subgraph isomorphism between two graphs?#TITLE_END#Dear  author, @jwegis @lonnen @cournape @alexbrc  I have two networkx graphs g1 and g2. The g1 and g2 defines as following: ``` #This is g1's definition g1 = nx.Graph() g1.add_node('1',label = 'c1') g1.add_node('2',label = 'h') g1.add_node('3',label = 'h') edges = [('1','2',{'label':'1'}),('1','3',{'label':'1'}),('2','3',{'label':'1'})]  g1.add_edges_from(edges) #This is g2's definition g2 = nx.Graph() g2.add_node('10',label = 'c1') g2.add_node('11',label = 'h') g2.add_node('12',label = 'h') edges = [('10','11',{'label':'1'}),('10','12',{'label':'1'})] #g2 has 2 edges now g2.add_edges_from(edges) ``` If we plot the two graphs on a paper according the g1 and g2 above ,we will see the expected "subgraph isomorphism" or "mapping"--------- {'1':'10','2':'11','3':'12'}.  But when I [use the code](https://github.com/networkx/networkx/blob/3d1732ef5c19ccff5d491b8b2650ce606cf673a3/networkx/algorithms/isomorphism/isomorphvf2.py#L1) to check the mapping from g1 to g2, it prints nothing. the code is as following: ``` GM = nx.algorithms.isomorphism.GraphMatcher(g1,g2,                                             node_match=lambda n1,n2:n1['label']==n2['label'],                                             edge_match = lambda x,y:x['label']==y['label'] )  for subgraph in GM.subgraph_isomorphisms_iter():     if subgraph:         print("mapping:"+str(subgraph))     else :         print("no matching") ```  But when I deleting an edge from g2,the networkx format like this: ``` g2 = nx.Graph() g2.add_node('10',label = 'c1') g2.add_node('11',label = 'h') edges = [('10','11',{'label':'1'})] #g2 only have 1 edge. g2.add_edges_from(edges)  for subgraph in GM.subgraph_isomorphisms_iter():     if subgraph:         print("mapping:"+str(subgraph))     else :         print("no matching") ``` it gives me the answer: ``` mapping:{'1': '10', '3': '11'} mapping:{'1': '10', '2': '11'} ``` So I have some questions : 1. How could I find all mappings from g1 to g2? The method I use is right? 2. Why did I not get the mapping when I first define the g2 who has 2 edges? why did I get the mapping after removing one edge from g2 ?  I am doing some research on "subgraph isomorphism" and I want to make the use of this algorithm. Maybe my clarification is not clear and my understanding is too shallow to express what I want. But I want to have some discussion with you. Looking forward to your reply. 
issue
The problems about the "similarity.py"#TITLE_END#Hello ,dear author:  I used your code named “similarity.py” about “how to calculate the GED problem” ([link](https://networkx.github.io/documentation/networkx2.2/_modules/networkx/algorithms/similarity.html#graph_edit_distance )or [link2](https://github.com/networkx/networkx/blob/master/networkx/algorithms/similarity.py) ) I read your code carefully, and have some questions as follows. # 1. How  how do you store a graph ?  We know that we often use “adjlist” or “adjmatrix” in the data structure. Every graph in your code use the graph of “networkx” , does it mean that we donnot need to consider the storage of a graph? # 2. How to define the cost ? I want to define the cost of opertating on a vertex or an edge like this: ``` path , cost = nx.optimal_edit_paths(graph_nx_1 , graph_nx_2,                                     node_subst_cost=5,node_ins_cost=1,node_del_cost=1,                                     edge_subst_cost=4,edge_ins_cost=2,edge_del_cost=3) ``` but it gives some bug which says `"TypeError: 'int' object is not callable".` I just want to define the cost of every operation on a node or an edge. But the parameter node_subst_cost/node_ins_cost and so on cannot be understood by me. You write the comments during the definition of the function like this : https://github.com/networkx/networkx/blob/7ae7f0146a33e340acbabe5a11d297e8187cb6d8/networkx/algorithms/similarity.py#L558  # 3.  the more paths, the less similarity between two graphs?  I print the "path" and "cost" after running the code. I wonder that if I can judge the similarity of two graphs by the number of paths or just the cost ?  I am struggling to  improve the performance of the GED caiculation and want to keep in touch with you. Hope for your reply.  @jwegis @cournape   Your sincerely, Woog.
issue
How to calculate the GED by the paths?#TITLE_END#Hi, dear code author, I am making researching on the graph edit distance by **[A*](https://github.com/networkx/networkx/blob/7ae7f0146a33e340acbabe5a11d297e8187cb6d8/networkx/algorithms/similarity.py#L153)** .I have 2 questions.  Firstly,I know that we can get a best path (or several best path) transforming a graph to another. But GED is the number of operations transfoming a graph to another graph. That is , how to calculating the GED by paths (or mapping we get by the algorithm)?   Secondly, I construct two graphs.The expected GED is 2, but it gives the 1.The code in my [github ](https://github.com/tiankonghenlan20113046/networkx_GED/blob/29f4367975625b35fe4150849568a09a4823b547/calculate_GED.py#L31)  shows me how to calculate it . we should subustitue edge(1,3) which labels '1' in q to edge (1,3) which labels '2' in g2, insert edge (1,3)  labeling '1' in q to g2. These two editi operations equal **GED = 2**.But the function gives me **1**. Please which faults did  I make ? @jwegis @lonnen 
comment
> They do seem to be isomorphic? >  > ![source](https://user-images.githubusercontent.com/4913181/85704534-48df3400-b6d8-11ea-9f69-ac57890c5c4a.png) > ![target](https://user-images.githubusercontent.com/4913181/85704556-51376f00-b6d8-11ea-824b-5641b179ae03.png) Thanks for  your contribution. Please how to plot the pics you draw ?
