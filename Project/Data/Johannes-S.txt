issue
Planar drawing algorithm#TITLE_END#We have added an algorithm that computes a planar drawing. This means for a planar graph it assigns each vertex a 2D position such that there is no intersection between any edges. It supports the existing API for graph drawing from `networkx/drawing`. The main algorithm is placed in `networkx/algorithms/planar_drawing.py`.  The algorithm is based on the paper "A Linear-time Algorithm for Drawing a Planar Graph on a Grid" from M. Chrobak and T.H. Payne.  Here are two examples how the generated graph drawings look:  | Small Graph | Large Graph | | -- | -- | | ![drawing_other_internally_triangulated](https://user-images.githubusercontent.com/7827287/44301466-b5888b00-a317-11e8-9327-d3cf14b49093.png) | ![drawing_large_graph_internally_triangulated](https://user-images.githubusercontent.com/7827287/44301469-ba4d3f00-a317-11e8-888d-2a69d222b513.png) | 
issue
Treewidth Heuristic#TITLE_END#We are a group of 8 students working on a project to improve graph libraries. We first plan on implementing heuristics for an upper bound on the treewidth. Many NP-complete problems can be solved efficiently if the treewidth is bound. We are implementing a minimum degree based heuristic and a minimum fill-in heuristic. They are described in section 4.3 in the paper linked below. We can submit a pull-request probably within the next 2 weeks.  [https://dspace.library.uu.nl/bitstream/handle/1874/22171/2005-018.pdf](https://dspace.library.uu.nl/bitstream/handle/1874/22171/2005-018.pdf)
comment
Hi, thanks for your feedback. Here is a selection of useful algorithms related to planarity: - Triangulation (we are currently working on it) - Planar drawing (we are currently working on it) - Planar generation (we are currently working on it) - Dual graph (easy) - 5-coloring algorithm   A datastructure for constant time insertion after a specific element (in the middle) would be a linked list. We cannot use pythons deque, because it does not allow the insertion in the middle. So we are now adding a datastructure that allows a constant insertion time and will add the non recursive version.
comment
Thanks for the StackOverflow link. However this would not really help here, because we do not have to iterate over the whole list. What we need is a constant time insert at a specific random position in the list (to insert an outgoing edge directly after another given outgoing edge).  We have now implemented our own data structure which would help here. We have implemented two versions: One implements the nx.Graph interface and the other one does not. I have added links to preliminary versions of each so you can have a look at it: 1. Subclass of nx.Graph : https://gist.github.com/Johannes-S/01d9243f86dbda0eb30ca5bb8729fe7c 2. No nx.Graph subclass: https://gist.github.com/Johannes-S/dacb6e55f0db4745cc7fd8e0e3c5c000  Both versions mainly use the variables ccw_nbr and cw_nbr. They are dicts that map a node v to a dict that maps each neighbor of v to the next neighbor of v in clockwise direction (or counter clockwise direction). It is similar to a doubly linked list, but by using dicts we get fast random access.  Which version would you prefer?  As we have mentioned, we are currently also working on the triangulation and a planar drawing algorithm, which would then also make use of this data structure.
comment
Hello, thanks for your response.  Sorry for the lack of an explanation of ccw and cw. In a final version we will include a more detailed explanation.  First I have listed a few general points, which I think might help to understand the LR-planarity algorithm: - The LR-planarity algorithm uses a directed graph `self.DG`, which is a spanning tree of the original graph. (For every edge in the original graph we have only one direction in the directed graph) - All edges of the original graph that are not part of the directed graph are so called back edges. Every back edge starts at a node in the directed graph and ends at a position in the directed graph (of lower height) - One main idea of the LR-planarity test is to partition the back edges into categories whether they must go LEFT around the lower part of the spanning tree, or RIGHT around it. The algorithm does this by considering different cases that force two back edges to be in opposite categories (one LEFT means the other cannot be in LEFT) or that force them to be in the same category (either both LEFT of both RIGHT). The main difficulty of the algorithm is so efficiently compute a solution to these constraints.  Now to the questions from your last comment:  >  [Are you constructing half edges as you go around a face and then the other half edge comes from the other face and] **it must have opposite polarity (cw or ccw) to be valid.?**  Half edges do not have a cw or ccw polarity. We just save the order in which the outgoing half-edges appear in the embedding. So for example a node v might have three neighbors w1, w2 and w3. Now a normal graph class would not know in which order these neighbors would appear in a planar embedding, so we need to safe the order but we want to use a data structure that makes it easy to add another neighbor at a specific position.   These neighbor nodes could appear in clockwise order (around v) as follows: [w1, w2, w3] and then the counter clockwise order is [w3, w2, w1]. So the half-edges do not contain a clockwise / counter clockwise parameter, but it just allows us to say how we want to view the neighborhood.  The methods `add_half_edge_cw` and `add_half_edge_ccw` are just named this way because the half edge that is added, can either be added clockwise to the `reference_neighbor`, or counterclockwise. With the example from above: `add_half_edge_cw(start_node=v, end_node=x, reference_neighbor=w2)` would lead to the following clockwise neighbor ordering of v [w1, w2, x, w3] (and of course the counter clockwise ordering [w3, x, w2, w1]).  If we would instead call `add_half_edge_ccw(start_node=v, end_node=x, reference_neighbor=w2)` then we get the following clockwise neighbor ordering of v: [w1, x, w2, w3] (and the counter clockwise ordering [w3, w2, x, w1]).  > Couldn't you find the "next neighbor" by looking up the neighbor in the outer dict?  We are not only interested in any next neighbor but to exactly the immediate next neighbor in counter clockwise or clockwise direction.  Note that we require the ordering at both sides of the edge. Therefore we have to include both directions. A half-edge data structure is only valid if both edges are present, so I think it would not make sense to consider it as a directed graph (because if  (v, w) is present (w, v) must also be present). However because of how the algorithm works it is easier to first add a half edge in one direction and later the half edge into the other direction, otherwise it would be nicer to enforce that both half edges have to be added at the same time. Therefore we have added the method check_structure, which checks that every half-edge has its opposite half-edge.  > Are you constructing half edges as you go around a face [...]  The LR-planarity algorithm does not add half edges along one face. We first add the half-edges of the directed graph `self.DG`  and later add the half edges for the back edges, so the edges that make up a face don't get added consecutively. However the half-edge structure allows us to compute the number of faces later to verify that an embedding is actually correct. This is done in the check_intersection method, which compares it to Euler's formula (N - E + F = 2) to proof that the returned embedding is actually planar.  > Finally, you often mention "constant time"... I always like to tweak the system by asking "constant as what variable changes?"  The parameter of the time complexity we give is the number of nodes or the number of edges of the input graph. Note that the maximum number of edges is proportional to the number of nodes for planar graphs (E &leq; 3*V-6 if V>2).   > How can you tell which direction you are going if you don't have an embedding to work from? Is the direction arbitrary for the first edge and once chose determined after that?   Not sure if I understand your question correctly. But of course there might be multiple cases where the resulting embedding is not unique for a specific input graph. E.g. a star graph could have an arbitrary order on the neighbors for the central node. I think the non determinism in the first depth first search (choosing some neighbor of a node) is determining which of the possible embeddings is returned. I would have to look at the code and the paper again to make sure that this is correct. 
comment
## Regarding Half-Edges The term half-edge is not an invention from us, it is in the literature also referred to as [doubly connected edge list (DCEL)](https://en.wikipedia.org/wiki/Doubly_connected_edge_list). We use the term half-edge, because even though the graph structure is undirected (an edge in one direction means that the graph also contains the other direction) the two directions of an edge are still different. For example a normal edge always has two faces as its neighbors (maybe one face is the outer face). Because half-edges always come in pairs, we can say that one half-edge belongs to one face and the other belongs to the other face. The following explanation goes into more detail on what this means.  I have added an image below to explain what half-edges are and what we use it for in more detail. <img src="https://user-images.githubusercontent.com/7827287/43066462-01ca98f4-8e65-11e8-8157-c54cef4d05df.jpg" width="50%"/>  I have labeled the nodes (1-7) and the faces (A-G).   #### What would the half-edge data structure contain in this case? The half-edge data structure saves to order of neighbors (or outgoing half-edges) for a node in clock-wise or counter-clockwise order. ```python {   1: [2, 4, 3],   2: [5, 4, 1],   3: [1, 4, 6],   4: [1, 2, 5, 7, 6, 3],   5: [7, 4, 2],   6: [3, 4, 7],   7: [6, 4, 5] } ``` The data above shows how the embedding would be represented in the current (unoptimized) implementation. For each node it displays its neighbors in clockwise order. Note that the first node in the list is arbitrary, so the neighbor list of node 4 could also be `[5, 7, 6, 3, 1, 2]`.  **Example: How would we obtain the clockwise half-edge of (4, 5)?**  1. Obtain the neighbor list of node 4. Result: `nbrs=[1, 2, 5, 7, 6, 3]` 2. Find the index of node 5. Result: `idx=2` 3. The neighbor of the desired half-edge is at the index `idx+1`. Result: `nbrs[idx+1]=7` 4. The clockwise half-edge of (4, 5) is (4, 7)  Of course the lookup in the list in step 2 is not very efficient, which is the main difference in our more optimized data structure.  ### What can the half-edge data structure be used for? In my drawing you can see that each half-edge belongs to exactly one face. For example the half-edge (4, 1) belongs to face B and the half-edge (1, 4) belongs to face A. The half-edge data structure allows us to determine all edges that belong to the same face. For example if we start with the half-edge (4, 1) and want to obtain all other edges that belong to the same face (B) we do the following:  1. Query the data-structure for the counter-clockwise neighbor of (1, 4) --> We obtain (1, 2) 2. Query the data-structure for the counter-clockwise neighbor of (2, 1) --> We obtain (2, 4) 3. Query the data-structure for the counter-clockwise neighbor of (4, 2) --> We obtain (4, 1), which is the same half-edge we started with  So we have found all half-edges (and therefore nodes) that belong to face B. Note that we flip the half-edge for our queries, because the data structure saves the order of **outgoing** half-edges for a node.  We can repeat this process for all half-edges that we have not encountered yet to get all faces of the graph. We can therefore obtain the number of faces of a planar graph, which cannot be determined that easily if you just have a normal graph structure.  Note that the half-edge data structure fixes which edges lie on each face, but does not fix which of the faces is the outer face.
comment
Thanks for the code. I think we can use this.  So this means we would implement a `PlanarEmbeddingGraph` class, which extends nx.DiGraph. We would then keep the default graph structure, but just add on top of it our API, which uses the edge attributes `cw` and `ccw`.  Do we have to account for the fact that a graph might include a node that is equal to `None`? In the code you posted this could lead to ambiguities because an edge attribute might be `None` if *no* neighbor has been assigned or if the `None` node has been assigned.
comment
Hello, We have added a commit to this pull request improving the following: - Removed recursion (we kept the easier recursive versions and added the suffix: `[...]_recursive`) - Added a PlanarEmbedding class (subclass of nx.DiGraph) - Improved documentation - Lower RAM consumption (by freeing variables that are no longer needed)   We have rebased the commits with the master branch so the tests run successfully.  We ran some benchmarks on larger graphs. We did use the planar graphs from https://users.dcc.uchile.cl/~jfuentess/datasets/graphs.php. The maximum memory consumption of the LR-Planarity algorithm is less than 3.5 times the memory consumption of the input graph.  | Edges [Million] | Max RAM [GB] | `nx.Graph` RAM [GB] | `nx.read_edgelist` time [hours] | `check_planarity` time [hours] | `check_structure` time [hours] | | --------------- | ------------ | ------------------- | ------------------------------- | ------------------------------ | ------------------------------ | |  3 |   8 |  3 | 0.0 | 0.1 | 0.0 | | 15 |  39 | 12 | 0.1 | 1.3 | 0.3 | | 30 |  77 | 24 | 0.3 | 2.9 | 0.6 | | 45 | 125 | 37 | 0.5 | 4.8 | 1.0 | | 60 | 155 | 48 | 0.6 | 6.5 | 1.3 | | 75 | 196 | 61 | 0.8 | 8.4 | 1.7 |  Notes regarding collums in the benchmark: - `nx.Graph` RAM [GB]: The ram consumption just for importing the graph into NetworkX - `nx.read_edgelist` time [hours]: The time it takes to import the graph into NetworkX - `check_planarity` time [hours]: The time the LR-Planarity algorithm takes - `check_structure` time [hours]: The time it takes to verify that the resulting embedding is correct (Just to make sure everything is correct)
comment
The current implementation should work even with directed and multigraphs as input. We already have included unit tests (see `test_planar_multigraph`, `test_planar_digraph`, ...) to verify that those inputs work correctly.  At the begin of the `get_counterexample()` method and `LRPlanarity.__init__()` we first copy the input graph into a new undirected graph, so it does not really matter with which graph type the method is called. The result of a planarity check of course does not change if we have multiple edges between two nodes.  So is it ok this way, or do you think it would be better to only allow undirected graphs as input?
comment
Yes, it is ready to merge. Thanks for your feedback!
comment
Thank you for the feedback, we changed everything you mentioned.
comment
Thanks for your comments, we have fixed all problems you mentioned. Now the pep8 checker does not return any error.
