issue
fix: Explicitly check for None/False in edge_attr during import from np#TITLE_END#[comment reference](https://github.com/networkx/networkx/pull/6259#discussion_r1280916514) in #6259 
issue
Allow user to opt out of edge attributes in from_numpy_array#TITLE_END#Begins to resolve #6248; tagging so @rossbar and @dschult can follow along :)  - [x] Update function signature and docstring - [x] Verify existing tests to ensure new behavior is backwards compatible - [x] Add new tests for new behavior
issue
Allow caller to opt out of adding `weight` attributes in `from_numpy_array`#TITLE_END#### Current Behavior  <!--- Tell us what happens instead of the expected behavior -->  Right now, calls to `from_numpy_array` add a `weight` attribute to all edges in the newly created (non-multi)graph.   ### Expected Behavior  <!--- Tell us what should happen --> It would be nice to allow the user to opt out of this behavior, or to specify an attribute that should receive this weight.  ### Steps to Reproduce  <!--- Provide a minimal example that reproduces the bug --> ```python import networkx as nx import numpy as np  mat = np.array([     [0, 1],     [1, 0] ]) g = nx.from_numpy_array(mat, create_using=nx.DiGraph) print(g.edges(data=True)) ```  ``` [(0, 1, {'weight': 1}), (1, 0, {'weight': 1})] ```  ### Environment  <!--- Please provide details about your local environment -->  * Python version: 3.10 * NetworkX version: All (2.6.3)  ### Additional context  <!--- Add any other context about the problem here, screenshots, etc. -->  This is confusing behavior because the caller does not explicitly request attribute creation. I would propose the following PREFERRED behavior:  #### Preferred  Creating a graph with an array of `dtype` âˆˆ {int, float} creates an attribute of name `weight_attribute`, which defaults to `w` for backwards compat.  ```python g = nx.from_numpy_array(mat, create_using=nx.DiGraph, weight_attribute="w") print(g.edges(data=True)) ```  ``` [(0, 1, {'w': 1}), (1, 0, {'w': 1})] ```  ```  Creating a graph with an array of `dtype` = bool treats each value as an existence flag and does not create an attribute:   ```python g = nx.from_numpy_array(mat==1, create_using=nx.DiGraph, weight_attribute="w") print(g.edges(data=True)) ```  ``` [(0, 1, {}), (1, 0, {})] ```  #### Also seems fine but changes fn signature:  Perhaps better for backwards compat is to allow the user to opt-out of the current behavior with a new argument `weight_attribute` which defaults to `weight` but can be set to `None` to remove this behavior. (Perhaps a bit more predictable than the above option?)  #### Seems kinda jank but is totally back-compat:  Setting `parallel_edges=True` and `create_using=nx.DiGraph` currently doesn't do anything, and could be repurposed to perform this behavior. Eh. This is kinda gross.
issue
in/out_degree interpret strings as collections#TITLE_END#When a node does not appear in a graph, calls to `out_degree` or `in_degree` treat a string node parameter as an iterable, yielding a `DegreeView`.  I'm not sure what I would expect to happen, but an IndexError might make sense; treating some strings as node names and some as iterables is confusing behavior.  ### Current Behavior  Consider the following example, in which I create two graphs. G2 is the important one here: Notice that it has nodes with multi-character names.  ```python import networkx as nx  G1 = nx.DiGraph()  G1.add_node("A") G1.add_edge("ABC", "B")   G2 = nx.DiGraph() G2.add_edge("A", "ABC") G2.add_edge("ABC", "BCD") ```  When I ask for degree information, SOME node names are treated as nodes; others are treated as iterables of single-character node names. **For example, let's create a dictionary of nodes to their out-degree:**  ```python {     c: G1.out_degree(c) # searching for degree in G1...     for c in G2.nodes   # for node-names taken from G2 } ```  ```python {'A': 0, 'ABC': 1, 'BCD': OutDegreeView({'B': 0})} ```  This dictionary very counterintuitively contains nonempty key-val pairs of nodes that don't exist in my graph!  I appreciate that some users may now rely upon this behavior, but I wanted to share it because it returns very counterintuitive results. I wonder if there might be a way to specify that I'm not looking for my node to be interpreted as an iterable:  ```python G1.degree("foo", is_iterable=False) # KeyError ```  (Just a thought!)  ### Expected Behavior  I would expect asking for out_degree of a nonexistent node to raise a `IndexError` or `KeyError` because the node isn't in the graph.   Note that `G2.out_degree(2)` raises a `TypeError` because 2 is not iterable.  ### Steps to Reproduce (See example above)  ### Environment <!--- Please provide details about your local environment --> * Python version: 3+ * NetworkX version: 2.4+  
issue
Fix betweenness_centrality doc paper links#TITLE_END#The links in the betweenness_centrality documentation no longer point to live paper references. This PR updates the docstrings with evergreen DOI links instead! :)
comment
@viktor-kryvyziuk if you're still looking for suggestions and @dschult approves, I'd recommend something like:  ```python def something_something_something_edges(     df: pd.DataFrame,      source_column: str = "source",      target_column: str = "target",      directed: boolean = False ) -> nx.Graph ```  In other words, the user can specify column headers if they are nonstandard, and otherwise it'll look for `source` and `target` columns; all the rest should be edge attributes, imo :)  I have a working implementation of this here, which is all Apache 2.0 if you'd like to borrow any of it: https://github.com/aplbrain/dotmotif/blob/master/dotmotif/ingest/__init__.py#L30-L47  **[edit]** this is with respect to the edge-specification question, sorry for the ambiguity 
comment
Ack. Sorry, silly oversight! (And sorry for the github notification spam!)
