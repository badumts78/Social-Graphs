issue
 write_gexf saves invalid dynamic graphs#TITLE_END#write_gexf does not save properly required metadata for dynamic graphs. It saves information about graph being dynamic, but omits "timeformat" attribute. This makes gephi to fail on reading of such file (see attached screenshot).  This bug is related to issue #3246: the metadata for a dynamic graph should contain information about time format.  Minimal test code: ``` import networkx as nx minimal = nx.read_gexf("minimal.gexf") nx.write_gexf(minimal, "minimal_saved_from_nx.gexf") ``` This is how the "graph" element looks like in the saved file: ``` <graph defaultedgetype="undirected" mode="dynamic" name=""> ``` This is how the line should look like: ``` <graph mode="dynamic" defaultedgetype="undirected" timeformat="dateTime"> ``` [minimal.gexf.txt](https://github.com/networkx/networkx/files/2593812/minimal.gexf.txt) ![screenshot_20181118_234620](https://user-images.githubusercontent.com/680825/48686828-2dbb5280-eb8c-11e8-9a4f-5ce6ab31c0da.png)    
issue
read_gexf does not parse ISO dateTime format#TITLE_END#read_gexf fails on parsing dynamic graph with temporal information provided in dateTime format. NetworkX was installed from github (commit 8f4845e94709dd62a4ebf3775fe02ca777ec49f2). Attached is a minimal sample graph. The file passes validation with xmllint: ``` $ xmllint --noout --schema gexf.xsd minimal.gexf minimal.gexf validates ``` [minimal.gexf.txt](https://github.com/networkx/networkx/files/2583893/minimal.gexf.txt)  Here is the test code: ``` print(nx.__version__) graph = nx.read_gexf("minimal.gexf") ``` Returned output: ``` 2.3rc1.dev_20181115061031  --------------------------------------------------------------------------- KeyError                                  Traceback (most recent call last) <ipython-input-6-39cc69bb07f8> in <module>()       1 print(nx.__version__) ----> 2 graph = nx.read_gexf("minimal.gexf")  <decorator-gen-752> in read_gexf(path, node_type, relabel, version)  /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/utils/decorators.py in _open_file(func_to_be_decorated, *args, **kwargs)     238         # Finally, we call the original function, making sure to close the fobj     239         try: --> 240             result = func_to_be_decorated(*new_args, **kwargs)     241         finally:     242             if close_fobj:  /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/readwrite/gexf.py in read_gexf(path, node_type, relabel, version)     177         G = relabel_gexf_graph(reader(path))     178     else: --> 179         G = reader(path)     180     return G     181   /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/readwrite/gexf.py in __call__(self, stream)     631         g = self.xml.find('{%s}graph' % self.NS_GEXF)     632         if g is not None: --> 633             return self.make_graph(g)     634         # try all the versions     635         for version in self.versions:  /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/readwrite/gexf.py in make_graph(self, graph_xml)     703         if nodes_element is not None:     704             for node_xml in nodes_element.findall('{%s}node' % self.NS_GEXF): --> 705                 self.add_node(G, node_xml, node_attr)     706      707         # add edges  /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/readwrite/gexf.py in add_node(self, G, node_xml, node_attr, node_pid)     728             data = self.add_slices(data, node_xml)  # add slices     729         else: --> 730             data = self.add_spells(data, node_xml)  # add spells     731         data = self.add_viz(data, node_xml)  # add viz     732         data = self.add_start_end(data, node_xml)  # add start/end  /usr/local/lib/python3.6/site-packages/networkx-2.3rc1.dev20181115061016-py3.6.egg/networkx/readwrite/gexf.py in add_spells(self, data, node_or_edge_xml)     829             ttype = self.timeformat     830             for s in spells_element.findall('{%s}spell' % self.NS_GEXF): --> 831                 start = self.python_type[ttype](s.get('start'))     832                 end = self.python_type[ttype](s.get('end'))     833                 data['spells'].append((start, end))  KeyError: 'dateTime' ```
