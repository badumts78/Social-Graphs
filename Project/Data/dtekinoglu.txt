issue
Remove to_numpy_matrix & from_numpy_matrix#TITLE_END#Remove deprecated functions `to_numpy_matrix` and `from_numpy_matrix` for NX 3.0. 
issue
Improve documentation of Component Algorithms#TITLE_END#Based on Discussion [#5464 ](https://github.com/networkx/networkx/discussions/5464), I made two main changes:  - Add `Raise` field to the `number_connected_components` method's documentation - Add valid input graph type (directed or undirected) to short description of components section methods 
issue
Adds `nx.draw_networkx_multigraph_edges` method#TITLE_END#This PR adds `nx.draw_networkx_multigraph_edges` method to the codebase.
issue
Graph walks implementation by jfinkels & dtekinoglu#TITLE_END#I created test_walks.py for the new methods,  when I tried to run them locally by `pytest test_walks.py` it gives the following output:  ![Adsız](https://user-images.githubusercontent.com/79102788/182185460-e7a63aba-edc4-46ec-bb64-677ef65cf68d.png)  What should I do to succesfully run the tests? @dschult @rossbar @MridulS 
issue
`nx.ancestors()` and `nx.descendants()` does not include the node itself.#TITLE_END#It is not stated in the documentations of `nx.ancestors()` and `nx.descendants()` about whether the node itself is included as ancestor/descendant or not. This information can be added to related documentations.  It is also possible to add a keyword argument to the source codes so that the user can include the node itself to its ancestors/descendants. 
issue
Implementation of LCA algorithm does not match with referenced paper#TITLE_END#The [reference paper](https://www3.cs.stonybrook.edu/~bender/pub/JALG05-daglca.pdf) stated in NetworkX documentation for lowest common ancestor, describes the algorithm as follow:  > Preprocess G by partitioning the set of edges into two sets: S1 is the set of edges of a spanning tree T of G, and S2 > is composed of the remaining edges, which make up the DAG D = (V, S2). Label the vertices of T by depth, breaking > ties arbitrarily. The same labels are used for D. Create a list Lv for each vertex v, which contains the ancestors of v in > D, including v itself. Proceed from vertex 0 until vertex n − 1. Sort the lists according to the first appearance of their > nodes in an Euler tour of T .  However, when I look at the current implementation, I saw that there are major differences.   - NetworkX implementation sorts the lists with respect to Euler tour of G although it should be of T. ``` euler_tour_pos = {} for node in nx.depth_first_search.dfs_preorder_nodes(G, root):     if node not in euler_tour_pos:         euler_tour_pos[node] = next(counter)  ``` - The paper states that Lv lists contain ancestors of v in D. However, in NetworkX implementation, Lv contains ancestors of v in G.  ```     ancestors = {}     for v in dag:         if pairs is None or v in pairset:             my_ancestors = nx.ancestors(G, v)             my_ancestors.add(v)             ancestors[v] = sorted(my_ancestors, key=euler_tour_pos.get) ```  IMO, current implementation does not follow the referenced study. Besides, the code seems complicated and difficult to understand. As it is stated in [Issue 4458](https://github.com/networkx/networkx/issues/4458), it does not work properly in some corner cases. I could not succesfully track the root cause down since there is a confict between the reference and the current implementation.   I would suggest to implement the algorithm using [Euler Tour + RMQ method](https://discuss.codechef.com/t/tutorial-lowest-common-ancestor-using-euler-tour-range-minimum-query/94326) which is more readable and not worse than the current one in terms of time and space complexity.  @rossbar @MridulS @dschult  
issue
`connectionstyle` argument of `nx.draw_networkx_edges()` does not work properly for multigraphs and undirected graphs#TITLE_END#`connectionstyle` argument of `nx.draw_networkx_edges()` does not work properly for MultiGraphs and Undirected graphs. Consider the following example:  ``` G=nx.DiGraph([(1,2),(3,1),(3,2)]) positions = {1:(0,0),2:(1,-2), 3:(2,0)} nx.draw_networkx_nodes(G, pos=positions, node_size = 500) nx.draw_networkx_edges(G, pos=positions, arrowstyle="-", connectionstyle="arc3,rad=0.3"); ``` Output is the following:  ![image](https://user-images.githubusercontent.com/79102788/178562664-87f24247-eee1-4bf8-a594-c01e4b145fbb.png)  The outputs of the same code snippet when G is created as a multigraph and an undirected graph (`G=nx.MultiGraph([(1,2),(3,1),(3,2)])` and `G=nx.Graph([(1,2),(3,1),(3,2)])`) as follows:  ![image](https://user-images.githubusercontent.com/79102788/178562886-5c6b5393-b4a3-4d4a-a5bf-d915c50c6381.png)  
issue
Defects of Bridges Algorithms#TITLE_END#Algorithms in the [Bridges](https://networkx.org/documentation/stable/reference/algorithms/bridges.html) section only applicable for undirected graphs. However, this is not stated in the documentation. They `Raise` `NetworkXNotImplemented` when the input is a directed graph. However, I am a bit confused about the following point:  Output of `nx.bridges(G)` is `<generator object bridges at 0x7f70733bb050>` . So, it seems that it works for directed graphs as well.  However, `list(nx.bridges(G))` raises `NetworkXNotImplemented`.  Is this expected? Should not `nx.bridges(G)` directly raise `NetworkXNotImplemented` instead?  With your guidance I am willing to work on this issue. @rossbar @MridulS @dschult 
issue
Add keyword argument to `nx.ancestors` & `nx.descendants`#TITLE_END#PR for #5801. I added keyword argument `include_source` to `nx.ancestors` and `nx.descendants` methods. If it is set to True, the list returned by the method will include the source node itself as its ancestor/descendant.
issue
Remove betweenness_centrality_source#TITLE_END#Remove betweenness_centrality_source for NX 3.0
issue
Rm jit.py#TITLE_END#Removed jit.py for NX 3.0. 
issue
Direction of arrows for undirected graphs -nx.draw(G, arrows=True)- misleading#TITLE_END#When I create an undirected graph and use `nx.draw()` function with argument `arrows=True`, arrows appear only in one direction even though I explicitly add edges (u,v) and (v,u) -which is actually not necessary in case of undirected graphs.  **Current Behavior**  `G=nx.Graph()` `G.add_edge(2,0)` `G.add_edge(0,1)` `G.add_edge(1,0)` `nx.draw(G, arrows=True, with_labels=True)` ![image](https://user-images.githubusercontent.com/79102788/161607567-828436e3-13fc-4329-be21-e49d3e47c2a0.png)  **Expected Behavior**  Arrows should appear in both directions for undirected graphs.  If this is not a feature but something to be improved, I can gladly work on this. @dschult @rossbar @MridulS  
issue
Disallow isolated nodes for Eulerian Path#TITLE_END#Fix #5594.
issue
Inconsistent implementation of Euler algorithms#TITLE_END#According to my research, having an Euler Circuit and/or Euler Path does not require a graph to be connected. Instead, it is enough that all of its vertices **with nonzero degree** belong to a single connected component. Nevertheless, there are some resources which states that a graph can have Euler Path and/or Euler Circuit  iff it is connected.  In the doc_string, it is stated that `has_eulerian_path` method follows the first opinion.  ``` A directed graph has an Eulerian path iff: - at most one vertex has out_degree - in_degree = 1, - at most one vertex has in_degree - out_degree = 1, - every other vertex has equal in_degree and out_degree, - and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.  An undirected graph has an Eulerian path iff: - exactly zero or two vertices have odd degree, - and all of its vertices with nonzero degree belong to a single connected component. ```  However, when we look at the source code, we see that it weirdly requires connectedness for undirected graphs but not for directed ones. Here is the related part:  ```   if G.is_directed():       # Remove isolated nodes (if any) without altering the input graph       nodes_remove = [v for v in G if G.in_degree[v] == 0 and G.out_degree[v] == 0]       if nodes_remove:           G = G.copy()           G.remove_nodes_from(nodes_remove) ``` If graph is directed, it removes the isolated nodes. But at the last part, it checks for connectedness both for directed (already removed isolated ones) and undirected graphs.  ``` return (             unbalanced_ins <= 1 and unbalanced_outs <= 1 and nx.is_weakly_connected(G)         ) else:     # We know it is not eulerian, so degree of source must be odd.     if source is not None and G.degree[source] % 2 != 1:         return False      # Sum is 2 since we know it is not eulerian (which implies sum is 0)     return sum(d % 2 == 1 for v, d in G.degree()) == 2 and nx.is_connected(G) ``` As a result, following examples return different results:  ``` >>> G = nx.DiGraph([(0, 1), (1, 2), (2, 0)]) >>> G.add_node(3) >>> nx.draw(G) >>> nx.has_eulerian_path(G) True ``` ![image](https://user-images.githubusercontent.com/79102788/166156024-a534f467-beb5-42f1-9caa-64d275c6f65f.png) ``` >>> G = nx.Graph([(0, 1), (1, 2), (0, 2)]) >>> G.add_node(3) >>> nx.draw(G) >>> nx.has_eulerian_path(G) False ``` ![image](https://user-images.githubusercontent.com/79102788/166155621-738726bd-ef3f-413a-8543-923065724b3c.png)   On the other hand, `is_eulerian` method requires connectedness for both graph types. IMO, there is an incosistency in the source code. If the first approach is to be accepted, it should be implemented both for Euler Paths and Euler Circuits since an Euler Circuit is nothing but an Euler Path that starts and ends at the same vertex. If you think that connectedness must be a condition, it should be implemented for both directed and undirected graph types.  @rossbar @dschult @MridulS 
issue
Add examples to compose operation#TITLE_END#Closes #4485  I added examples that show how to update node/edge attributes after `compose` operation. @dschult @rossbar 
issue
Improve bridges documentation#TITLE_END#This PR solves documentation problems of bridge algorithms. (Adding `Raise` `NetworkXNotImplemented` for directed graphs.)  @dschult I pushed another commit and reopened the PR for the following reason:  As you told, a previous PR makes bridge algorithms work for multigraphs as well. Thus, I revert my change `Raise` `NetworkXNotImplemented` for multigraphs. However, documentation did not include the raise for directed graphs. So, in my opinion, it needs to be included. I made that change. 
issue
Add is_planar function.  Solves issue #5109#TITLE_END#By the suggestion of @rossbar , I implemented `is_planar()` function which is mentioned in issue [#5109](https://github.com/networkx/networkx/discussions/5109).  To Do for myself: - Add tests for the new method. Could you please guide me on this? 
issue
Improve documentation of PlanarEmbedding class#TITLE_END#Closes #5090.  Please let me know if this needs any modification.  
issue
Change default value of arrowstyle for undirected graphs#TITLE_END#I changed default arrowstyle to "-" for undirected graphs. A person can still set another arrowstyle if he/she wants. But if `arrows=True` for undirected graphs without specifying an arrowstyle, no arrow-heads will be shown as expected.
issue
Improvement for issue 5192#TITLE_END#I added an example of [bethe_hessian_matrix] and printed the output.  I also added underscore character after each reference number. E.g. [2]_ 
issue
Solves issue #5538 partially#TITLE_END#I modified the source code so that only one direction of edges returned for `min_edge_cover`. However, could not correctly modify the related test. If you could guide me on this, I will gladly continue to work on it. @rossbar 
issue
Solves Issue #5486 partially#TITLE_END#I added `Raise` `NetworkXNotImplemented` fields for directed graphs and multigraphs to the documentation parts of all three bridge algorithms. Although `@not_implemented_for("multigraph")` was only writtten for `local_bridges()` method, the current behavior of other two methods also `Raise` `NetworkXNotImplemented` in the case of multigraphs. That is why I modified the documentation in this way. 
comment
Hi, @MridulS I am an Outreachy applicant for 2022 Round 1. I added examples for "nonedge" and "nodelist" arguments and created a pull request. Looking forward to hearing your feedback ! :)
comment
I created the subgraph induced on nodes in your first example:  ![image](https://user-images.githubusercontent.com/79102788/180567061-b78249b5-6156-48e9-9f11-44c034ad92ff.png)  As @U-238 told, total path length of 233 is 7, whereas it is 8 for 236. But I don't think this necessarily means that 233 is a lower ancestor than 236. For example, going from 256 to 233 might not be going "up" but instead they might be in the same level.  I thought of comparing their levels by finding the shortest paths to the root. The graph has 544 nodes with 0 in-degree. I calculated shortest paths to each of these 544 nodes for 233 and 236. Then, I got the longest of these shortest paths for each of these two nodes. Both of them has the lowest level for node 1784. Here are the shortest paths to 1784:  1. For 233 path length from the root 1784 is 20. [1784,1785,1787,1789,1791,1793,1794,1796,1798,1799,1801,1803,1804,1806,795,554,202,197,194,233] 2. For 236 path length from the root 1784 is 21. : [1784,1785,1787,1789,1791,1793,1794,1796,1798,1799,1801,1662,1654,879,864,532,9,7,4,6,236]  In other words, 236 is lower than 233 for root 1784. And among all roots, this root gives the lowest level for both 233 and 236.  I agree with @dschult and I will search more about the definition of LCA in DAGs.
comment
Hello @dschult , I want to work on this issue if it is still needed.
