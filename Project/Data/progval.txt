issue
Fix contracted_nodes with self_loops=True.#TITLE_END#Closes GH-2575.
issue
Use relative imports for version and release.#TITLE_END#Closes GH-2546.
issue
Add adjlist_outer_dict_factory.#TITLE_END#- Rename adjlist_dict_factory to adjlist_inner_dict_factory - Split node_dict_factory into node_dict_factory (and add its doc) and adjlist_inner_dict_factory (its previously documented purpose).  Motivation: in an application I am writing, I set `node_dict_factory` to a pseudo-dict that notifies a certain class when nodes are added to the graph. Unfortunately, `node_dict_factory` is also used to create the outer dict of the adjacency list, so I have no way to patch one and not the other. 
issue
Fix tests failing because of ordering issues.#TITLE_END#https://github.com/networkx/networkx/issues/2203#issuecomment-236373973 
issue
dfs_labeled_edges returns self-loops for sources#TITLE_END#As shown here: https://github.com/networkx/networkx/blob/d67f13025fc438149874fee70879a2d5ab22d0ec/networkx/algorithms/traversal/tests/test_dfs.py#L60-L68  Is this actually the expected behavior? 
issue
Test fixes for Jython and a few improvements#TITLE_END#Mainly test fixes. But also: - Fix to `edge_boundary`: https://github.com/networkx/networkx/commit/5e3da7202a2ea5a7302974172b86c14341961b2e - MultiGraph support for `assert_edges_equal`: https://github.com/networkx/networkx/commit/bed56aa0b1ec270c4c772f386c97dbd7aa0132b0 
issue
Many tests depend on CPython's ordering#TITLE_END#I started to look at #1671.  The first thing I noticed is that hundreds of tests fail. Most (all?) of them because of ordering issues, like the order of nodes, edges, or nodes in an edge.  I see three solutions to this: 1. Order everything in networkx's main code. 2. Use `sorted()` (or `set()` if the content is hashable) everywhere in tests. 3. Design and implement a small module for making comparisons in tests, eg. `assert_node_list_equal` or `assert_adjacency_list_equal`, and rewrite tests to use them.  I believe 3. to be the best solution, because 1 may slow it significantly on large graphs, and 2 will make tests a lot less readable. Additionally, this small module could be use by projects using networkx to write their own tests. 
issue
Random failures in test_agraph tests.#TITLE_END#Two tests in `test_agraph` sometimes fail on my machine.  After adding this code to `assert_equal`:  ```         print(sorted(G1.edges()))         print(sorted(G2.edges())) ```  the errors are:  ``` ====================================================================== FAIL: test_agraph.TestAGraph.testMultiUndirected ---------------------------------------------------------------------- Traceback (most recent call last):   File "/home/progval/.local/lib/python3.4/site-packages/nose/case.py", line 198, in runTest     self.test(*self.arg)   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 63, in testMultiUndirected     self.agraph_checks(nx.MultiGraph())   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 33, in agraph_checks     self.assert_equal(G, H)   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 27, in assert_equal     assert_true( sorted(G1.edges()) == sorted(G2.edges()) ) nose.proxy.AssertionError: False is not true -------------------- >> begin captured stdout << --------------------- [('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'A'), ('D', 'A')] [('A', 'C'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('D', 'A')]  --------------------- >> end captured stdout << ----------------------     'False is not true' = self._formatMessage('False is not true', "%s is not true" % safe_repr(False)) >>  raise self.failureException('False is not true')   ====================================================================== FAIL: test_agraph.TestAGraph.testUndirected ---------------------------------------------------------------------- Traceback (most recent call last):   File "/home/progval/.local/lib/python3.4/site-packages/nose/case.py", line 198, in runTest     self.test(*self.arg)   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 57, in testUndirected     self.agraph_checks(nx.Graph())   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 33, in agraph_checks     self.assert_equal(G, H)   File "/home/progval/dev/networkx/networkx/drawing/tests/test_agraph.py", line 27, in assert_equal     assert_true( sorted(G1.edges()) == sorted(G2.edges()) ) nose.proxy.AssertionError: False is not true -------------------- >> begin captured stdout << --------------------- [('B', 'A'), ('B', 'C'), ('C', 'A'), ('D', 'A')] [('A', 'C'), ('B', 'A'), ('B', 'C'), ('D', 'A')]  --------------------- >> end captured stdout << ----------------------     'False is not true' = self._formatMessage('False is not true', "%s is not true" % safe_repr(False)) >>  raise self.failureException('False is not true')   ---------------------------------------------------------------------- ```  Using networkx from the `master` branch. 
issue
convert.from_dict_of_dicts' result depends on ordering#TITLE_END#I modified the code like this:  ```         else: # Undirected             if G.is_multigraph():                 seen=set()   # don't add both directions of undirected graph                 for u,nbrs in d.items():                     for v,datadict in nbrs.items():                         print(datadict)                         if (u,v) not in seen:                             print('not seen')                             G.add_edges_from( (u,v,key,data)                                                for key,data in datadict.items()                                               )                             seen.add((v,u))                 print('foo')                 try:                     print(G[1])                 except:                     pass ```  and I run the test `test_to_undirected`.  On CPython 2.7, the output is:  ``` {0: {}} not seen {0: {}} not seen {0: {}} {0: {'foo': []}} not seen {0: {}} {0: {}, 1: {'foo': []}} foo {0: {0: {}}, 2: {0: {'foo': []}}} ```  On Jython, it is:  ``` {0: {}} not seen {0: {}} not seen {0: {}} {0: {}, 1: {'foo': []}} not seen {0: {}} {0: {'foo': []}} foo {0: {0: {}}, 2: {0: {}, 1: {'foo': []}}} ```  As you can see, the final value of `G[1])` depends on whether `{0: {}, 1: {'foo': []}}` or `{0: {'foo': []}}` as been explored first.  If you can't debug this easily, I can try to do it, but I don't really understand the dict structure here. 
issue
Use arrays instead of matrices in scipy.linalg.expm()#TITLE_END#Closes GH-2194. 
issue
Add support for reading adjacency matrix in readwrite.pajek.parse_pajek.#TITLE_END#Closes GH-2123. 
issue
Add support for subgraphs with no edges in convert_matrix.to_scipy_sparse_matrix.#TITLE_END#Closes GH-2181. 
issue
Remove temporary files after tests are run.#TITLE_END#This PR also simplifies the `try`/`finally` and `if` logic in these tests, using the `with` statement. 
comment
It would also be nice to have it work without multiprocessing, as it does not work on all platforms, like Jython, or Linux distributions without the right permissions on `/dev/shm`. 
comment
> The Jython website seems to indicate that there is a Jython 2.7.0 final release that supports Python 2.7, which should include multiprocessing, is that correct?  I don't think so. Jython provides “real” threads in the `threading` module, so `multiprocessing` is irrelevant.  > Does the implementation of `multiprocessing` always use the shared memory at `/dev/shm` on Linux systems?  I don't know, but I have received several bug reports related to this for one of my projects. 
comment
> how should I check the test coverage?  Below the the last comment, click “Show all checks”, then click the “Details” link right to coverage/coveralls, and search for your file.  > Other than that is there anything else to here apart from tidy up comments?  On my projects I consider that enough. I don't know about NetworkX's team standards. 
comment
It could be solved using `repr()` for writing and `ast.literal_eval()` for reading.
comment
@jfinkels NotImplementedError is an exception meaning that part of the **code** was not written yet, which should be raised to the user. NotImplemented is not an exception (it should be `return`ed, not `raise`d!), it means that this class doesn't know how to be compared with the other one, and that the other one should be called for the comparison. 
comment
Could you add this function to the `__all__` list at the beginning of the module, so it's available as `nx.transitive_reduction`?  Note: This feature was requested in #2185 
comment
Can you provide an example file? 
comment
>  But the way you set it up two objects that aren't the same can have the same hash  That's not the issue here. Because of this:  ```     def __hash__(self):         return self.x     def __eq__(self, x):         return x.x == self.x ```  objects are equal if and only if they have the same hash. And it is not an issue for two unequal objects to have the same hash (unless you care about performance).  The problem is that the definition of equality for these objects is twisted, because equals objects are displayed differently. So we tell Python these two objects are equal, but we don't read their string representations as being equivalent 
comment
> with some performance loss  This will happen even when dealing with integers (greater than 256), because two instantiations of the same (greater than 256) number give different objects (which obviously are equal):  ``` >>> a = 257 >>> b = 257 >>> a is b False ``` 
comment
> However, this should not be possible in a citation network data...  I wouldn't be so sure.  You can get a list of the missing edges this way:  ``` python from collections import Counter original_edges = Counter(frozenset((u,v)) for (u,v) in G.edges()) G2 = G.to_undirected() undirected_edges = Counter(frozenset((u,v)) for (u,v) in G2.edges()) missing_edges = original_edges - undirected_edges for ((u,v), count) in missing_edges.items():     if count != 0:         print('Missing edge: {} - {}'.format(u, v)) ```  This creates two edge-to-int dictionaries, which count the number of occurences of each edge, regardless of its direction (thanks to frozenset, which is unordered like a set, but is also hashable). Then it substracts the two, so you get t 
