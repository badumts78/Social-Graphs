issue
MultiGraph from graphml with explicit edge ids #3470#TITLE_END#Prior this commit, a graph with explicit edge ids but no parallel edges stored in a graphml was converted to  a Graph and the edge ids were moved to the edge data. This behaviour has been removed.
issue
MultiGraph: Why does G.edges[key] does not work? Only G.edges[u, v, k] does#TITLE_END#``` type(G) Out[305]: networkx.classes.multidigraph.MultiDiGraph  list(G.edges)[0:2] Out[306]: [('1_17_0', '2_16_0', 'e001'), ('1_17_0', '2_15_0', 'e002')]  G.edges['1_17_0', '2_16_0', 'e001'] Out[312]: {'index': 2, 'type': 't', 'transformation': '[[1,0],[0,1]]'}  G.edges['e001'] --------------------------------------------------------------------------- ValueError                                Traceback (most recent call last) <ipython-input-313-46b62708ebb6> in <module>() ----> 1 G.edges['e001']  ~/.local/lib/python3.6/site-packages/networkx/classes/reportviews.py in __getitem__(self, e)    1104     1105     def __getitem__(self, e): -> 1106         u, v, k = e    1107         return self._adjdict[u][v][k]    1108   ValueError: too many values to unpack (expected 3)  nx.__version__ Out[314]: '2.4' ```  Why is it not possible to address an edge in a MultiGraph with the unique key alone? Did I overlook another means to access an edge?  In interactive Jupyter sessions it would be nice when the shorter version would also work.
issue
Why is MultiDiGraph.edges.data(keys=False) the default?#TITLE_END#Consider a MultiDiGraph ``` type(G) Out[275]: networkx.classes.multidigraph.MultiDiGraph ``` `G.edges` returns as expected the source and target nodes and the edge id: ``` G.edges Out[276]: OutMultiEdgeView([('1_17_0', '2_16_0', 'e001'), ('1_17_0', '2_15_0', 'e002'), ```   However, `G.edges()` and `G.edges.data()` do only return the nodes and not the edge id: ``` G.edges() Out[277]: OutMultiEdgeDataView([('1_17_0', '2_16_0'), ('1_17_0', '2_15_0'), ...])  G.edges.data() Out[278]: OutMultiEdgeDataView([('1_17_0', '2_16_0', {'index': 2, 'type': 't', 'transformation': '[[1,0],[0,1]]'}), ('1_17_0', '2_15_0', {'index': 2, 'type': 't', 'transformation': '[[1,0],[0,1]]'}), ...]) ```  I have to enable explicitly that the keys should be returned as well: ``` G.edges(keys=True) Out[279]: OutMultiEdgeView([('1_17_0', '2_16_0', 'e001'), ('1_17_0', '2_15_0', 'e002'),...]) ```  Why is this the case?
comment
To apply all node and edge default attributes one can use following snippet:  ```python # Expand Default Attributes for node, data in G.nodes(data=True):     for k, v in G.graph['node_default'].items():         if k not in data:             data[k] = v  for u, v, data in G.edges(data=True):     for k, v in G.graph['edge_default'].items():         if k not in data:             data[k] = v ```
comment
Are there specific reasons why networkx has chosen the graphml output representation for edge ids to be different to node ids?  This inconsistency is surprising for the user and reduces IMHO the readabililty of the xml code.
comment
@peterjc    The GraphML Schema Documentation defines the edge id as non-required xml attribute: http://graphml.graphdrawing.org/specification/xsd.html#element-edge  which lists all required and optional attributes.  The [GraphML primer](http://graphml.graphdrawing.org/primer/graphml-primer.html#GraphEdge) repeats this:  > Optionally an identifier for the edge can be specified with the XML Attribute id. When it is necessary to reference the edge, the id XML-Attribute is used. >  > An edge with all XML-Attributes defined >   >     ... >     <edge id="e1" directed="true" source="n0" target="n2"/> >     ...  From my point of view one could say the GraphML format defines an edge ID as well.  Another motivation to treat them more special are graphs with multi-edges.
comment
@dschult Thanks for your response.  > It's not clear to mean what you (@kiryph ) are questioning/suggesting.  As the OP I would have used the xml representation as written in the title of this issue      <edge id="XXX">  and used on the graphml website.  > What should the edge ID be?  It is an optional attribute and should only be written when the user has created edge ids or the original input has provided ones.  > Why isn't it enough to have the edge data as attributes?  [sidenote] I assume you mean the id as [GraphML-Attribute](http://graphml.graphdrawing.org/primer/graphml-primer.html#Attributes) not [xml attribute](https://www.w3schools.com/xml/xml_attributes.asp) `<edge id="">`; the graphml primer emphasizes:  > GraphML-Attributes must not be confounded with XML-Attributes which are a different concept.  [/sidenote]   I see several reasons why I would prefer the edge id as an xml-attribute instead of a graphml-attribute:  - More readable xml files:    less lines and no cryptic and easily confused key id `d1` (in another file without node colors it is `d0`). - XPATH expressions do not have to be modified (assuming the original file uses the representation from http://graphml.graphdrawing.org/). Furthermore, selection is similar to nodes, i.e. more intuitive. Example with [xmlstarlet](http://xmlstar.sf.net/):  ``` ❯ curl -L -O http://graphml.graphdrawing.org/primer/attributes.graphml ❯ xml sel -t -v '//_:node/@id' attributes.graphml n0 n1 n2 n3 n4 n5 ❯ xml sel -t -v '//_:edge/@id' attributes.graphml e0 e1 e2 e3 e4 e5 e6 ``` Run once through networkx ``` ❯ python3 -c "import networkx as nx; nx.readwrite.graphml.write_graphml(nx.readwrite.graphml.read_graphml('attributes.graphml'), 'attributes-networkx.graphml')" ``` Original XPATH expression does not work anymore: ``` ❯ xml sel -t -v '//_:edge/@id' attributes-networkx.graphml  # nothing. You have to modify your XPATH expression ❯ xml sel -t -v '//_:edge/_:data[@key="d2"]' attributes-networkx.graphml e0 e1 e2 e3 e4 e5 e6 ```  - Output in agreement with the examples given on the official website of graphml (more newbie friendly) - Smaller xml files (less important for xml, but still) - ~~Graphs with multi-edges are written in a more obvious way. In general I would argue data for different edges can be equal but edge ids cannot which makes this value more special than edge weight/direction/...~~ (incorrect, see my next comment)  Actually, I do not know any reason why I would prefer it the other way. Saying that nodes are different to edges is obvious (the xml tags are `<node>`and `<edge>` and makes this clear enough). There is no need for additional syntactic differences.
comment
(comment updated)  ### `MultiGraph`<--> GraphML files with edge ids as xml attributes   I have noticed following two behaviours: 1. Reading data from a GraphML file with actual parallel edges gives a NetworkX `MultiGraph`/`MultiDiGraph`. If no parallel edges are found, the graph is converted to `Graph`/`DiGraph`. 2. A networkx `MultiGraph`/`MultiDiGraph` is always saved with edge ids as xml attributes (what this issue is about). Note parallel edges do not need to exist:  ```python import networkx as nx G = nx.MultiGraph() G.add_edge(1, 2, color='red', key='e0') G.add_edge(1, 2, color='red', key='e1') nx.readwrite.graphml.write_graphml(G, 'demo-multigraph.graphml') ``` ``` ❯ cat demo-multigraph.graphml <?xml version='1.0' encoding='utf-8'?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"><key attr.name="color" attr.type="string" for="edge" id="d0"/> <graph edgedefault="undirected"><node id="1"/> <node id="2"/> <edge id="e0" source="1" target="2">   <data key="d0">red</data> </edge> <edge id="e1" source="1" target="2">   <data key="d0">red</data> </edge> </graph></graphml> ```  When I read again this file into networkx and show the edge data everything is as expected:  ```python J = nx.readwrite.graphml.read_graphml('demo-multigraph.graphml') J.edges.data(keys=True) MultiEdgeDataView([('1', '2', 'e0', {'color': 'red'}), ('1', '2', 'e1', {'color': 'red'})]) ```  However, when I delete the parallel edge either before saving to graphml with   ``` G.remove_edge('1','2','e1') nx.readwrite.graphml.write_graphml(G, 'demo-multigraph-no-parallel-edges.graphml') ```  or outside with a text editor, the GraphmlReader of networkx creates at in a first step again a `MultiGraph` from GraphML data but switches to an ordinary `Graph`/`DiGraph` and moves the edge ids to a data field when no parallel edges are found  https://github.com/networkx/networkx/blob/89daa927a0135a79cc69a75a3c89202158fa2ca7/networkx/readwrite/graphml.py#L719-L725  This breaks the read/write cycle when no parallel edges are present.  ### Suggestion  I could imagine that NetworkX `GraphmlReader` creates a `MultiGraph` if edge ids are provided in the graphml file regardless of the existence of parallel edges.  Hence, the Python type property `MultiGraph` is stored in the graphml file  by the existence of edge ids as xml attributes.  If the user wants a normal `Graph`, she must say so, which means ids are thrown away or moved to edge data. An explicit intervention of the user makes from my point of view sense here.  Did I overlook a reason why this is not feasible?  A naive change would be: ```diff ~/networkx/readwrite ❯ git diff graphml.py graphml-multi.py diff --git a/graphml.py b/graphml-multi.py index 3d3df04..230e89f 100644 --- a/graphml.py +++ b/graphml-multi.py @@ -761,8 +761,8 @@ class GraphMLReader(GraphML):          data = self.decode_data_elements(graphml_keys, graph_xml)          G.graph.update(data)  -        # switch to Graph or DiGraph if no parallel edges were found -        if not self.multigraph: +        # switch to Graph or DiGraph if no parallel edges were found and no edge ids are provided. +        if not self.multigraph and len(self.edge_ids) == 0:               if G.is_directed():                  G = nx.DiGraph(G) ```
