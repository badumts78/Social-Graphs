issue
Document `subgraph_view` function with support for filter functions#TITLE_END#This is functionality I've developed external to networkx and thought it might be a welcome feature.  An example of how I've used it is in an energy distribution circuit, where I want to stop iterating a series of conducting elements when I encounter an open switch. For example, in the following circuit i have several conductors (a,b), (b, c), (b, d) and (c, e) -- one of which is a switch. Depending on the status of the switch, i would want to stop traversing the graph so that I don't build a model of the circuit where there is a demand for power that can't be satisfied, which would probably cause my model to fail to solve.  ```     a---------b---------c./ .e->L                \                 \                  d->L ```  I'm open to suggestions about how this could work , but my vision for it is that traversal functions can accept a callable which takes a standard set of arguments -- for example, a depth-first-search edge traversal interrupt would be parametrized by the graph and the parent/child, so that within the interrupt i can perform any analysis on the graph and/or edge data that I want before deciding if the branch should be interrupted, which I can do by raising a `StopIteration` error.  I've created an issue, https://github.com/networkx/networkx/issues/3625, related to this PR, which may be a better place to discuss this at a high-level.   I'll probably work on adding this interface to the `edge_dfs` function and the bfs functions as well, which is why this PR is marked WIP for now. 
issue
3511 gml list support#TITLE_END#Taking a stab at issue https://github.com/networkx/networkx/issues/3511  As I got into this, I realized it is tricky, and it seems as though it isn't possible to support lists fully. The list syntax cited in the issue is actually a dictionary key/value description. The way i've implemented the change is that the example, ``` graph [   node [     id 0     label "n1"     properties [       0 "a"       1 "b"     ]   ] ] ``` gets `properties` parsed as `OrderedDict([(0, "a"), (1, "b"])`. this gets us * ability to index like a list, e.g. `graph.nodes(data=True)["n1"][1] >> "b"` * ability to iterate e.g. `for index, value in enumerate(graph.nodes(data=True)["n1"])`  however, its perhaps surprising that if you write in a property with lists, you get back a dictionary.  I had thought that maybe an alternative would be to not record keys, e.g. ``` graph [   node [     id 0     label "n1"     properties [ "a"  "b"  ]   ] ] ``` ...however, this doesn't work because there isn't an obvious reason why you wouldn't interpret this as just a key-value pair, i.e. `graph.nodes(data=True)["n1"] >> {"a": "b"}`
issue
Add Interrupt functionality to graph traversals#TITLE_END#One graph traversal technique I've used is an interrupt, essentially a handler function that decides if the branch in question should be traversed. This is important in applications such as energy distribution networks, where you might want to iterate over the circuit in a depth-first fashion but stop if you encounter an open switch that disconnects part of the network.  I have a basic idea for how to implement this and am happy to work on it, but would like to get feedback on whether this is a welcome idea and how people might want it to look.
comment
Wondering if its possible to reopen this issue? I think the solution that we came to here was not nuanced enough to account for all of the 'dot' syntax and ignores some parts of pydot that seem to work fine.  The syntax `Example:A` and `Example:B` have a specific meaning in graphviz where `A` and `B` are supposed to be ports of the node `Example` within i visually structured node shape, allowing for arrows pointing to specific parts of the node. There is additional documentation [here](https://graphviz.org/doc/info/shapes.html#record). Rejecting `Example:A` because it isn't quoted means that existing code which uses networkx to build a graph using these features would break (this is the situation i'm in, since i have existing code that builds dot graphs using networkx and pydot)  In addition, while I agree that there is a bug in pydot where ':' is present in *certain* attribute values, i don't see it occurring universally.  For example, if i define the following graph using networkx:  ```python    G = nx.Graph(node=dict(shape='record'))     G.add_node("TapeShieldCableInfo", label="{<header>TapeShieldCableInfo|<contents>name: +copper-wound\l}")     G.add_node("Cable", label="{<header>Cable|<contents> + name: string\\l + length: integer}")     G.add_edge(         "TapeShieldCableInfo:header",         "Cable:contents",     ) ```  I can convert this to pydot as follows:  ```python     source = nx.nx_pydot.to_pydot(G) ```  This produces a dot string that looks like this:  ``` strict graph  { node [shape=record]; TapeShieldCableInfo [label="{<header>TapeShieldCableInfo|<contents>name: +copper-wound\l}"]; Cable [label="{<header>Cable|<contents> + name: string\l + length: integer}"]; TapeShieldCableInfo; Cable; TapeShieldCableInfo:header -- Cable:contents; } ```  Here you can see that the 'label' attribute of each of my node definitions is properly quoted (note i'm using networkx 2.7 to make these examples, since 2.8 rejects the values).  In addition, if i render this using `graphviz.Source(str(source).render(...)` i get the following image:  ![image](https://user-images.githubusercontent.com/2414360/179889646-3ae90f7e-dbfb-4575-987e-8c9c6ee0777f.png)  You can see here that because i've defined my edge as `TapeShieldCableInfo:header -- Cable:contents" I get an edge linking the top of the `TapeShieldInfo` node to the bottom of the `Cable` node. This is exactly how `graphviz` is supposed to work, and although I agree its a bit counter-intuitive to someone who hasn't familiarized themselves with the syntax, its not a bug.   What I have found is that i can only reproduce an issue with the attribute values if i remove all special characters (other than colon) from the attribute before invoking pydot on the data:  ```python     G = nx.Graph(node=dict(shape='record'))     G.add_node("TapeShieldCableInfo", label="TapeShieldCableInfoname:copperwound234")  # only apha-numeric  chars and :     G.add_node("Cable", label="{<header>Cable|<contents> + name: string\\l + length: integer}")     G.add_edge(         "TapeShieldCableInfo:header",         "Cable:contents",     ) ``` produces  ``` strict graph  { node [shape=record]; TapeShieldCableInfo [label=TapeShieldCableInfoname:copperwound234]; Cable [label="{<header>Cable|<contents> + name: string\l + length: integer}"]; TapeShieldCableInfo; Cable; TapeShieldCableInfo:header -- Cable:contents; } ```  which results in a syntax error if i try to render to png using the graphviz backend. This relates to the issue in https://github.com/networkx/networkx/issues/4663 where someone had trouble specifying a gradient as an attribute value. In that case i think it makes more sense to only reject attribute values in the form `<alphanumeric string>:<alphanumeric string>' since pydot seems to properly handle other attribute values, and they are valid graphviz syntax.   ## TLDR  * graphviz applies a special meaning to node names that include colons in them * the posted issue, while a bit confusing, is valid grpahviz syntax and arguably shouldn't be rejected * if people want to use ":" in node names they need to either escape them with quotes, or not try to render those graphs using graphviz * the pre-checking of attribute values is too strict, ruling out inputs that pydot is able to process correctly (i.e. when they have non-alphanumeric characters) 
comment
@rossbar ok, that makes sense to me. i will look at switching to `pygraphviz` on my end
comment
I found another link to the spec  referenced by @MartinPJorge, http://svn.bigcat.unimaas.nl/pvplugins/GML/trunk/docs/gml-technical-report.pdf based on what it says, it isn't clear that the suggested format is even valid GML, since keys are supposed to start with alpha characters. ![image](https://user-images.githubusercontent.com/2414360/66880308-56142280-ef90-11e9-9c9d-3e260f831ebf.png). I tried loading a sample into gephi, another graph tool, and it couldn't even handle the file.   The spec does consider writing lists, but it only uses repeated keys, which of course does not support the above-mentioned edge-case. ![image](https://user-images.githubusercontent.com/2414360/66880555-6aa4ea80-ef91-11e9-8331-7f094400e052.png)  To support the format recommended here, you'd have to detect duplicate keys and switch to list-reading mode, but of course this suffers from the same problem as the current networkx implementation, that you can't detect a list unless it has multiple elements.  
comment
@Zoher15  could you print out `list(claim_g.edges(data=True))`? This would make it easier to reproduce. Also might be helpful to know `type(claim_g)`.
