issue
Fix for filtered MultiGraph views from `edge_subgraph` (#7724).#TITLE_END#Fixes #7724: `MultiGraph` views return inconsistent `has_edge` results.  ___  Minimum working example:  ```python import networkx as nx  G = nx.MultiDiGraph()  G.add_edges_from([("a", "b"),                   ("a", "c"),       # <-- to be filtered out                   ("c", "b")])  H = nx.edge_subgraph(G, [("a", "b", 0), ("c", "b", 0)])  print(f"{H.edges()}\n\n"       f"{H.has_edge('a', 'c')} \t H.has_edge('a', 'c')\n"       f"{('a', 'c') in H.edges()} \t ('a', 'c') in H.edges()\n\n"       f"{'c' in H['a']} \t 'c' in H['a']\n"       f"{'c' in list(H['a'])} \t 'c' in list(H['a'])") ```  Output **before** the PR:  ``` # [('a', 'b'), ('b', 'c')] # # True      H.has_edge('a', 'c')    # <-- inconsistent result # False     ('a', 'c') in H.edges() # # True      'c' in H['a']           # <-- inconsistent result # False     'c' in list(H['a']) ```  Output **after** the PR:  ``` # [('a', 'b'), ('b', 'c')]  # False      H.has_edge('a', 'c') # False      ('a', 'c') in H.edges()  # False      'c' in H['a'] # False      'c' in list(H['a']) ```
issue
`MultiGraph` views return inconsistent `has_edge` results#TITLE_END#### Current Behavior  Filtered views of a `MultiGraph`, created with `edge_subgraph`, return inconsistent results from `has_edge`.  ### Expected Behavior  Match the same results from a `Graph`: either `True` if the edge exists in the subgraph view, or `False` if not.  ### Steps to Reproduce  In case of a `MultiGraph`: checking if the edge `('a', 'c')` exists in the view may return **either `True` or `False`**.  ```python import networkx as nx  G = nx.MultiGraph()  G.add_edges_from([("a", "b"),                   ("a", "c"),       # <-- to be filtered out                   ("c", "b")])  H = nx.edge_subgraph(G, [("a", "b", 0), ("c", "b", 0)])  print(f"{H.edges()}\n\n"       f"{H.has_edge('a', 'c')} \t H.has_edge('a', 'c')\n"       f"{('a', 'c') in H.edges()} \t ('a', 'c') in H.edges()\n\n"       f"{'c' in H['a']} \t 'c' in H['a']\n"       f"{'c' in list(H['a'])} \t 'c' in list(H['a'])")  # [('a', 'b'), ('b', 'c')] # # True      H.has_edge('a', 'c')    # <-- inconsistent result # False     ('a', 'c') in H.edges() # # True      'c' in H['a']           # <-- inconsistent result # False     'c' in list(H['a']) ```  In case of a `Graph`: checking if the edge `('a', 'c')` exists in the view returns **only `False`** (as expected).  ```python import networkx as nx  G = nx.Graph()  G.add_edges_from([("a", "b"),                   ("a", "c"),                   ("c", "b")])  H = nx.edge_subgraph(G, [("a", "b"), ("c", "b")])  print(f"{H.edges()}\n\n"       f"{H.has_edge('a', 'c')} \t H.has_edge('a', 'c')\n"       f"{('a', 'c') in H.edges()} \t ('a', 'c') in H.edges()\n\n"       f"{'c' in H['a']} \t 'c' in H['a']\n"       f"{'c' in list(H['a'])} \t 'c' in list(H['a'])")  # [('a', 'b'), ('b', 'c')] # # False     H.has_edge('a', 'c') # False     ('a', 'c') in H.edges() # # False     'c' in H['a'] # False     'c' in list(H['a']) ```  Note that the same results follow in case of a `DiGraph` vs. a `MultiDiGraph` object.  ### Environment  Python version: `3.11.10` NetworkX version: `3.4.2`  ### Additional context  I am not sure if this is a known issue or a side-effect of edge keys in multigraphs, but thought I should report it just in case.
issue
Fixes #7575: Inconsistent `nx.subgraph` node types.#TITLE_END#Subgraphs now return node types as defined in the graph object, independent of the input to the `subgraph` function.  See corresponding issue ticket for details (#7575) and the example below for a quick rundown running `numpy==2.0.1`.  ___  #### Input:  ```python import networkx as nx import numpy as np  graphs = [       nx.dense_gnm_random_graph(3, 3),       nx.dense_gnm_random_graph(5, 10),       nx.karate_club_graph(), ]  nodes_int = [0, 1] nodes_npy = [np.int64(0), np.int64(1)] nodes_mix = [0, np.int64(1)]  edges_int = [(0, 1)] edges_npy = [(np.int64(0), np.int64(1))] edges_mix = [(0, np.int64(1))]  for G in graphs:     print(f"{G}\n"           f"G_subgraph_int: {G.subgraph(nodes_int).nodes()}\n"           f"G_subgraph_npy: {G.subgraph(nodes_npy).nodes()}\n"           f"G_subgraph_mix: {G.subgraph(nodes_mix).nodes()}\n"           f"G_edge_subgraph_int: {G.edge_subgraph(edges_int).nodes()}\n"           f"G_edge_subgraph_npy: {G.edge_subgraph(edges_npy).nodes()}\n"           f"G_edge_subgraph_mix: {G.edge_subgraph(edges_mix).nodes()}\n") ```  #### Output (after change):  ```none Graph with 3 nodes and 3 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [0, 1] G_edge_subgraph_mix: [0, 1]  Graph with 5 nodes and 10 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [0, 1] G_edge_subgraph_mix: [0, 1]  Graph named "Zachary's Karate Club" with 34 nodes and 78 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [0, 1] G_edge_subgraph_mix: [0, 1] ```  #### Output (before change):  ```none Graph with 3 nodes and 3 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [0, 1] G_edge_subgraph_mix: [0, 1]  Graph with 5 nodes and 10 edges G_subgraph_int: [0, 1] G_subgraph_npy: [np.int64(0), np.int64(1)] G_subgraph_mix: [0, np.int64(1)] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [np.int64(0), np.int64(1)] G_edge_subgraph_mix: [0, np.int64(1)]  Graph named "Zachary's Karate Club" with 34 nodes and 78 edges G_subgraph_int: [0, 1] G_subgraph_npy: [np.int64(0), np.int64(1)] G_subgraph_mix: [0, np.int64(1)] G_edge_subgraph_int: [0, 1] G_edge_subgraph_npy: [np.int64(0), np.int64(1)] G_edge_subgraph_mix: [0, np.int64(1)] ```
issue
`numpy>=2`: Inconsistent `nx.subgraph` node types (`int`, `np.int64`)#TITLE_END#Creating a subgraph with `nx.{edge_,}subgraph` returns nodes with inconsistent types, either `int` or `np.int64`.  Results seem to vary depending on (1) the node types given to the function; and (2) the order/size of the graph object.  ### Current Behavior  Creating subgraphs yield nodes with different dtypes depending on the original graph's order and the filtered nodes types.  ### Expected Behavior  Subgraphs should return node types as defined in the graph object, independent of (1) and (2) IMHO.  ### Steps to Reproduce  #### Input:  ```python import networkx as nx import numpy as np  graphs = [       nx.dense_gnm_random_graph(3, 3),       nx.dense_gnm_random_graph(5, 10),       nx.karate_club_graph(), ]  nodes_int = [0, 1] nodes_npy = [np.int64(0), np.int64(1)] nodes_mix = [0, np.int64(1)]  for G in graphs:     print(f"{G}\n"           f"G_subgraph_int: {G.subgraph(nodes_int).nodes()}\n"           f"G_subgraph_npy: {G.subgraph(nodes_npy).nodes()}\n"           f"G_subgraph_mix: {G.subgraph(nodes_mix).nodes()}\n") ```  #### Output:  ```none Graph with 3 nodes and 3 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1]  Graph with 5 nodes and 10 edges G_subgraph_int: [0, 1] G_subgraph_npy: [np.int64(0), np.int64(1)] G_subgraph_mix: [0, np.int64(1)]  Graph named "Zachary's Karate Club" with 34 nodes and 78 edges G_subgraph_int: [0, 1] G_subgraph_npy: [np.int64(0), np.int64(1)] G_subgraph_mix: [0, np.int64(1)] ```  ### Environment  Python version: `3.12.4` NetworkX version: `3.3` NumPy version: `2.0.1`  ### Additional context  (!) Please note that **this bug has been observed only on `numpy>= 2.0`.** Previous versions seem unaffected.  When running the same code on `numpy==1.26.4`, with the same networkx version, returned output is as expected:  ``` Graph with 3 nodes and 3 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1]  Graph with 5 nodes and 10 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1]  Graph named "Zachary's Karate Club" with 34 nodes and 78 edges G_subgraph_int: [0, 1] G_subgraph_npy: [0, 1] G_subgraph_mix: [0, 1] ```
issue
`write_graphml`: Small fix for object type description on `TypeError` exception#TITLE_END#Fixes a small issue when calling `networkx.write_graphml` on a graph with invalid attribute types (e.g., a `list`).  The exception message raised by networkx currently displays an unhelpful error message, which reads:  ``` TypeError: GraphML does not support type <class 'type'> as data values. ```  This PR simply fixes it to display the object type that is causing the exception, such as in:  ``` TypeError: GraphML does not support type <class 'list'> as data values. ```  
