issue
Parameter verification for LFR_benchmark_graph is incorrect#TITLE_END#The team which [developed the LFR benchmark](https://sites.google.com/site/santofortunato/inthepress2) uses the default values 2 and 1 for `tau1` and `tau2` respectively. This combination is forbidden in networkx, which demands values "strictly greater than 1".
issue
Switch to faster smallest-last algorithm implementation.#TITLE_END#Implementation used degree lists to track updates to the ever-shrinking graph. This reduced time from O(|V|^2) to O(|V|+|E|).   Because this was a replacement for the existing algorithm, instead of new functionality, no tests were added. This build passes all of the existing tests for smallest-last strategy. 
issue
*Really* allow community asyn_lpa test to have two answers#TITLE_END#This small fix improves on #2339 by incorporating the nosetests asserts, which give richer output upon failure.  EDIT: No, it actually fixes the fix to that testing bug we've had.
issue
Use faster random geometric graph implementation.#TITLE_END#Replace the existing random geometric graph generator with one that uses a k-d tree to efficiently determine which nodes are adjacent, so the algorithm is now `O(n)` instead of `O(n^2)`.  Use p-norm number as parameter instead of function. The scipy KDTree requires a number instead of distance function.
issue
`erdos_renyi_graph` is a possible misnomer#TITLE_END#Erdos and Renyi introduced the G(n, M) model. Gilbert [introduced](http://www.jstor.org/stable/2237458) the G(n, p) model in the same year. Erdos and Renyi analyzed the G(n, p) model shortly after.   Is it correct to call the G(n, p) graph an `erdos_renyi_graph` (as one of its many synonyms)? Or would `gilbert_graph` be a better fit, and `erdos_renyi_graph` slowly move (by deprecation and reintroduction) to meaning the G(n, M) random graph?
issue
The tools/ directory is out-of-date#TITLE_END#These files are dated and no longer used, now that Travis is used for continuous integration. The files have also not been updated to handle recent versions of Python.  This line in `/tools/test_pr.py` makes it clear:  ``` python supported_pythons = ['python2.6', 'python2.7', 'python3.2','python3.3'] ``` 
issue
Rerun Travis?#TITLE_END#After pulling my changes (from a passing build), the NetworkX build is failing. I don't see any description of the failure in the Travis log. 
comment
_Totally_ off-topic, but how did you produce the stacked standard deviation/mean plots in your paper, @FerranPares ?
comment
And more on-topic: you should include tests for your code. I understand that it's difficult for an asynchronous algorithm (e.g. #2339 and #2341), but it's important. 
comment
@FerranPares Perhaps my question is simpler than you read it to be. My thesis was in a similar vein—using LFR benchmarks to appraise a CD algorithm—so I understand the benchmark process. I'm more curious about the matplotlib (or other plotting tool) code to plot standard deviation and means on one plot, without the axis numbers overlapping.  Additionally, you may wish to include the [`@not_implemented_for('directed', 'multigraph')`](https://networkx.github.io/documentation/networkx-1.10/_modules/networkx/utils/decorators.html) decorator to restrict the set of possible input graphs.  ~Finally, as the parameter `k` must be specified, this strikes me more as a graph partitioning algorithm. I'd appreciate an explanation of the difference; perhaps we could continue this conversation by email.~
comment
Raymond Hettinger (the `itertools` guy) has a [talk](https://www.youtube.com/watch?v=wf-BqAjZb8M) about PEP8 for big projects, and his golden rule of PEP8 is "PEP8 unto thyself, not unto others."  By removing whitespace, you introduced a failed test. I'd be interested to see whether you've uncovered a bug in the original implementation, if you're willing to do that digging. 
comment
When you run your tests, make sure you're doing `nosetests --with-doctest`. Also, your doctest output is different between Python 2 and Python 3 because `print` became a function. Because of how the REPL works, you don't need the `print`s—just put the expression you want evaluated on the line. 
comment
This is a really useful feature that you've implemented. I notice that `all_local_bridges()` is iterating over the edges, so it's cleaner to do that like this:  ``` python     bridges = {}     for e in G.edges():         G.remove_edge(*e)         try:             (u, v) = e                        path_length = nx.shortest_path_length(G, u, v)         except nx.NetworkXNoPath:             bridges[e] = -1  # found a bridge             if first_match:                 return bridges         else:             if path_length > 2:  # found a local bridge                 bridges[e] = path_length                 if first_match:                     return bridges         finally:             G.add_edge(*e)     return bridges ``` 
comment
You can also avoid global variables if you alter `all_bridges()` to use an inner function:  ``` python def bridges(G):     """ Looks through the graph object `G` for all bridges.      We formally define a bridge to be any edge `(u, v)` such that the removal     of the edge increases the total number of connected components.      Parameters     ----------     G : Undirected Graph object      Returns     ----------     iterable         Edges that are bridges      Examples     --------     >>> G = nx.cycle_graph(5)     >>> bridges = bridges(G)     >>> list(bridges)     []     >>> G.remove_edge(0,1)     >>> list(bridges(G))     [(2, 1), (3, 2), (4, 3), (0, 4)]      Notes     ----------     This function can be useful to quickly determine what bridges exist     in a given network. We use an implemenation of Tarjan's Bridge-finding     algorithm to do this.      The algorithm is described in [1]_.      References      ----------     .. [1] R. Endre Tarjan,          "A note on finding the bridges of a graph", *Information Processing          Letters*, **2** (6): 160--161      """      visited = set()     depths = {}     low = {}     parent = {node: None for node in G}      def bridge_util(u, depth):         visited.add(u)         depth += 1         depths[u] = low[u] = depth         for v in G[u]:             if v not in visited:                 parent[v] = u                 for e in bridge_util(v, depth):                     yield e                 # Check if subtree rooted at v has connection                 # to an ancestor of u.                 low[u] = min(low[u], low[v])                 # If the lowest vertex reachable from the subtree under v                 # is below u in the DFS tree, then `u-v` is a bridge.                 if low[v] > depths[u]:                     yield (u, v)             elif v != parent[u]:                 low[u] = min(low[u], depths[v])      for u in G:         if u not in visited:             for e in bridge_util(u, depth=0):                 yield e ```  This version is a generator, so it would make your `bridges_exist()` function even faster. 
comment
Hi @rmsyed—looking through the Travis logs, your problem is here:  ```       File "/home/travis/virtualenv/pypy3-2.4.0/site-packages/networkx/algorithms/bridges.py", line 217, in all_bridges               startnode = allnodes[0]     TypeError: 'generator' object is not subscriptable ```  The comment I posted above circumvents that, after which your build should pass. 
comment
Hey @rmsyed—Travis is comparing against the dev version of networkx, but I bet that when you run `import networkx as nx`, it gets your local version of networkx, which is (probably) the older 1.11.  A lot of the main library functions are now generators. One example is `G.nodes()`. Now that it's a generator, you can duplicate the functionality you want with `next(allnodes)`, which gets the next (in this case, first) item from the generator. There's actually a function in `nx.utils` called `arbitrary_element`, which uses that pattern while making your intent a bit clearer.  Of course, you can sidestep that whole process with the algorithm posted above. 
comment
One more thought: since `all_local_bridges()` may return just the first match, I might rename it `local_bridges()`. For symmetry, I'd rename `all_bridges()` to `bridges()`. Again, I'm really impressed that you tackled something missing from the codebase. It's always scary to venture forth in new directions. 
comment
Looks like this isn't the first PR of Tarjan's bridge-finding algorithm. See the discussion at #903.  
comment
You can increase the efficiency by only copying the user's graph once, outside of the loop over edges:  ``` python def local_bridges(G):     H = G.copy(with_data=False)     for u, v in G.edges():         ... ```  Then make sure to re-add the edge after removing it.  
comment
Have you followed the discussion at #1783?
comment
Just click on the failed jobs and you can look at the logs. In this case, the end of the traceback for the failed test is:  ``` text.python.traceback   File "/home/travis/miniconda/envs/test-environment/lib/python2.7/site-packages/networkx/drawing/nx_pylab.py", line 606, in draw_networkx_edges     fc=arrow_colors[i], IndexError: tuple index out of range ``` 
comment
Seems like @Zsailer fixed this; can we close it?  
