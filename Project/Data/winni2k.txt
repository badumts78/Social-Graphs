issue
Abstract base class for Graph, DiGraph, MultiGraph, and MultiDiGraph#TITLE_END#I am working with a project (https://github.com/broadinstitute/pyfrost/issues/1) that is using a custom backend for graph storage instead of dicts of dicts, mostly in order to save memory. The project is attempting to create a DiGraph compliant interface in order to use networkx algorithms. I have found it challenging/error prone to create a DiGraph-compliant interface in the past and I would find it helpful to have an abstract base class for the networkx graph types. Does this already exist somewhere? Is this an [XY](http://xyproblem.info/) problem, and should I/we be thinking about our problem in pyfrost differently?
issue
Add targets argument to all_simple_paths#TITLE_END#If one is looking to find all simple paths to multiple targets with out-degree 0, then emitting paths for a set of targets instead of each target separately improves big O algorithmic complexity by a factor of m, where m is the number of targets.  Further clarification: Because we are using an exhaustive depth-first search to find all paths to a target, all other targets will also be encountered during that search.  This PR changes the algorithm so that those paths are also emitted.    One might not want to use the `targets` argument if any of the targets have out-degree > 0.
issue
Please merge: PR 3138#TITLE_END#I have a [PR](https://github.com/networkx/networkx/pull/3138) that is ready to be reviewed.  I would like someone to look it over and if possible merge it, please.
issue
In all_simple_paths(). Replace list with OrderedDict for speedup#TITLE_END#See discussion of this at https://github.com/networkx/networkx/issues/2975#issuecomment-406354042
issue
Return values of `edge_dfs` could use cleanup#TITLE_END#From the documentation of `edge_dfs` in networkx 2.2:   > If orientation is ‘reverse’ or ‘ignore’, then edge takes the form (u, v, key, direction) where direction is a string, ‘forward’ or ‘reverse’,  that indicates if the edge was traversed in the forward (tail to head) or reverse (head to tail) direction, respectively.  I often find myself wanting to use `edge_dfs` with the `original` and with the `reverse` direction (dynamically set) in the same loop, but in the former case I get a tuple of two or three values, and in the latter case I get a tuple of three or four  values to work with, depending on whether I am working with a multigraph. I think it would be cleaner if `edge_dfs` always returned the direction value if the `direction` parameter to `edge_dfs` is not `None`.   Here is a wrapper that I think would do what I am talking about (untested code):  ```python def my_edge_dfs(G, source=None, orientation=None):     add_orientation = False     if orientation is None:         orientation = 'original'     elif orientation == 'original':         add_orientation = True     for edge in nx.edge_dfs(G, source=source, orientation=orientation):         if add_orientation:             edge = edge + (orientation,)         yield edge ```  What do people think?
comment
I've always found hashing of mutable objects problematic. Maybe it would be better to remove the `__hash__` function from nx graphs altogether?  Mutable base objects such as `set` aren't hashable either ...
comment
For example, what happens when someone changes a graph after it has been memoized? Will the memoization function return the changed or the original graph?
comment
More subclassing examples would be much appreciated!
comment
I noticed that `all_simple_paths` performs a linear search on the visited path.  I have a PR for a fix at https://github.com/networkx/networkx/pull/3074. I think that may be relevant to this benchmark?
comment
I should probably respond to the original post as well:  >In the doc, there is no warning about it when we pass in parameters as targets, those should be out-degree 0. Otherwise it may not return all_simple_paths as this function name indicates.  That is correct.  The way the code is currently written, `all_simple_paths` returns all simple paths ending when the first target is found.  >There also exists same mistakes in the test. path_graph used in the test not creating using DiGraph do not have out-degree 0 nodes.  I am in favor of testing with more inputs. However, the algorithm does not care about out-degree, so I'm not sure about this statement. Maybe more interestingly: We are dealing with a single-edge and a multigraph implementation.  If we are going to test with multiple graph inputs, then multigraphs should be included as well.  > in this example, pervious code would only get 1 path (which should be 2 paths of course).  Good catch!  >However, I think in one pass of DFS, we could enumerate all_simple_paths to many targets, including but not limit to leaf nodes (as out-degree 0). pls check the code below.  Do you mean that your suggestions would not necessarily enumerate all simple paths to all targets?   
comment
>I just draw some nodes and edges casually and make it just a little more complex (so one may not see through it at once).  Ok, let's try this: Did you come up with this test in a test-driven manner? That is, does this test catch something that no other test catches? That might be one way to name/describe the purpose of the test.  After taking a closer look at the test, it appears to me that this test is testing the `cutoff` parameter. I would suggest replacing the "non-trivial" test with one along the lines of "test_all_simple_paths_with_two_targets_cutoff" with a cutoff of 2. Alternatively, maybe just remove the test if it's testing something that another test will catch. Lastly, you could leave it in, but be prepared for the next contributor to delete it if they do not understand its point...  
comment
@dschult: barring any more changes from @GxvgiuU, this looks good to me.
comment
We are returning all simple paths between the source and every target. If all targets have degree 1, then the behavior of this function is not changed. If some targets have degree > 1, then this function should now return the same paths that would be retrieved if every target was fed into `all_simple_paths` one at a time.   @GxvgiuU, is my summary correct?
comment
I agree with @GxvgiuU that this behavior is likely more intuitive to most users and that we should adopt it.
comment
Hi, A big thanks for networkx from me as well!    For my problem I really do want every path. I did a line_profile of all_simple_paths, and it looks like line 270 below is an obvious place to do some optimizing inside networkx (line 263 is probably my fault, as I'm using my own graph implementation).  ``` Function: _all_simple_paths_multigraph at line 255  Line #      Hits         Time  Per Hit   % Time  Line Contents ==============================================================    255                                           @profile    256                                           def _all_simple_paths_multigraph(G, source, target, cutoff=None):    257         1          8.0      8.0      0.0      if cutoff < 1:    258                                                   return    259         1          1.0      1.0      0.0      visited = [source]    260         1          7.0      7.0      0.0      stack = [(v for u, v in G.edges(source))]    261     86228      60800.0      0.7      1.0      while stack:    262     86228      67452.0      0.8      1.1          children = stack[-1]    263     86228    1096883.0     12.7     17.3          child = next(children, None)    264     86228      65491.0      0.8      1.0          if child is None:    265     40559      32587.0      0.8      0.5              stack.pop()    266     40559      32270.0      0.8      0.5              visited.pop()    267     45668      43772.0      1.0      0.7          elif len(visited) < cutoff:    268     45668      34889.0      0.8      0.6              if child == target:    269        68       3453.0     50.8      0.1                  yield visited + [target]    270     45600    4611533.0    101.1     72.8              elif child not in visited:    271     45600      49808.0      1.1      0.8                  visited.append(child)    272     45600     239244.0      5.2      3.8                  stack.append((v for u, v in G.edges(child)))    273                                                   else:  # len(visited) == cutoff:    274                                                       count = ([child] + list(children)).count(target)    275                                                       for i in range(count):    276                                                           yield visited + [target]    277                                                       stack.pop()    278                                                       visited.pop() ```  Has anyone done, or is anyone doing any unmerged work in this direction?
comment
Yup, that fix appears to work great for my graph:  ``` Line #      Hits         Time  Per Hit   % Time  Line Contents ==============================================================    255                                           @profile    256                                           def _all_simple_paths_multigraph(G, source, target, cutoff=None):    257         1          8.0      8.0      0.0      if cutoff < 1:    258                                                   return    259         1          2.0      2.0      0.0      path_so_far = [source]    260         1          1.0      1.0      0.0      visited = {source}    261         1          7.0      7.0      0.0      stack = [(v for u, v in G.edges(source))]    262    251219     188907.0      0.8      4.0      while stack:    263    251219     201339.0      0.8      4.3          children = stack[-1]    264    251219    2659030.0     10.6     56.8          child = next(children, None)    265    251218     200550.0      0.8      4.3          if child is None:    266    122733     106208.0      0.9      2.3              stack.pop()    267    122733     128027.0      1.0      2.7              visited.remove(path_so_far.pop())    268    128485     119722.0      0.9      2.6          elif len(visited) < cutoff:    269    128485     103953.0      0.8      2.2              if child == target:    270       585      29676.0     50.7      0.6                  yield path_so_far + [target]    271    127900     119599.0      0.9      2.6              elif child not in visited:    272    127900     108511.0      0.8      2.3                  path_so_far.append(child)    273    127900     113695.0      0.9      2.4                  visited.add(child)    274    127900     605402.0      4.7     12.9                  stack.append((v for u, v in G.edges(child)))    275                                                   else:  # len(visited) == cutoff:    276                                                       count = ([child] + list(children)).count(target)    277                                                       for i in range(count):    278                                                           yield path_so_far + [target]    279                                                       stack.pop()    280                                                       visited.remove(path_so_far.pop()) ```
comment
I've added a pull request of the implementation with an ordered dict because that ends up being even faster on my dataset:  ``` Line #      Hits         Time  Per Hit   % Time  Line Contents ==============================================================    281                                           @profile    282                                           def _all_simple_paths_multigraph(G, source, target, cutoff=None):    283         1        332.0    332.0      0.0      if cutoff < 1:    284                                                   return    285         1         14.0     14.0      0.0      visited = collections.OrderedDict.fromkeys([source])    286         1         16.0     16.0      0.0      stack = [(v for u, v in G.edges(source))]    287    275933     181457.0      0.7      3.8      while stack:    288    275933     200504.0      0.7      4.2          children = stack[-1]    289    275933    2684622.0      9.7     56.3          child = next(children, None)    290    275932     196717.0      0.7      4.1          if child is None:    291    135035     104299.0      0.8      2.2              stack.pop()    292    135035     131754.0      1.0      2.8              visited.popitem()    293    140897     115143.0      0.8      2.4          elif len(visited) < cutoff:    294    140897      99379.0      0.7      2.1              if child == target:    295       643     228306.0    355.1      4.8                  yield list(visited) + [target]    296    140254     113483.0      0.8      2.4              elif child not in visited:    297    140254     114007.0      0.8      2.4                  visited[child] = None    298    140254     594512.0      4.2     12.5                  stack.append((v for u, v in G.edges(child)))    299                                                   else:  # len(visited) == cutoff:    300                                                       count = ([child] + list(children)).count(target)    301                                                       for i in range(count):    302                                                           yield list(visited) + [target]    303                                                       stack.pop()    304                                                       visited.popitem() ```
