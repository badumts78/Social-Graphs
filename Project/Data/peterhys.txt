issue
graph.copy() retains the original graph attribute dictionary if graph_attr_dict_factory is defined#TITLE_END#<!-- If you have a general question about NetworkX, please use the discussions tab to create a new discussion -->  <!--- Provide a general summary of the issue in the Title above -->   ### Current Behavior <!--- Tell us what happens instead of the expected behavior -->  The copy created using`graph.copy` shares the same graph attribute dictionary as the original, when graph_attr_dict_factory is defined (similar to the example [antigraph](https://github.com/networkx/networkx/blob/main/examples/subclass/plot_antigraph.py)).  ### Expected Behavior <!--- Tell us what should happen --> Expect `H.graph` is a shallow copy of  `G.graph`.  ### Steps to Reproduce <!--- Provide a minimal example that reproduces the bug -->   ```python  class AntiGraph(Graph):      graph_attr_dict = {"weight": 1}      def single_graph_attr_dict(self):         return self.graph_attr_dict      graph_attr_dict_factory = single_graph_attr_dict  >>> G = AntiGraph() >>> G.add_node(1) >>> H = G.copy() >>> H.graph is G.graph True ```   ### Environment <!--- Please provide details about your local environment --> Python version: python 3.8.13 NetworkX version: 2.8.3   ### Additional context <!--- Add any other context about the problem here, screenshots, etc. -->  The [copy method](https://github.com/networkx/networkx/blob/main/networkx/classes/graph.py):  ```python class Graph:     ...     def copy(self, as_view=False):         if as_view is True:             return nx.graphviews.generic_graph_view(self)         G = self.__class__()         G.graph.update(self.graph)         G.add_nodes_from((n, d.copy()) for n, d in self._node.items())         G.add_edges_from(             (u, v, datadict.copy())             for u, nbrs in self._adj.items()             for v, datadict in nbrs.items()         )         return G ```  The defined class attribute `graph_attr_dict = {"weight": 1}` in `AntiGraph` is mutable and shared across all instances. When the copy G is created, the newly defined `G.graph` is `self.graph`, rather than creating a shallow copy of the graph attribute.  I am not sure if this is intentional, but I think the examples and documentation are not clear that this is the expected behavior.
