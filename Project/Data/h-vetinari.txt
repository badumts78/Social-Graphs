issue
Add an edge_bfs traversal to match edge_dfs#TITLE_END#`networkx.algorithms.traversal.bfs_edges` does not correctly return all the edges of a graph if a node has more than one in-edge. My expectation would be (and critical in my application) is that in a traversal, _all_ edges in the graph are returned at some point in the iteration.  Here's an illustration  ``` import networkx as nx from networkx.algorithms.traversal import bfs_edges from random import shuffle  G = nx.DiGraph() e_in = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (6, 8), (5, 9), (7, 9), (8,10), (9,10)] # shuffle(e_in) # test that bfs_edges generates correct order G.add_edges_from(e_in) e_out = [e for e in bfs_edges(G, 1)] print('Received: ', e_in) print('Returned: ', e_out) print('Set difference: ', set(e_in) ^ set(e_out)) # Set difference:  {(6, 8), (9, 10), (7, 9)}  # visualisation # import graphviz as gv # gv.Source(nx.drawing.nx_pydot.to_pydot(G).to_string()) ```  The issue is in `generic_bfs_edges` in https://networkx.github.io/documentation/latest/_modules/networkx/algorithms/traversal/breadth_first_search.html, where a node gets excluded from forming more edge pairs if it gets visited once - hence the issue if a node has more than one in-edge. However, it's not a solution to completely exclude this visitor-mechanism, because then the respective child-nodes get added to the queue multiple times.  ``` from collections import deque, Counter def generic_bfs_edges_no_visitors(G, source, neighbors=None):     visited = {source}     queue = deque([(source, neighbors(source))])     while queue:         parent, children = queue[0]         try:             child = next(children)             if child not in visited:                 yield parent, child                 # visited.add(child)                 queue.append((child, neighbors(child)))         except StopIteration:             queue.popleft()  e_out = [e for e in generic_bfs_edges_no_visitors(G, 1, G.successors)] print('Received: ', e_in) print('Returned: ', e_out) print('Set difference: ', set(e_in) ^ set(e_out)) # Set difference:  set() print('Multiset difference: ', Counter(e_out) - Counter(e_in)) # Multiset difference:  Counter({(8, 10): 1, (9, 10): 1}) ```  Here's my proposed fix. I don't know enough about the rest of the library to see if this would break anything, but getting graph traversal right sounds pretty fundamental to me.  ``` def generic_bfs_edges_proposed_fix(G, source, neighbors=None):     visited = {source}     queue = deque([(source, neighbors(source))])     while queue:         parent, children = queue[0]         try:             child = next(children)             yield parent, child # moved this line out of the if-condition!             if child not in visited:                 visited.add(child)                 queue.append((child, neighbors(child)))         except StopIteration:             queue.popleft()  e_out = [e for e in generic_bfs_edges_proposed_fix(G, 1, G.successors)] print('Received: ', e_in) print('Returned: ', e_out) print('Set difference: ', set(e_in) ^ set(e_out)) # Set difference:  set() print('Multiset difference: ', Counter(e_out) - Counter(e_in)) # Multiset difference:  Counter() ```
comment
Thanks for responding so quickly on this, much appreciated. I think `networkx-core` would also be a fine solution (modulo a bit of migration pain, but possibly/likely everyone happier in the longterm).
comment
> `conda` does not have this feature. It will let a package author give constraints for optional dependencies with [`run_constrained`](https://docs.conda.io/projects/conda-build/en/latest/resources/define-metadata.html#run-constrained) in `metadata.yaml`, but there's no way to tell conda "install all optional dependencies".  Just to elaborate on that a bit, while conda does not have a concept of optional dependencies, it trivially supports multiple outputs per recipe. I haven't seen this fully formalized, but packages with many extras often get a mapping Ã  la `pip install package[extra]` -> `conda install package-extra` (including `package-all` if desired). There are several examples, here's [one](https://github.com/conda-forge/ray-packages-feedstock/blob/master/recipe/meta.yaml#L44-L59).
comment
Hey, I was just thinking about the old issue about this - what a fortuitous coincidence! :)  Very happy to see that you picked this up - even more so because I wouldn't have had an idea of all the additional functionality (MultiGraphs etc) that you needed.  Unfortunately, this still does not solve my original problem -- that edges come breadth-first, guaranteed. I used your definition of `edge_bfs` to test, and found the following counter-example (haven't had time to pare this down to the minimal counter-example possible, unfortunately...): ``` G = nx.DiGraph() e_in = [(1, 2), (2, 4), (2, 5), (1, 6), (6, 7), (4, 9), (5, 9), (7, 8), (8, 9), (8, 10), (9, 10)] G.add_edges_from(e_in) e_out = [e for e in edge_bfs(G, 1)] print(e_out) # [(1, 2), (1, 6), (2, 4), (2, 5), (6, 7), (4, 9), (5, 9), (7, 8), (9, 10), (8, 9), (8, 10)] ### (9, 10) __must__ come after (8,9) ###  # visualisation import graphviz as gv gv.Source(nx.drawing.nx_pydot.to_pydot(G).to_string()) ```  ![4](https://user-images.githubusercontent.com/33685575/42176757-53df11b0-7e2a-11e8-924e-cbab164e1848.png)  The order does not change with `orientation='original'`: ``` [e for e in edge_bfs(G, 1, orientation='original')] # [(1, 2, 'forward'), (1, 6, 'forward'), (2, 4, 'forward'), (2, 5, 'forward'), (6, 7, 'forward'), (4, 9, 'forward'), (5, 9, 'forward'), (7, 8, 'forward'), (9, 10, 'forward'), (8, 9, 'forward'), (8, 10, 'forward')] ```  I may not have the complete overview over graph-theory, and maybe your implementation works exactly as intended in my case above. But if so, would it be possible to add a keyword-option `orientation='enforce'` or something like that?  To clarify what I need: In my application, it is crucial that no edge is added to the queue whose originating node has not received all in-edges (as counted by the appearance of the corresponding edge in the `edge_bfs`-iteration).
comment
> Let me make sure I understand your need: For the example you show above is the problem that edge (9, 10) comes before (8, 9)? Any other edges off?  In the example above, there was nothing else off -- it doesn't matter what the exact order is between different side branches, but the crucial point is the following: Imagine the nodes being workers who take their incoming edges as inputs and produce the outgoing edges, and that the work cannot be executed before all inputs have been received (in the case above, node 9 would need to be executed to produce `(9,10)`, but cannot because it has not received the input from 8 yet).  > If I understand correctly, you want a topological_sort. Typically people using a topological sort want a list of nodes. But I guess i can imagine wanting the edges. Are you sure you want the edges? Maybe there is some way to get them from the ordered nodes.  I didn't know `topological_sort`, but looking at https://networkx.github.io/documentation/latest/reference/algorithms/generated/networkx.algorithms.dag.topological_sort.html > > A topological sort is a nonunique permutation of the nodes such that an edge from u to v implies that u appears before v in the topological sort order.  this looks to be exactly would solve the specification above (regarding the nodes, at least).  > I think the following gives a list of the edges for a topological sort. I would like a reference for this but I can't find any.  I played around with it a little(!) bit, and it looks good so far. Thanks a lot! Do you think this could make it into 2.2 still? 
comment
I'm not sure I understand you correctly -- you mean "people" = "workers" (=nodes for me) and "tasks" = "inputs" (edges for me)?  If so, inverting the conceptual setup like this is not really possible, and would make application/interpretation/visualisation that much harder.  But just calling `line_graph` as an intermediate step in the calculation is perfectly fine -- I don't need to have a purpose-built function. I'd just like to have a way that works out of the box, and your `list(nx.topological_sort(nx.line_graph(G)))` does so beautifully.  I didn't know either of those functions, and would never have been able to come up with that reasoning, but I can (sort of) understand it now, and appreciate its beauty. Thanks!
