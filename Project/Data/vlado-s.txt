issue
local efficiency bug?#TITLE_END#Hi all, I wrote my own routines for calculation of efficiency in weighted graphs. While testing them for un-weigted graph (all w=1) I discovered a difference in the values for local efficiency (global if fine). I believe there is a logical bug in the nx.local_efficiency(G) source which is:  return sum(global_efficiency(nx.ego_graph(G, v)) for v in G) / len(G)  however should be:  return sum(global_efficiency(nx.ego_graph(G, v, center=False)) for v in G) / len(G)  I conclude so based on the original paper by Latora & Marchiori (DOI: 10.1103/PhysRevLett.87.198701), where they state (page 2): "Since _E_ is also defined for a disconnected graph we can characterize the local properties of **G** by evaluating for each vertex _i_ the efficiency of **G**_i_ , the subgraph of the neighbors of _i_." Thus _i_ should not be in the ego_graph(G). How do you see it, am I right? Please let me know. Thank's a lot! Cheers, Vlado Sladek 
comment
I can confirm that when the graph nodes have the viz attributes (color, size, position), then the export via version 1.2draft cannot be read by Gephi 0.9.2 (latest release). If these attributes are not defined, then an export according to the 1.2draft version can be read (there will be a warning about deprecated format, but it will be opened) in Gephi 0.9.2.  The addition by @boofarzab does not help :) (I figured out the same "modification" independently, but no other change to code was done by me).  So, will the latest (and now default) version 1.3 be supported in NetworkX? Would be very useful.  If it will not be done in foreseeable time, can we get some hints about which parts of the code need to be fixed? So far I know about the networkx/readwrite/gexf.py module. But this itself does not define the exact format (as far as I could tell)?  Thanks
comment
Hi, Now I'm using the NetworkX implementation of the Louvain community detection algorithms. I'm not 100% sure about the interpretation of the edge weights in this algorithm. In NetworkX the general assumption is that weight is made equal to node distance, i.e. larger weight = larger distance / weaker connection. Right?  I contacted Renaud Lambiotte (co-author of the Louvain code) about this. He ensured me that in their code the interpretation of weight is reversed. To quote: "... I can tell you that our C++ code deals with weights as a notion of “importance” of a link. Stronger links hence imply stronger connections."  So my question is - how should I use weights in the NetworkX implementation?  Thank you.
comment
Just a quick note - in _Chem. Phys. Lett_. **319** (2000) 713 (where Estrada index is introduced) it is defined as _I_ = sum over i of exp{_lambda_(i)} Here _lambda_(i) are the eigenvalues of the adjacency matrix _A_ of graph _G_. However sometimes (e.g. in _Bioinf_. **18** (2002) 697 and apparently onward) he uses it normalised by _N_, which is the dimension of the adjacency matrix (number of nodes in _G_).  The value calculated by NetworkX is the first value (not normalised) - just in case someone was wondering why the large number :)  Also, obviously, NetworkX does not put any weights on the diagonal of _A_ - as used (recommended) in chemical application.
