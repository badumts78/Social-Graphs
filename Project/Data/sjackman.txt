issue
Longest path (diameter) in an undirected graph [question]#TITLE_END#I have a weighted undirected graph, and I'd like to determine the longest path(s) in the graph (any path would do if there are more than one). `distance_measures.diameter` would return the length of that path. `distance_measures.eccentricity` would allow determining the source and target vertices of that path.  As a special case, I've already used `tree.mst.maximum_spanning_tree` to find a maximum spanning tree, and I'm interested in determining the longest path of that tree.
issue
More than one maximum_spanning_tree#TITLE_END#The documentation for `maximum_spanning_tree ` says:  > There may be more than one tree with the same minimum or maximum weight. See networkx.tree.recognition for more detailed definitions.  https://networkx.github.io/documentation/networkx-2.2/reference/algorithms/generated/networkx.algorithms.tree.mst.maximum_spanning_tree.html  The results appear to be deterministic. I can run `maximum_spanning_tree` twice and I get the same result both times.  If however I use the exact same graph data, but change the order in which the vertices/edges are added to the graph, I get different results. When I use `networkx.drawing.nx_agraph.read_dot` to read the graph, I don't have control over the order in which the data is added to graph.  What techniques can I use to mitigate this effect to ensure consistent results, regardless of the order in which the data appears in the file on disk?  I'm working with a strict undirected graph with vertex names. Is it enough to ensure that the vertices are added in the same order? After reading the graph with `networkx.drawing.nx_agraph.read_dot`, I'm thinking of creating a new empty graph, sorting the vertices by name, adding the vertices in sorted order, and then copying the edges from the old graph to the new one. Do you think that'll do the trick? I'll test and report back.
issue
Longest path problem#TITLE_END#I've found the function `dag_longest_path`. Is there an algorithm for the longest path problem for directed graphs containing cycles, either exact or approximate? The general problem is NP-hard. See https://en.wikipedia.org/wiki/Longest_path_problem 
issue
dag_longest_path: Use edge weights#TITLE_END#If G has edges with 'weight' attribute the edge data are used as weight values. 
issue
Document dag_longest_path#TITLE_END#The algorithms [`dag_longest_path`](https://github.com/networkx/networkx/blob/master/networkx/algorithms/dag.py#L395) and `dag_longest_path_length` are not documented.  http://networkx.github.io/documentation/development/reference/algorithms.html  Thanks! 
comment
Hi, James. I stumbled upon this PR while looking for am implementation of `triconnected_components`. What's the status of this PR?
comment
Here's my poor-man's version of `triconnected_components`, in case anyone else stumbles on this issue.  ```python     def triconnected_components(g):         "Return the triconnected components of the graph."         components = []         for component in nx.biconnected_components(g):             if len(component) < 3:                 components.append(component)                 continue             try:                 cuts = next(nx.all_node_cuts(                     g.subgraph(component),                     k=2, flow_func=nx.algorithms.flow.shortest_augmenting_path))                 if len(cuts) > 2:                     components.append(component)                     continue                 assert len(cuts) == 2                 subcomponents = list(nx.connected_components(g.subgraph(component - cuts)))                 if len(subcomponents) == 1:                     components.append(component)                     continue                 components += subcomponents                 components.append(cuts)             except StopIteration:                 components.append(component)         return components ```  I'd appreciate any comments you may have about how to speed up this function.
