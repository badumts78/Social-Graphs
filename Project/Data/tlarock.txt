issue
Issue with networkx.has_eulerian_path()#TITLE_END#This issue adds to #3976   There appears to be a problem with the `has_eulerian_path` function. It returns the wrong answer on this example: ``` test_graph = nx.DiGraph() test_graph.add_edges_from([(0, 1), (1,2), (0,2)]) print(nx.has_eulerian_path(test_graph)) print(list(nx.eulerian_path(test_graph))) ``` Output: ``` True [(0, 0), (0, 1), (1, 2)] ```  This directed graph does not have a Eulerian path, and, adding to #3976, the path returned by `eulerian_path` is not an actual Eulerian path, since it (1) does not include the edge `(0,2)` and (2) includes a self-loop `(0,0)` that is not in the graph.  My hunch is that the problem is in this line: https://github.com/networkx/networkx/blob/3351206a3ce5b3a39bb2fc451e93ef545b96c95b/networkx/algorithms/euler.py#L256  I think changing that `2` to be `semibalanced_ins+semibalanced_outs` may do the trick, since the definition is >"...every _other_ vertex has equal in\_degree and out\_degree..."   Going to see about fixing and adding this test. Appreciate any clues, ideas or tips. 
issue
Inefficiency in _weighted_triangles_and_degree_iter#TITLE_END#The line  `max_weight=float(max(d.get(weight,1.0)                               for u,v,d in G.edges(data=True)))`  in _weighted_triangles_and_degree_iter is inefficient. The list of edges should be generated first, then iterated over. Running the following code on my machine, iterating over the pre-generated edgelist is twice as fast as not: `import timeit` `setup = 'import networkx as nx;G = nx.fast_gnp_random_graph(20000, 0.01); edges = G.edges(data=True)'` `timeit.timeit('m = float(max(d.get("weight", 1.0) for u,v,d in edges))', setup=setup, number = 5)` `timeit.timeit('m = float(max(d.get("weight", 1.0) for u,v,d in G.edges(data=True)))', setup=setup, number = 5)`
