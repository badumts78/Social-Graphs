issue
Graph.nbunch_iter() treat single node similarly to a sequence of nodes#TITLE_END#The [documentation for Graph.nbunch_iter()](https://networkx.org/documentation/latest/reference/classes/generated/networkx.Graph.nbunch_iter.html#networkx.Graph.nbunch_iter) states:  > The nodes in nbunch are checked for membership in the graph and if not are silently ignored.  Unknown nodes are indeed "silently ignored" if nbunch is a sequence, but not if nbunch is a single node. For example, using the following graph:  ```pycon >>> import networkx as nx >>> G = nx.from_edgelist([(0,1), (1,2), (2,3)], nx.DiGraph) ```  As expected, specifying a single node "2", which exists in the graph, returns an iterator containing just that node:  ```pycon >>> list(G.nbunch_iter(2)) [2] ```  As expected, specifying a list of nodes [0, 2, 5], where only 0 and 2 exist in the graph, returns an iterator containing only 0 and 2:  ```pycon >>> list(G.nbunch_iter([0, 2, 5])) [0, 2] ```  As expected, specifying a list containing a single node "5", which does not exist in the graph, returns an iterator that yields nothing:  ```pycon >>> list(G.nbunch_iter([5])) [] ```  Specifying a single node "5", which does not exist in the graph, should give the same outcome as above, but instead it throws an exception:  ```pycon >>> list(G.nbunch_iter(5)) Traceback (most recent call last):   File "/Users/mark/Dev/studbook/venv/lib/python3.9/site-packages/networkx/classes/graph.py", line 1911, in bunch_iter     for n in nlist: TypeError: 'int' object is not iterable  During handling of the above exception, another exception occurred:  Traceback (most recent call last):   File "<stdin>", line 1, in <module>   File "/Users/mark/Dev/studbook/venv/lib/python3.9/site-packages/networkx/classes/graph.py", line 1926, in bunch_iter     raise exc networkx.exception.NetworkXError: nbunch is not a node or a sequence of nodes. ```  This pull request fixes the latter case so a single node not in the graph is treated in the same way as a list containing a node not in the graph, i.e. by returning an iterator that yields nothing. I also provide clearer error messages.  I originally encountered this issue where my app's code uses `nx.edge_dfs(G, source)` and in some cases `source` was not in `G`. The resulting exceptions (as above) were very unclear and unhelpful in identifying the problem. These changes to `Graph.nbunch_iter()` will cause `edge_dfs()` to yield nothing if `source` is not in `G`, which is a sensible outcome in my particular use-case. But that may not be suitable for everyone, and consideration could be given to whether `edge_dfs()` and other similar functions should raise an exception if `source` is not in `G`.  Nonetheless, I recommend this PR because it brings `Graph.nbunch_iter()` more into line with what the documentation says it should do.  This PR somewhat implements "Option 2" proposed by @SultanOrazbayev in #6275.
issue
Lowest common ancestor returns incomplete result#TITLE_END#### Current Behavior  In the attached dataset and code, the result returned by `lowest_common_ancestor()` is a common ancestor but certainly not the lowest one. This can be seen in the output below, which shows the path between each node and the returned result.  ### Expected Behavior  `lowest_common_ancestor()` should return the LCA. In the attached example, the correct LCA of nodes 1082 and 1096 would be **183**.  ### Steps to Reproduce  Download attached dataset [lca_bug.json.txt](https://github.com/networkx/networkx/files/8677017/lca_bug.json.txt)  and rename to `lca_bug.json`  Put this Python script in the same directory as `lca_bug.json` and run it:  ```python import json import networkx as nx  # Load data with open('lca_bug.json', 'r') as f:     data = json.load(f) G = nx.node_link_graph(data) G_rev = nx.reverse(G)  x = 1082 y = 1096  # Find lowest common ancestor lca = nx.lowest_common_ancestor(G, x, y) print("Lowest common ancestor:") print("  %d" % lca)  # Show path to and from this ancestor print("Go up from X to LCA:") for node in nx.shortest_path(G_rev, x, lca):     print("  %d" % node) print("Then down from LCA to Y:") for node in nx.shortest_path(G, lca, y):     print("  %d" % node) ```  The returned result is below, with my own annotations added:  ``` Lowest common ancestor:   199 Go up from X to LCA:   1082   1081   183   <-- the correct LCA   448   184   187   195   199 Then down from LCA to Y:   199   195   187   184   448   183   <-- the correct LCA   1096 ```  The result 199 is not the correct LCA. The result should be **183**. The nodes 448, 184, 187 and 195 are additional common ancestors lower than 199 on the same path between 183 and 199. I also can't see any particular reason why it stopped at 199, because there are several common ancestors above 199 as well.  ### Environment  Python version: 3.9.12 NetworkX version: 2.8.1.dev0, latest git HEAD, specifically f50fc70b8cb6b4f5217a6d5505ba0e2b82b4761b 
comment
@dtekinoglu please also see #5628 which contains sample data that triggers an incorrect result
comment
I am also +1 for replacing the existing LCA functions with the new ones from @dtekinoglu. The `naive_` functions provide correct results where the existing functions are incorrect. This is a bug fix, not a new function.  The issues I raised in #5628 relate to the definition of LCA in a DAG where multiple LCAs exist for a pair of nodes, potentially with different path lengths between those nodes and the LCAs, but that does not necessarily make the new functions "wrong".
