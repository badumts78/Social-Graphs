issue
Graph generators change default random seed#TITLE_END#I noticed that, when passing graph generators a `seed` parameter, they change the _default_ seed for `random`. This affects affecting all subsequent calls to `random` in the module. That is, if a single generator is passed a `seed` parameter, all other generators are affected. [Most](https://github.com/networkx/networkx/blob/v1.10/networkx/generators/random_graphs.py#L47) [generators](https://github.com/networkx/networkx/blob/v1.10/networkx/generators/random_graphs.py#L602) seem to be doing this. The code in question is  ``` if seed is not None:     random.seed(seed) ```  Here's a discussion [on SO](http://stackoverflow.com/q/12368996/1600770). There is a simple solution. Creating an instance of `random` inside each function would make the seed change self-contained and prevent it from affecting other calls. Something like this would do  ``` if seed is not None:     my_random = random.Random(seed) else:     my_random = random ... # use my_random for calls ```  The same trick can be used if a NumPy random generator is needed  ``` my_random = np.random.RandomState(seed) ```  This could be especially useful to add a `seed` parameter to the layout functions, that currently lack one, and do not provide a way to arrange nodes deterministically (the same way in two different calls). see for instance [this function](https://github.com/networkx/networkx/blob/v1.9.1/networkx/drawing/layout.py#L55). 
issue
Graphml default attribute values are not applied#TITLE_END#It seems default attribute values for custom graphml attributes are not applied, when loading a graph.  Here is a test case  ``` import networkx as nx  G = nx.read_graphml("colored.graphml")  for node in G.nodes():     print(G.node[node]['color']) ```  Here's the input graphml file, a simplified version of this [official example](http://graphml.graphdrawing.org/primer/graphml-primer.html#AttributesExample).  ``` <?xml version="1.0" encoding="UTF-8"?> <graphml xmlns="http://graphml.graphdrawing.org/xmlns"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns          http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">   <key id="d0" for="node" attr.name="color" attr.type="string">     <default>yellow</default>   </key>   <graph id="G" edgedefault="undirected">     <node id="n0">       <data key="d0">green</data>     </node>     <node id="n1"/>   </graph> </graphml> ```  Here is an error showing that the default "yellow" value was not applied.  ``` green Traceback (most recent call last):   File "C:/Users/sturaroa/Documents/PycharmProjects/node_labeling_test.py", line 16, in <module>     print(G.node[node]['color']) KeyError: 'color' ``` 
issue
Inconsistent signatures for layout methods#TITLE_END#I noticed some good additions have been made to layouts for the 1.10 version.  However, I also noticed that `random_layout` is the only method lacking the `scale` parameter.  ``` random_layout(G, dim=2, center=None) circular_layout(G, dim=2, scale=1, center=None) ```  The `center` parameter has been added in v1.10. Adding `scale` as well would have made it more intuitive to switch between the two layouts.  A similar argument could be made for other methods, the signatures are quite inconsistent. Notice the order of parameters `dim`, `scale`, `center` and `weight`.  ``` circular_layout(G[, dim, scale, center]) random_layout(G[, dim, center]) shell_layout(G[, nlist, dim, scale, center]) spring_layout(G, dim, k, pos, fixed, iterations, weight, scale, center) spectral_layout(G, dim, weight, scale, center) ```  They could be re-organized for v2, putting parameters with the same name in the same place  ``` circular_layout(G[, dim, scale, center]) random_layout(G[, dim, scale, center]) shell_layout(G[, dim, scale, center, nlist]) spring_layout(G[, dim, scale, center, weight, k, pos, fixed, iterations]) spectral_layout(G[, dim, scale, center, weight]) ```  EDIT: another welcome addition would be a `seed` parameter for `random_layout` and possibly also for `spring_layout` (right now there's no way to make it deterministic). 
issue
Layouts in 1.10 behave differently#TITLE_END#Just updated my Anaconda distribution (v 2.3) to NetworkX 1.10. I noticed the same code for graph layouts returns very different plots.  ``` import networkx as nx import matplotlib.pyplot as plt  G = nx.random_regular_graph(2, 20) nx.draw_networkx(G, pos=nx.random_layout(G)) plt.show() nx.draw_networkx(G, pos=nx.circular_layout(G)) plt.show() nx.draw_networkx(G, pos=nx.spring_layout(G)) plt.show() plt.close() ```  Circular layout and spring layout (and possibly others) are double the size and centered differently Output of v 1.9.1, plot is 1x1 and centered on (0.5, 0.5) ![circular_layout_v1 9 1](https://cloud.githubusercontent.com/assets/1441393/9502170/f2bb65ca-4c2f-11e5-90b0-f631dad7f538.png) Output of v 1.10, plot is 2x2 and centered on (0.0, 0.0) ![circular_layout_v1 10](https://cloud.githubusercontent.com/assets/1441393/9502139/bab9bff0-4c2f-11e5-8bbd-423c53b1e275.png)  UPDATE: [the documentation](networkx.readthedocs.org/en/stable/reference/generated/networkx.drawing.layout.spring_layout.html) for `spring_layout` says it should position nodes "in a box of size [0,scale] x [0,scale]". But they get positioned in a totally different area, and the size of the box can be triple that.  ``` import networkx as nx import random import matplotlib.pyplot as plt  G = nx.barabasi_albert_graph(20, 3, 130) G.add_edge(21, random.choice(G.nodes()))  nx.draw_networkx(G, pos=nx.spring_layout(G)) plt.show() plt.close() ```  Notice how the height of the plotted graph is 3, from -2.0 to 1.0. ![spring_layout_v1 10_bug](https://cloud.githubusercontent.com/assets/1441393/9507383/2700fe30-4c4e-11e5-92d6-7f3d6fd51fff.png) 
issue
Bibtex authors line broken#TITLE_END#I noticed [this Bibtex](http://math.lanl.gov/~hagberg/Publications/hagberg-2008-exploring.shtml) to cite NetworkX in a paper  The `author` line is missing commas between surnames and names, so Latex shortens everything  ``` @inproceedings{hagberg-2008-exploring,     author = {Aric A. Hagberg and Daniel A. Schult and Pieter J. Swart}, ```  >  H. A. A., S. D. A., and S. P. J.  The fix is trivial and produces a readable result  ``` @inproceedings{networkx_paper,     author = {Hagberg, Aric A. and Schult, Daniel A. and Swart, Pieter J.}, ```  >  A. A. Hagberg, D. A. Schult, and P. J. Swart 
issue
Parameter description appears twice in adjlist functions#TITLE_END#The description of the `create_using` parameter appears twice in `adjlist` and `multiline_adjlist` functions ([1](http://networkx.github.io/documentation/networkx-1.9.1/reference/readwrite.adjlist.html), [2](networkx.github.io/documentation/networkx-1.9.1/reference/generated/networkx.readwrite.adjlist.parse_adjlist.html), [3](https://networkx.github.io/documentation/latest/reference/generated/networkx.readwrite.multiline_adjlist.read_multiline_adjlist.html), [4](https://networkx.github.io/documentation/latest/reference/generated/networkx.readwrite.multiline_adjlist.parse_multiline_adjlist.html)). 
issue
Missing arrows parameter in draw_networkx#TITLE_END#The parameter `arrows` is present in the doc of [draw_networkx_edges](https://networkx.github.io/documentation/latest/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html), but is not present in the doc of the more general [draw_networkx](https://networkx.github.io/documentation/latest/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html).  However, I tried to use `arrows=False` in `draw_networkx`, and it appears to work. Maybe it's just missing in the doc? 
issue
maximal_matching in v1.9.1 (latest)#TITLE_END#I have found a case where a maximal matching between 14 nodes can be found, but the algorithm only finds it for 12 of those nodes.  Here is a hand built example. ![graph to match](https://cloud.githubusercontent.com/assets/1441393/7997658/34c159e6-0af6-11e5-9de0-4ab8d285b373.png)  This is a maximum matching I found by hand. ![correct maximal matching](https://cloud.githubusercontent.com/assets/1441393/7997662/39309eba-0af6-11e5-9a30-f30ba9f5409d.png)  When running `maximal_matching` on that undirected graph, NetworkX v1.9.1 proposes me this matching, which is not maximal (node 3 and node 8 are not matched). ![wrong graph matching](https://cloud.githubusercontent.com/assets/1441393/7997682/9dbc3c7c-0af6-11e5-877f-1bc0789a081f.png)  Here is the adjacency list representing the graph  ``` 11 5 10 1 5 13 1 0 3 2 5 4 12 3 6 1 0 9 3 2 7 5 4 9 8 7 7 6 9 8 ```  Maybe this is a residual problem from version 1.8.1, mentioned in  #1558?  EDIT: I just found out that _maximAL_ matching is not the same as a _maximUM_ matching, so this behavior is probably technically correct however, if I search on Google "maximal matching", the first page of results is all about "maximUM matching". Moreover, if I search "maximal matching networkx", the very first result points to the [matching doc](https://networkx.github.io/documentation/latest/reference/algorithms.matching.html) It doesn't even warn "maybe you meant...".  The problem people are commonly facing is to search for a maximUM matching. That maximAL matching thing there is just tricky. 
issue
Possible bug in nx.relabel_nodes#TITLE_END#Relabeling nodes to their own id when `copy=False` can create problems  ``` import networkx as nx  G = nx.Graph() G.add_nodes_from([(0, {'data': 0}), (1, {'data': 0}), (2, {'data': 0}), (3, {'data': 0}), (4, {'data': 0})]) print('G.nodes(data=True) = ' + str(G.nodes(data=True)))  # this will print an empty graph, or a graph where nodes lost their data nx.relabel_nodes(G, mapping={0: 0, 1: 1, 2: 2, 3: 3, 4: 4}, copy=False) print('G.nodes(data=True) = ' + str(G.nodes(data=True)))  # this works nx.relabel_nodes(G, mapping={0: 1, 1: 2, 2: 3, 3: 4, 4: 5}, copy=False) print('G.nodes(data=True) = ' + str(G.nodes(data=True))) ```  Now, why would I want to relabel nodes the same as before? This was actually a corner case of an algorithm that did relabeling. It was supposed to do nothing in this case, but instead it messed the graph, so I got to notice. 
issue
Parameters for Barabasi-Albert generator#TITLE_END#I'm trying to reproduce the synthetic networks described in some papers, namely:. - Catastrophic cascade of failures in interdependent networks, Buldyrev et al., published on Nature in 2010 with a separately provided Supplementary Information - Small Cluster in Cyber Physical Systems, Huang et al. 2014 - Catastrophic cascade of failures in interdependent networks, Havlin et al. 2010, this is on the Arxiv and somewhat clarifies the first  I see they all reference the Barabasi and Albert paper "Emergence of Scaling in Random Networks" when they talk about how they built their networks. It's the same paper where the algorithm to generate the BA model is described.  They talk about creating a couple of a scale-free networks following 2 identical power-law degree distributions $P_A(k) = P_B(k) ∝ k^{-λ}$.  However, they are not clear on when they use that algorithm and when not. In fact, they also create use power law distributions with an exponent different than 3 (e.g. 2.5 and 2.7). If I understood the BA algorithm correctly, it can only generate distributions with a power law exponent that's exactly 3, so they can't be using it in all cases.  Here's a reference to the [discussion](http://cs.stackexchange.com/q/39764) on CS StackExchange.  Is there an algorithm in this library to model an undirected graph which nodes are organized according to power law distribution with a given exponent, like [this one does](http://igraph.org/r/doc/static.power.law.game.html)?  Thanks. 
comment
Thank you for this PR.  For some corner cases, `spring_layout` spreads nodes differently in this PR than in 1.9.1. Here's a test case, add a free node to a densely connected graph  ``` import networkx as nx import matplotlib.pyplot as plt  G = nx.barabasi_albert_graph(99, 3, 5724916525465685432) G.add_node(100)  layout_pos = nx.spring_layout(G, dim=2, scale=1.) nx.draw_networkx(G, pos=layout_pos) plt.show() plt.close() ```  Results for v1.9.1 ![spring_layout_1 9 1](https://cloud.githubusercontent.com/assets/1441393/9663354/5508d958-5264-11e5-91ab-586a0c50a5d7.png)  Results for this PR ![spring_layout_pr](https://cloud.githubusercontent.com/assets/1441393/9663278/f5128bf2-5263-11e5-94ec-f8a4681bf4ff.png)  To reproduce, I swapped the module `layout.py` found in 1.9.1 and the one found in this PR, remembering to erase the compiled `layout.pyc`. I'm not sure what behavior is the most preferable here, but I'm sure it's different.   Comparing the 1.9.1 layout module with the one in your PR, some interesting can be found. The biggest one I see is that the second to last line of the functions `_fruchterman_reingold` and `_sparse_fruchterman_reingold` went missing. Restoring that line fixes the problem for me when calling `spring_layout` in my larger programs.  ```     t-=dt     pos=_rescale_layout(pos) return pos ```  Other differences I noted. In function `fruchterman_reingold_layout`, `pos_arr` is defined and overwritten  ``` if pos is not None:         dom_size = max(np.array(pos.values()).flatten())         pos_arr=np.asarray(np.random.random((len(G),dim)))*dom_size         pos_arr=np.asarray(np.random.random((len(G),dim))) ```  `t` is defined like this in `_fruchterman_reingold`, as in v1.10  ``` # compute this in case our domain becomes bigger than 1x1. t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1]))*0.1 ```  but it's defined like this in `_sparse_fruchterman_reingold`, as in v1.9.1  ``` # the initial "temperature"  is about .1 of domain area (=1x1) # this is the largest step allowed in the dynamics. t=0.1 ```  I didn't test the other layouts, so there may be other surprises. 
comment
By more complex I mean I used it in a bigger piece of code, but could not isolate the problem. Now I found it and I edited my post to include a test case. I used `spring_layout`.  It would help reproducibility to add a `seed` parameter to these functions. An instance of NumPy random generator could be initialized with that seed inside each functions, like this  ``` my_np_random = np.random.RandomState(seed) ``` 
comment
Thank you for looking into this.  Declaring a separate instance of `RandomState` would avoid creating unwanted side effects. Same goes for Python's `random` module, I usually create a separate instance  ``` my_random = random.Random(seed) ```  In fact, I just noticed that graph generators, like [this](https://github.com/networkx/networkx/blob/v1.10/networkx/generators/random_graphs.py#L47) and [this](https://github.com/networkx/networkx/blob/v1.10/networkx/generators/random_graphs.py#L602) change the default seed for `random`, which may be another thing worth looking into. Should I open an issue?  ``` if seed is not None:     random.seed(seed) ``` 
comment
Thank you. Would it be possible to add the `scale` parameter to `random_layout`? It's the only layout lacking it.  The center from v1.10 parameter could be added back, IMHO. All it takes is a call to a function `_recenter(node_pos, center)` at the end of the layout functions, and maybe a check for fixed positions.  This way we could keep functionalities introduced in 1.10, but make them compatible with v <= 1.9.1. The default center would need to be 0.5, 0.5, and then scaled.  _EDIT:_ I see [a "fixme"](https://github.com/dschult/networkx/blob/fix-layout/networkx/drawing/layout.py#L158) at the end of `shell_layout`  Also, the docstring mentions `fruchterman_reingold_layout`, that I can't find [in the doc](http://networkx.github.io/documentation/development/reference/drawing.html). Maybe this one is desired.  ``` # The same using longer function name      >>> pos=nx.fruchterman_reingold_layout(G)      >>> pos=nx.fruchterman_reingold_layout(G) ``` 
comment
Thank you. I tested this and it works for me.  Below are some tests I written, maybe you can turn them into proper unit tests.  ``` import numpy as np import networkx as nx import matplotlib.pyplot as plt  def check_inside(layout_pos, scale, center):     half_scale = scale / 2.0     left_border = center[0] - half_scale     right_border = center[0] + half_scale     bottom_border = center[1] - half_scale     top_border = center[1] + half_scale      # check if positions are inside the box     for node, pos in layout_pos.items():         if not left_border <= pos[0] <= right_border:             print('node {} pos x outside box'.format(node))         if not bottom_border <= pos[1] <= top_border:             print('node {} pos y outside box'.format(node))  def check_center(layout_pos, scale, center, tolerance_perc):     # calculate the actual area occupied by the nodes     first_it = True     for pos in layout_pos.values():         x = pos[0]         y = pos[1]         if first_it is True:             x_min = x             x_max = x             y_min = y             y_max = y             first_it = False         else:             if x > x_max:                 x_max = x             elif x < x_min:                 x_min = x             if y > y_max:                 y_max = y             elif y < y_min:                 y_min = y     x_span = x_max - x_min     y_span = y_max - y_min      # check if the center of the area occupied by the nodes is the intended one     actual_center = np.array([x_min + x_span / 2.0, y_min + y_span / 2.0])     if abs(actual_center[0] - center[0]) > scale * tolerance_perc:         print('the x coordinate of the center is far from the intended one')     if abs(actual_center[1] - center[1]) > scale * tolerance_perc:         print('the y coordinate of the center is far from the intended one')   G = nx.barabasi_albert_graph(99, 3, 5724916525465685432)  # create a densely connected graph  G.add_edge(G.number_of_nodes(), G.number_of_nodes() - 1)  # add a new node connected by a single edge G.add_node(G.number_of_nodes())  # add a new unconnected node  base_center = np.array([0.5, 0.5]) scales = [0.5, 1.0, 1.5, 2.0] tolerance_perc = 0.1 # tolerance for comparing the final center and the intended one  for scale in scales:     print('scale = {}'.format(scale))     center = base_center * scale     # layout_pos = nx.random_layout(G, dim=2, scale=scale, center=center)     # layout_pos = nx.circular_layout(G, dim=2, scale=scale/2.0, center=center)     # layout_pos = nx.shell_layout(G, dim=2, scale=scale/2.0, center=center)     layout_pos = nx.spring_layout(G, dim=2, scale=scale, center=center)     check_inside(layout_pos, scale, center)     check_center(layout_pos, scale, center, tolerance_perc)     nx.draw_networkx(G, pos=layout_pos)     plt.show()     plt.close() ``` 
comment
Thank you and congratulations for your work  What about adding a `seed` parameter, is that an option that was considered? Thanks. 
comment
Thanks, I guess we can close #1750 then. 
comment
[The link](http://networkx.readthedocs.org/en/networkx-1.10/) to the 1.10 documentation found [here](https://networkx.github.io/documentation.html) is broken. 
comment
I propose Build errors on readthedocs  #1667  Documentation is not automatically built on commit #1571  Graphml default attribute values are not applied #1398   Thanks. 
comment
I guess #1783 could also be considered for the next release. 
comment
Now that release 1.10 is included in Anaconda, I have to tell people to manually patch against #1760  Is there any news on 1.10.1? Thanks. 
comment
What about using the same documentation style as 1.9.1, would that prevent some errors? 
