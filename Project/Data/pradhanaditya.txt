issue
Lowest Common Ancestors (LCA) algorithm does not return the correct ancestor for every spanning tree#TITLE_END#<!--- Provide a general summary of the issue in the Title above --> I created a `networkx` graph from a big TVM relay graph and tried to use the `nx.all_pairs_lowest_common_ancestor` method to determine the LCA of two nodes, where one node is an immediate parent of the other node. I think we would expect the immediate parent to be the result but that was not the case. Instead, some other ancestor was returned. On further investigation, found that I could get the expected result if the spanning tree returned by the following line of code is different (in `all_pairs_lowest_common_ancestor`): ```python spanning_tree = nx.dfs_tree(G, root) ```  Luckily, I was able to reduce this issue in a small graph but we have to do some extra work to replicate the issue. The graph can be constructed as follows: ```python mg = nx.DiGraph() for i in range(0, 16):    mg.add_node(i) mg.add_edge(0, 1) mg.add_edge(1, 2) mg.add_edge(1, 14) mg.add_edge(2, 3) mg.add_edge(3, 4) mg.add_edge(4, 5) mg.add_edge(5, 6) mg.add_edge(6, 7) mg.add_edge(6, 15) mg.add_edge(7, 8) mg.add_edge(7, 10) mg.add_edge(8, 9) mg.add_edge(9, 11) mg.add_edge(10, 9) mg.add_edge(11, 12) mg.add_edge(12, 13) mg.add_edge(14, 10) mg.add_edge(15, 11) ```  Since the above is a simple graph, the `all_pairs_lowest_common_ancestor` would pick the obvious spanning tree which would result in the correct result if we wish to find the LCA of the pair (11, 12). However, if suppose the following (valid) spanning tree is selected by `dfs_tree` (a similar thing happened in my relay graph, the `dfs_tree` itself returns a similar spanning tree):  ```python # Replacing the call to dfs_tree in lowest_common_ancestors.py::all_pairs_lowest_common_ancestor by the below spanning tree for the above graph  # spanning_tree = nx.dfs_tree(G, root) spanning_tree = nx.DiGraph() for i in range(0, 16):     spanning_tree.add_node(i) spanning_tree.add_edge(0, 1) spanning_tree.add_edge(1, 2) spanning_tree.add_edge(1, 14) spanning_tree.add_edge(2, 3) spanning_tree.add_edge(3, 4) spanning_tree.add_edge(4, 5) spanning_tree.add_edge(5, 6) spanning_tree.add_edge(6, 7) spanning_tree.add_edge(6, 15) spanning_tree.add_edge(7, 8) spanning_tree.add_edge(9, 11) spanning_tree.add_edge(10, 9) spanning_tree.add_edge(11, 12) spanning_tree.add_edge(12, 13) spanning_tree.add_edge(14, 10) ```  The following image shows the graph and the spanning tree:  ![networkx_issue_graph](https://github.com/user-attachments/assets/3c62a322-6a40-448e-a9d0-d0dfd0c7193f)  The output for the pair (11, 12) is `8`, which is an ancestor but not the lowest common ancestor. Since, `11` is an immediate parent of `12`, we would expect `11` to be the result.  Please let me know if this is indeed a valid issue or if I'm missing something.  ### Environment Python version: 3.9.20 NetworkX version: 2.8.5 
